
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model MentorProfile
 * 
 */
export type MentorProfile = $Result.DefaultSelection<Prisma.$MentorProfilePayload>
/**
 * Model MenteeProfile
 * 
 */
export type MenteeProfile = $Result.DefaultSelection<Prisma.$MenteeProfilePayload>
/**
 * Model ProgramCycle
 * 
 */
export type ProgramCycle = $Result.DefaultSelection<Prisma.$ProgramCyclePayload>
/**
 * Model Mentorship
 * 
 */
export type Mentorship = $Result.DefaultSelection<Prisma.$MentorshipPayload>
/**
 * Model MentorshipMentee
 * 
 */
export type MentorshipMentee = $Result.DefaultSelection<Prisma.$MentorshipMenteePayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model MeetingMinutes
 * 
 */
export type MeetingMinutes = $Result.DefaultSelection<Prisma.$MeetingMinutesPayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model ProgressNote
 * 
 */
export type ProgressNote = $Result.DefaultSelection<Prisma.$ProgressNotePayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model Portfolio
 * 
 */
export type Portfolio = $Result.DefaultSelection<Prisma.$PortfolioPayload>
/**
 * Model Availability
 * 
 */
export type Availability = $Result.DefaultSelection<Prisma.$AvailabilityPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SessionReflection
 * 
 */
export type SessionReflection = $Result.DefaultSelection<Prisma.$SessionReflectionPayload>
/**
 * Model TodoItem
 * 
 */
export type TodoItem = $Result.DefaultSelection<Prisma.$TodoItemPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model WikiPage
 * 
 */
export type WikiPage = $Result.DefaultSelection<Prisma.$WikiPagePayload>
/**
 * Model Whiteboard
 * 
 */
export type Whiteboard = $Result.DefaultSelection<Prisma.$WhiteboardPayload>
/**
 * Model Artboard
 * 
 */
export type Artboard = $Result.DefaultSelection<Prisma.$ArtboardPayload>
/**
 * Model Slide
 * 
 */
export type Slide = $Result.DefaultSelection<Prisma.$SlidePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorProfile`: Exposes CRUD operations for the **MentorProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorProfiles
    * const mentorProfiles = await prisma.mentorProfile.findMany()
    * ```
    */
  get mentorProfile(): Prisma.MentorProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteeProfile`: Exposes CRUD operations for the **MenteeProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteeProfiles
    * const menteeProfiles = await prisma.menteeProfile.findMany()
    * ```
    */
  get menteeProfile(): Prisma.MenteeProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programCycle`: Exposes CRUD operations for the **ProgramCycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramCycles
    * const programCycles = await prisma.programCycle.findMany()
    * ```
    */
  get programCycle(): Prisma.ProgramCycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorship`: Exposes CRUD operations for the **Mentorship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentorships
    * const mentorships = await prisma.mentorship.findMany()
    * ```
    */
  get mentorship(): Prisma.MentorshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorshipMentee`: Exposes CRUD operations for the **MentorshipMentee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorshipMentees
    * const mentorshipMentees = await prisma.mentorshipMentee.findMany()
    * ```
    */
  get mentorshipMentee(): Prisma.MentorshipMenteeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meetingMinutes`: Exposes CRUD operations for the **MeetingMinutes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeetingMinutes
    * const meetingMinutes = await prisma.meetingMinutes.findMany()
    * ```
    */
  get meetingMinutes(): Prisma.MeetingMinutesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.progressNote`: Exposes CRUD operations for the **ProgressNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgressNotes
    * const progressNotes = await prisma.progressNote.findMany()
    * ```
    */
  get progressNote(): Prisma.ProgressNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **Portfolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portfolios
    * const portfolios = await prisma.portfolio.findMany()
    * ```
    */
  get portfolio(): Prisma.PortfolioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availability`: Exposes CRUD operations for the **Availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Availabilities
    * const availabilities = await prisma.availability.findMany()
    * ```
    */
  get availability(): Prisma.AvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionReflection`: Exposes CRUD operations for the **SessionReflection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionReflections
    * const sessionReflections = await prisma.sessionReflection.findMany()
    * ```
    */
  get sessionReflection(): Prisma.SessionReflectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.todoItem`: Exposes CRUD operations for the **TodoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoItems
    * const todoItems = await prisma.todoItem.findMany()
    * ```
    */
  get todoItem(): Prisma.TodoItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wikiPage`: Exposes CRUD operations for the **WikiPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WikiPages
    * const wikiPages = await prisma.wikiPage.findMany()
    * ```
    */
  get wikiPage(): Prisma.WikiPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whiteboard`: Exposes CRUD operations for the **Whiteboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whiteboards
    * const whiteboards = await prisma.whiteboard.findMany()
    * ```
    */
  get whiteboard(): Prisma.WhiteboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artboard`: Exposes CRUD operations for the **Artboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artboards
    * const artboards = await prisma.artboard.findMany()
    * ```
    */
  get artboard(): Prisma.ArtboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slide`: Exposes CRUD operations for the **Slide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slides
    * const slides = await prisma.slide.findMany()
    * ```
    */
  get slide(): Prisma.SlideDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.0
   * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    MentorProfile: 'MentorProfile',
    MenteeProfile: 'MenteeProfile',
    ProgramCycle: 'ProgramCycle',
    Mentorship: 'Mentorship',
    MentorshipMentee: 'MentorshipMentee',
    Meeting: 'Meeting',
    Attendance: 'Attendance',
    MeetingMinutes: 'MeetingMinutes',
    Goal: 'Goal',
    ProgressNote: 'ProgressNote',
    Feedback: 'Feedback',
    Resource: 'Resource',
    Portfolio: 'Portfolio',
    Availability: 'Availability',
    Notification: 'Notification',
    SessionReflection: 'SessionReflection',
    TodoItem: 'TodoItem',
    ActivityLog: 'ActivityLog',
    SupportTicket: 'SupportTicket',
    TicketComment: 'TicketComment',
    WikiPage: 'WikiPage',
    Whiteboard: 'Whiteboard',
    Artboard: 'Artboard',
    Slide: 'Slide'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "mentorProfile" | "menteeProfile" | "programCycle" | "mentorship" | "mentorshipMentee" | "meeting" | "attendance" | "meetingMinutes" | "goal" | "progressNote" | "feedback" | "resource" | "portfolio" | "availability" | "notification" | "sessionReflection" | "todoItem" | "activityLog" | "supportTicket" | "ticketComment" | "wikiPage" | "whiteboard" | "artboard" | "slide"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      MentorProfile: {
        payload: Prisma.$MentorProfilePayload<ExtArgs>
        fields: Prisma.MentorProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>
          }
          findFirst: {
            args: Prisma.MentorProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>
          }
          findMany: {
            args: Prisma.MentorProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>[]
          }
          create: {
            args: Prisma.MentorProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>
          }
          createMany: {
            args: Prisma.MentorProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>[]
          }
          delete: {
            args: Prisma.MentorProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>
          }
          update: {
            args: Prisma.MentorProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>
          }
          deleteMany: {
            args: Prisma.MentorProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>[]
          }
          upsert: {
            args: Prisma.MentorProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorProfilePayload>
          }
          aggregate: {
            args: Prisma.MentorProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorProfile>
          }
          groupBy: {
            args: Prisma.MentorProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorProfileCountArgs<ExtArgs>
            result: $Utils.Optional<MentorProfileCountAggregateOutputType> | number
          }
        }
      }
      MenteeProfile: {
        payload: Prisma.$MenteeProfilePayload<ExtArgs>
        fields: Prisma.MenteeProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteeProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteeProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>
          }
          findFirst: {
            args: Prisma.MenteeProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteeProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>
          }
          findMany: {
            args: Prisma.MenteeProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>[]
          }
          create: {
            args: Prisma.MenteeProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>
          }
          createMany: {
            args: Prisma.MenteeProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteeProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>[]
          }
          delete: {
            args: Prisma.MenteeProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>
          }
          update: {
            args: Prisma.MenteeProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>
          }
          deleteMany: {
            args: Prisma.MenteeProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteeProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteeProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>[]
          }
          upsert: {
            args: Prisma.MenteeProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeProfilePayload>
          }
          aggregate: {
            args: Prisma.MenteeProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteeProfile>
          }
          groupBy: {
            args: Prisma.MenteeProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteeProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteeProfileCountArgs<ExtArgs>
            result: $Utils.Optional<MenteeProfileCountAggregateOutputType> | number
          }
        }
      }
      ProgramCycle: {
        payload: Prisma.$ProgramCyclePayload<ExtArgs>
        fields: Prisma.ProgramCycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramCycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramCycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>
          }
          findFirst: {
            args: Prisma.ProgramCycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramCycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>
          }
          findMany: {
            args: Prisma.ProgramCycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>[]
          }
          create: {
            args: Prisma.ProgramCycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>
          }
          createMany: {
            args: Prisma.ProgramCycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCycleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>[]
          }
          delete: {
            args: Prisma.ProgramCycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>
          }
          update: {
            args: Prisma.ProgramCycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>
          }
          deleteMany: {
            args: Prisma.ProgramCycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramCycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramCycleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>[]
          }
          upsert: {
            args: Prisma.ProgramCycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramCyclePayload>
          }
          aggregate: {
            args: Prisma.ProgramCycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramCycle>
          }
          groupBy: {
            args: Prisma.ProgramCycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramCycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCycleCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCycleCountAggregateOutputType> | number
          }
        }
      }
      Mentorship: {
        payload: Prisma.$MentorshipPayload<ExtArgs>
        fields: Prisma.MentorshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          findFirst: {
            args: Prisma.MentorshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          findMany: {
            args: Prisma.MentorshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
          }
          create: {
            args: Prisma.MentorshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          createMany: {
            args: Prisma.MentorshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
          }
          delete: {
            args: Prisma.MentorshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          update: {
            args: Prisma.MentorshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          deleteMany: {
            args: Prisma.MentorshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
          }
          upsert: {
            args: Prisma.MentorshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          aggregate: {
            args: Prisma.MentorshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorship>
          }
          groupBy: {
            args: Prisma.MentorshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorshipCountArgs<ExtArgs>
            result: $Utils.Optional<MentorshipCountAggregateOutputType> | number
          }
        }
      }
      MentorshipMentee: {
        payload: Prisma.$MentorshipMenteePayload<ExtArgs>
        fields: Prisma.MentorshipMenteeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorshipMenteeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorshipMenteeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>
          }
          findFirst: {
            args: Prisma.MentorshipMenteeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorshipMenteeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>
          }
          findMany: {
            args: Prisma.MentorshipMenteeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>[]
          }
          create: {
            args: Prisma.MentorshipMenteeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>
          }
          createMany: {
            args: Prisma.MentorshipMenteeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorshipMenteeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>[]
          }
          delete: {
            args: Prisma.MentorshipMenteeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>
          }
          update: {
            args: Prisma.MentorshipMenteeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>
          }
          deleteMany: {
            args: Prisma.MentorshipMenteeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorshipMenteeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorshipMenteeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>[]
          }
          upsert: {
            args: Prisma.MentorshipMenteeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipMenteePayload>
          }
          aggregate: {
            args: Prisma.MentorshipMenteeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorshipMentee>
          }
          groupBy: {
            args: Prisma.MentorshipMenteeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorshipMenteeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorshipMenteeCountArgs<ExtArgs>
            result: $Utils.Optional<MentorshipMenteeCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeetingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      MeetingMinutes: {
        payload: Prisma.$MeetingMinutesPayload<ExtArgs>
        fields: Prisma.MeetingMinutesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingMinutesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingMinutesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>
          }
          findFirst: {
            args: Prisma.MeetingMinutesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingMinutesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>
          }
          findMany: {
            args: Prisma.MeetingMinutesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>[]
          }
          create: {
            args: Prisma.MeetingMinutesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>
          }
          createMany: {
            args: Prisma.MeetingMinutesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingMinutesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>[]
          }
          delete: {
            args: Prisma.MeetingMinutesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>
          }
          update: {
            args: Prisma.MeetingMinutesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>
          }
          deleteMany: {
            args: Prisma.MeetingMinutesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingMinutesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeetingMinutesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>[]
          }
          upsert: {
            args: Prisma.MeetingMinutesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingMinutesPayload>
          }
          aggregate: {
            args: Prisma.MeetingMinutesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingMinutes>
          }
          groupBy: {
            args: Prisma.MeetingMinutesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingMinutesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingMinutesCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingMinutesCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      ProgressNote: {
        payload: Prisma.$ProgressNotePayload<ExtArgs>
        fields: Prisma.ProgressNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgressNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgressNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>
          }
          findFirst: {
            args: Prisma.ProgressNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgressNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>
          }
          findMany: {
            args: Prisma.ProgressNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>[]
          }
          create: {
            args: Prisma.ProgressNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>
          }
          createMany: {
            args: Prisma.ProgressNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgressNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>[]
          }
          delete: {
            args: Prisma.ProgressNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>
          }
          update: {
            args: Prisma.ProgressNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>
          }
          deleteMany: {
            args: Prisma.ProgressNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgressNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgressNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>[]
          }
          upsert: {
            args: Prisma.ProgressNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressNotePayload>
          }
          aggregate: {
            args: Prisma.ProgressNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgressNote>
          }
          groupBy: {
            args: Prisma.ProgressNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgressNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgressNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ProgressNoteCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Portfolio: {
        payload: Prisma.$PortfolioPayload<ExtArgs>
        fields: Prisma.PortfolioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findFirst: {
            args: Prisma.PortfolioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findMany: {
            args: Prisma.PortfolioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          create: {
            args: Prisma.PortfolioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          createMany: {
            args: Prisma.PortfolioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          delete: {
            args: Prisma.PortfolioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          update: {
            args: Prisma.PortfolioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          aggregate: {
            args: Prisma.PortfolioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolio>
          }
          groupBy: {
            args: Prisma.PortfolioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCountAggregateOutputType> | number
          }
        }
      }
      Availability: {
        payload: Prisma.$AvailabilityPayload<ExtArgs>
        fields: Prisma.AvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findMany: {
            args: Prisma.AvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          create: {
            args: Prisma.AvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          createMany: {
            args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          delete: {
            args: Prisma.AvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          update: {
            args: Prisma.AvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.AvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailability>
          }
          groupBy: {
            args: Prisma.AvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SessionReflection: {
        payload: Prisma.$SessionReflectionPayload<ExtArgs>
        fields: Prisma.SessionReflectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionReflectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionReflectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>
          }
          findFirst: {
            args: Prisma.SessionReflectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionReflectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>
          }
          findMany: {
            args: Prisma.SessionReflectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>[]
          }
          create: {
            args: Prisma.SessionReflectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>
          }
          createMany: {
            args: Prisma.SessionReflectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionReflectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>[]
          }
          delete: {
            args: Prisma.SessionReflectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>
          }
          update: {
            args: Prisma.SessionReflectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>
          }
          deleteMany: {
            args: Prisma.SessionReflectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionReflectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionReflectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>[]
          }
          upsert: {
            args: Prisma.SessionReflectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionReflectionPayload>
          }
          aggregate: {
            args: Prisma.SessionReflectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionReflection>
          }
          groupBy: {
            args: Prisma.SessionReflectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionReflectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionReflectionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionReflectionCountAggregateOutputType> | number
          }
        }
      }
      TodoItem: {
        payload: Prisma.$TodoItemPayload<ExtArgs>
        fields: Prisma.TodoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TodoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TodoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          findFirst: {
            args: Prisma.TodoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TodoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          findMany: {
            args: Prisma.TodoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>[]
          }
          create: {
            args: Prisma.TodoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          createMany: {
            args: Prisma.TodoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TodoItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>[]
          }
          delete: {
            args: Prisma.TodoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          update: {
            args: Prisma.TodoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          deleteMany: {
            args: Prisma.TodoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TodoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TodoItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>[]
          }
          upsert: {
            args: Prisma.TodoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          aggregate: {
            args: Prisma.TodoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTodoItem>
          }
          groupBy: {
            args: Prisma.TodoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TodoItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TodoItemCountArgs<ExtArgs>
            result: $Utils.Optional<TodoItemCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      WikiPage: {
        payload: Prisma.$WikiPagePayload<ExtArgs>
        fields: Prisma.WikiPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WikiPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WikiPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          findFirst: {
            args: Prisma.WikiPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WikiPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          findMany: {
            args: Prisma.WikiPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          create: {
            args: Prisma.WikiPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          createMany: {
            args: Prisma.WikiPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WikiPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          delete: {
            args: Prisma.WikiPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          update: {
            args: Prisma.WikiPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          deleteMany: {
            args: Prisma.WikiPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WikiPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WikiPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          upsert: {
            args: Prisma.WikiPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          aggregate: {
            args: Prisma.WikiPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWikiPage>
          }
          groupBy: {
            args: Prisma.WikiPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WikiPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WikiPageCountArgs<ExtArgs>
            result: $Utils.Optional<WikiPageCountAggregateOutputType> | number
          }
        }
      }
      Whiteboard: {
        payload: Prisma.$WhiteboardPayload<ExtArgs>
        fields: Prisma.WhiteboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhiteboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhiteboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          findFirst: {
            args: Prisma.WhiteboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhiteboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          findMany: {
            args: Prisma.WhiteboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          create: {
            args: Prisma.WhiteboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          createMany: {
            args: Prisma.WhiteboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhiteboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          delete: {
            args: Prisma.WhiteboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          update: {
            args: Prisma.WhiteboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          deleteMany: {
            args: Prisma.WhiteboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhiteboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhiteboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          upsert: {
            args: Prisma.WhiteboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          aggregate: {
            args: Prisma.WhiteboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhiteboard>
          }
          groupBy: {
            args: Prisma.WhiteboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhiteboardCountArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardCountAggregateOutputType> | number
          }
        }
      }
      Artboard: {
        payload: Prisma.$ArtboardPayload<ExtArgs>
        fields: Prisma.ArtboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>
          }
          findFirst: {
            args: Prisma.ArtboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>
          }
          findMany: {
            args: Prisma.ArtboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>[]
          }
          create: {
            args: Prisma.ArtboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>
          }
          createMany: {
            args: Prisma.ArtboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>[]
          }
          delete: {
            args: Prisma.ArtboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>
          }
          update: {
            args: Prisma.ArtboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>
          }
          deleteMany: {
            args: Prisma.ArtboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>[]
          }
          upsert: {
            args: Prisma.ArtboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtboardPayload>
          }
          aggregate: {
            args: Prisma.ArtboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtboard>
          }
          groupBy: {
            args: Prisma.ArtboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtboardCountArgs<ExtArgs>
            result: $Utils.Optional<ArtboardCountAggregateOutputType> | number
          }
        }
      }
      Slide: {
        payload: Prisma.$SlidePayload<ExtArgs>
        fields: Prisma.SlideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>
          }
          findFirst: {
            args: Prisma.SlideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>
          }
          findMany: {
            args: Prisma.SlideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>[]
          }
          create: {
            args: Prisma.SlideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>
          }
          createMany: {
            args: Prisma.SlideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SlideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>[]
          }
          delete: {
            args: Prisma.SlideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>
          }
          update: {
            args: Prisma.SlideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>
          }
          deleteMany: {
            args: Prisma.SlideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SlideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>[]
          }
          upsert: {
            args: Prisma.SlideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlidePayload>
          }
          aggregate: {
            args: Prisma.SlideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlide>
          }
          groupBy: {
            args: Prisma.SlideGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlideGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlideCountArgs<ExtArgs>
            result: $Utils.Optional<SlideCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    mentorProfile?: MentorProfileOmit
    menteeProfile?: MenteeProfileOmit
    programCycle?: ProgramCycleOmit
    mentorship?: MentorshipOmit
    mentorshipMentee?: MentorshipMenteeOmit
    meeting?: MeetingOmit
    attendance?: AttendanceOmit
    meetingMinutes?: MeetingMinutesOmit
    goal?: GoalOmit
    progressNote?: ProgressNoteOmit
    feedback?: FeedbackOmit
    resource?: ResourceOmit
    portfolio?: PortfolioOmit
    availability?: AvailabilityOmit
    notification?: NotificationOmit
    sessionReflection?: SessionReflectionOmit
    todoItem?: TodoItemOmit
    activityLog?: ActivityLogOmit
    supportTicket?: SupportTicketOmit
    ticketComment?: TicketCommentOmit
    wikiPage?: WikiPageOmit
    whiteboard?: WhiteboardOmit
    artboard?: ArtboardOmit
    slide?: SlideOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    mentorships: number
    menteeships: number
    meetingsCreated: number
    attendances: number
    minutesCreated: number
    goalsCreated: number
    feedbackGiven: number
    feedbackReceived: number
    resourcesUploaded: number
    notifications: number
    portfolios: number
    availabilities: number
    sessionReflections: number
    todoItems: number
    activityLogs: number
    ticketsCreated: number
    assignedTickets: number
    ticketComments: number
    wikiPages: number
    whiteboards: number
    slides: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    mentorships?: boolean | UserCountOutputTypeCountMentorshipsArgs
    menteeships?: boolean | UserCountOutputTypeCountMenteeshipsArgs
    meetingsCreated?: boolean | UserCountOutputTypeCountMeetingsCreatedArgs
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
    minutesCreated?: boolean | UserCountOutputTypeCountMinutesCreatedArgs
    goalsCreated?: boolean | UserCountOutputTypeCountGoalsCreatedArgs
    feedbackGiven?: boolean | UserCountOutputTypeCountFeedbackGivenArgs
    feedbackReceived?: boolean | UserCountOutputTypeCountFeedbackReceivedArgs
    resourcesUploaded?: boolean | UserCountOutputTypeCountResourcesUploadedArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    portfolios?: boolean | UserCountOutputTypeCountPortfoliosArgs
    availabilities?: boolean | UserCountOutputTypeCountAvailabilitiesArgs
    sessionReflections?: boolean | UserCountOutputTypeCountSessionReflectionsArgs
    todoItems?: boolean | UserCountOutputTypeCountTodoItemsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    ticketsCreated?: boolean | UserCountOutputTypeCountTicketsCreatedArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    ticketComments?: boolean | UserCountOutputTypeCountTicketCommentsArgs
    wikiPages?: boolean | UserCountOutputTypeCountWikiPagesArgs
    whiteboards?: boolean | UserCountOutputTypeCountWhiteboardsArgs
    slides?: boolean | UserCountOutputTypeCountSlidesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMenteeshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipMenteeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeetingsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMinutesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingMinutesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGoalsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourcesUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPortfoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAvailabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionReflectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTodoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWikiPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WikiPageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhiteboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhiteboardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSlidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlideWhereInput
  }


  /**
   * Count Type ProgramCycleCountOutputType
   */

  export type ProgramCycleCountOutputType = {
    mentorships: number
  }

  export type ProgramCycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorships?: boolean | ProgramCycleCountOutputTypeCountMentorshipsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCycleCountOutputType without action
   */
  export type ProgramCycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycleCountOutputType
     */
    select?: ProgramCycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCycleCountOutputType without action
   */
  export type ProgramCycleCountOutputTypeCountMentorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipWhereInput
  }


  /**
   * Count Type MentorshipCountOutputType
   */

  export type MentorshipCountOutputType = {
    mentees: number
    meetings: number
    goals: number
    feedbacks: number
  }

  export type MentorshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentees?: boolean | MentorshipCountOutputTypeCountMenteesArgs
    meetings?: boolean | MentorshipCountOutputTypeCountMeetingsArgs
    goals?: boolean | MentorshipCountOutputTypeCountGoalsArgs
    feedbacks?: boolean | MentorshipCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * MentorshipCountOutputType without action
   */
  export type MentorshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipCountOutputType
     */
    select?: MentorshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MentorshipCountOutputType without action
   */
  export type MentorshipCountOutputTypeCountMenteesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipMenteeWhereInput
  }

  /**
   * MentorshipCountOutputType without action
   */
  export type MentorshipCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * MentorshipCountOutputType without action
   */
  export type MentorshipCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * MentorshipCountOutputType without action
   */
  export type MentorshipCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }


  /**
   * Count Type MeetingCountOutputType
   */

  export type MeetingCountOutputType = {
    attendances: number
    minutes: number
    sessionReflections: number
  }

  export type MeetingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | MeetingCountOutputTypeCountAttendancesArgs
    minutes?: boolean | MeetingCountOutputTypeCountMinutesArgs
    sessionReflections?: boolean | MeetingCountOutputTypeCountSessionReflectionsArgs
  }

  // Custom InputTypes
  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingCountOutputType
     */
    select?: MeetingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountMinutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingMinutesWhereInput
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountSessionReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionReflectionWhereInput
  }


  /**
   * Count Type GoalCountOutputType
   */

  export type GoalCountOutputType = {
    progressNotes: number
  }

  export type GoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progressNotes?: boolean | GoalCountOutputTypeCountProgressNotesArgs
  }

  // Custom InputTypes
  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCountOutputType
     */
    select?: GoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountProgressNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressNoteWhereInput
  }


  /**
   * Count Type SessionReflectionCountOutputType
   */

  export type SessionReflectionCountOutputType = {
    todoItems: number
  }

  export type SessionReflectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    todoItems?: boolean | SessionReflectionCountOutputTypeCountTodoItemsArgs
  }

  // Custom InputTypes
  /**
   * SessionReflectionCountOutputType without action
   */
  export type SessionReflectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflectionCountOutputType
     */
    select?: SessionReflectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionReflectionCountOutputType without action
   */
  export type SessionReflectionCountOutputTypeCountTodoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoItemWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    comments: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | SupportTicketCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }


  /**
   * Count Type WhiteboardCountOutputType
   */

  export type WhiteboardCountOutputType = {
    artboards: number
  }

  export type WhiteboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artboards?: boolean | WhiteboardCountOutputTypeCountArtboardsArgs
  }

  // Custom InputTypes
  /**
   * WhiteboardCountOutputType without action
   */
  export type WhiteboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardCountOutputType
     */
    select?: WhiteboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhiteboardCountOutputType without action
   */
  export type WhiteboardCountOutputTypeCountArtboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtboardWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    avatar: string | null
    bio: string | null
    passwordHash: string | null
    role: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    avatar: string | null
    bio: string | null
    passwordHash: string | null
    role: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    emailVerified: number
    image: number
    avatar: number
    bio: number
    passwordHash: number
    role: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    image?: true
    avatar?: true
    bio?: true
    passwordHash?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    image?: true
    avatar?: true
    bio?: true
    passwordHash?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    image?: true
    avatar?: true
    bio?: true
    passwordHash?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    avatar: string | null
    bio: string | null
    passwordHash: string | null
    role: string
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatar?: boolean
    bio?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorProfile?: boolean | User$mentorProfileArgs<ExtArgs>
    menteeProfile?: boolean | User$menteeProfileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    mentorships?: boolean | User$mentorshipsArgs<ExtArgs>
    menteeships?: boolean | User$menteeshipsArgs<ExtArgs>
    meetingsCreated?: boolean | User$meetingsCreatedArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    minutesCreated?: boolean | User$minutesCreatedArgs<ExtArgs>
    goalsCreated?: boolean | User$goalsCreatedArgs<ExtArgs>
    feedbackGiven?: boolean | User$feedbackGivenArgs<ExtArgs>
    feedbackReceived?: boolean | User$feedbackReceivedArgs<ExtArgs>
    resourcesUploaded?: boolean | User$resourcesUploadedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    portfolios?: boolean | User$portfoliosArgs<ExtArgs>
    availabilities?: boolean | User$availabilitiesArgs<ExtArgs>
    sessionReflections?: boolean | User$sessionReflectionsArgs<ExtArgs>
    todoItems?: boolean | User$todoItemsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    ticketsCreated?: boolean | User$ticketsCreatedArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    wikiPages?: boolean | User$wikiPagesArgs<ExtArgs>
    whiteboards?: boolean | User$whiteboardsArgs<ExtArgs>
    slides?: boolean | User$slidesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatar?: boolean
    bio?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatar?: boolean
    bio?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatar?: boolean
    bio?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "emailVerified" | "image" | "avatar" | "bio" | "passwordHash" | "role" | "phone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorProfile?: boolean | User$mentorProfileArgs<ExtArgs>
    menteeProfile?: boolean | User$menteeProfileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    mentorships?: boolean | User$mentorshipsArgs<ExtArgs>
    menteeships?: boolean | User$menteeshipsArgs<ExtArgs>
    meetingsCreated?: boolean | User$meetingsCreatedArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    minutesCreated?: boolean | User$minutesCreatedArgs<ExtArgs>
    goalsCreated?: boolean | User$goalsCreatedArgs<ExtArgs>
    feedbackGiven?: boolean | User$feedbackGivenArgs<ExtArgs>
    feedbackReceived?: boolean | User$feedbackReceivedArgs<ExtArgs>
    resourcesUploaded?: boolean | User$resourcesUploadedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    portfolios?: boolean | User$portfoliosArgs<ExtArgs>
    availabilities?: boolean | User$availabilitiesArgs<ExtArgs>
    sessionReflections?: boolean | User$sessionReflectionsArgs<ExtArgs>
    todoItems?: boolean | User$todoItemsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    ticketsCreated?: boolean | User$ticketsCreatedArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    wikiPages?: boolean | User$wikiPagesArgs<ExtArgs>
    whiteboards?: boolean | User$whiteboardsArgs<ExtArgs>
    slides?: boolean | User$slidesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      mentorProfile: Prisma.$MentorProfilePayload<ExtArgs> | null
      menteeProfile: Prisma.$MenteeProfilePayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      mentorships: Prisma.$MentorshipPayload<ExtArgs>[]
      menteeships: Prisma.$MentorshipMenteePayload<ExtArgs>[]
      meetingsCreated: Prisma.$MeetingPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      minutesCreated: Prisma.$MeetingMinutesPayload<ExtArgs>[]
      goalsCreated: Prisma.$GoalPayload<ExtArgs>[]
      feedbackGiven: Prisma.$FeedbackPayload<ExtArgs>[]
      feedbackReceived: Prisma.$FeedbackPayload<ExtArgs>[]
      resourcesUploaded: Prisma.$ResourcePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      portfolios: Prisma.$PortfolioPayload<ExtArgs>[]
      availabilities: Prisma.$AvailabilityPayload<ExtArgs>[]
      sessionReflections: Prisma.$SessionReflectionPayload<ExtArgs>[]
      todoItems: Prisma.$TodoItemPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      ticketsCreated: Prisma.$SupportTicketPayload<ExtArgs>[]
      assignedTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      ticketComments: Prisma.$TicketCommentPayload<ExtArgs>[]
      wikiPages: Prisma.$WikiPagePayload<ExtArgs>[]
      whiteboards: Prisma.$WhiteboardPayload<ExtArgs>[]
      slides: Prisma.$SlidePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      lastName: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      avatar: string | null
      bio: string | null
      passwordHash: string | null
      role: string
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentorProfile<T extends User$mentorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$mentorProfileArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    menteeProfile<T extends User$menteeProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$menteeProfileArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentorships<T extends User$mentorshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$mentorshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    menteeships<T extends User$menteeshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$menteeshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetingsCreated<T extends User$meetingsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$meetingsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    minutesCreated<T extends User$minutesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$minutesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goalsCreated<T extends User$goalsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$goalsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackGiven<T extends User$feedbackGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackReceived<T extends User$feedbackReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resourcesUploaded<T extends User$resourcesUploadedArgs<ExtArgs> = {}>(args?: Subset<T, User$resourcesUploadedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    portfolios<T extends User$portfoliosArgs<ExtArgs> = {}>(args?: Subset<T, User$portfoliosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availabilities<T extends User$availabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$availabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionReflections<T extends User$sessionReflectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionReflectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    todoItems<T extends User$todoItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$todoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketsCreated<T extends User$ticketsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketComments<T extends User$ticketCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wikiPages<T extends User$wikiPagesArgs<ExtArgs> = {}>(args?: Subset<T, User$wikiPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whiteboards<T extends User$whiteboardsArgs<ExtArgs> = {}>(args?: Subset<T, User$whiteboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slides<T extends User$slidesArgs<ExtArgs> = {}>(args?: Subset<T, User$slidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.mentorProfile
   */
  export type User$mentorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    where?: MentorProfileWhereInput
  }

  /**
   * User.menteeProfile
   */
  export type User$menteeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    where?: MenteeProfileWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.mentorships
   */
  export type User$mentorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    where?: MentorshipWhereInput
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    cursor?: MentorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * User.menteeships
   */
  export type User$menteeshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    where?: MentorshipMenteeWhereInput
    orderBy?: MentorshipMenteeOrderByWithRelationInput | MentorshipMenteeOrderByWithRelationInput[]
    cursor?: MentorshipMenteeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipMenteeScalarFieldEnum | MentorshipMenteeScalarFieldEnum[]
  }

  /**
   * User.meetingsCreated
   */
  export type User$meetingsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.minutesCreated
   */
  export type User$minutesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    where?: MeetingMinutesWhereInput
    orderBy?: MeetingMinutesOrderByWithRelationInput | MeetingMinutesOrderByWithRelationInput[]
    cursor?: MeetingMinutesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingMinutesScalarFieldEnum | MeetingMinutesScalarFieldEnum[]
  }

  /**
   * User.goalsCreated
   */
  export type User$goalsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * User.feedbackGiven
   */
  export type User$feedbackGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.feedbackReceived
   */
  export type User$feedbackReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.resourcesUploaded
   */
  export type User$resourcesUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.portfolios
   */
  export type User$portfoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    cursor?: PortfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * User.availabilities
   */
  export type User$availabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * User.sessionReflections
   */
  export type User$sessionReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    where?: SessionReflectionWhereInput
    orderBy?: SessionReflectionOrderByWithRelationInput | SessionReflectionOrderByWithRelationInput[]
    cursor?: SessionReflectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionReflectionScalarFieldEnum | SessionReflectionScalarFieldEnum[]
  }

  /**
   * User.todoItems
   */
  export type User$todoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    where?: TodoItemWhereInput
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    cursor?: TodoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.ticketsCreated
   */
  export type User$ticketsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.ticketComments
   */
  export type User$ticketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * User.wikiPages
   */
  export type User$wikiPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    where?: WikiPageWhereInput
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    cursor?: WikiPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * User.whiteboards
   */
  export type User$whiteboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    where?: WhiteboardWhereInput
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    cursor?: WhiteboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * User.slides
   */
  export type User$slidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    where?: SlideWhereInput
    orderBy?: SlideOrderByWithRelationInput | SlideOrderByWithRelationInput[]
    cursor?: SlideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlideScalarFieldEnum | SlideScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model MentorProfile
   */

  export type AggregateMentorProfile = {
    _count: MentorProfileCountAggregateOutputType | null
    _avg: MentorProfileAvgAggregateOutputType | null
    _sum: MentorProfileSumAggregateOutputType | null
    _min: MentorProfileMinAggregateOutputType | null
    _max: MentorProfileMaxAggregateOutputType | null
  }

  export type MentorProfileAvgAggregateOutputType = {
    maxMentees: number | null
  }

  export type MentorProfileSumAggregateOutputType = {
    maxMentees: number | null
  }

  export type MentorProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    jobTitle: string | null
    expertise: string | null
    experience: string | null
    linkedIn: string | null
    maxMentees: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MentorProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    jobTitle: string | null
    expertise: string | null
    experience: string | null
    linkedIn: string | null
    maxMentees: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MentorProfileCountAggregateOutputType = {
    id: number
    userId: number
    company: number
    jobTitle: number
    expertise: number
    experience: number
    linkedIn: number
    maxMentees: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MentorProfileAvgAggregateInputType = {
    maxMentees?: true
  }

  export type MentorProfileSumAggregateInputType = {
    maxMentees?: true
  }

  export type MentorProfileMinAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    jobTitle?: true
    expertise?: true
    experience?: true
    linkedIn?: true
    maxMentees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MentorProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    jobTitle?: true
    expertise?: true
    experience?: true
    linkedIn?: true
    maxMentees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MentorProfileCountAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    jobTitle?: true
    expertise?: true
    experience?: true
    linkedIn?: true
    maxMentees?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MentorProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorProfile to aggregate.
     */
    where?: MentorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorProfiles to fetch.
     */
    orderBy?: MentorProfileOrderByWithRelationInput | MentorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorProfiles
    **/
    _count?: true | MentorProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorProfileMaxAggregateInputType
  }

  export type GetMentorProfileAggregateType<T extends MentorProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorProfile[P]>
      : GetScalarType<T[P], AggregateMentorProfile[P]>
  }




  export type MentorProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorProfileWhereInput
    orderBy?: MentorProfileOrderByWithAggregationInput | MentorProfileOrderByWithAggregationInput[]
    by: MentorProfileScalarFieldEnum[] | MentorProfileScalarFieldEnum
    having?: MentorProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorProfileCountAggregateInputType | true
    _avg?: MentorProfileAvgAggregateInputType
    _sum?: MentorProfileSumAggregateInputType
    _min?: MentorProfileMinAggregateInputType
    _max?: MentorProfileMaxAggregateInputType
  }

  export type MentorProfileGroupByOutputType = {
    id: string
    userId: string
    company: string | null
    jobTitle: string | null
    expertise: string | null
    experience: string | null
    linkedIn: string | null
    maxMentees: number
    createdAt: Date
    updatedAt: Date
    _count: MentorProfileCountAggregateOutputType | null
    _avg: MentorProfileAvgAggregateOutputType | null
    _sum: MentorProfileSumAggregateOutputType | null
    _min: MentorProfileMinAggregateOutputType | null
    _max: MentorProfileMaxAggregateOutputType | null
  }

  type GetMentorProfileGroupByPayload<T extends MentorProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorProfileGroupByOutputType[P]>
            : GetScalarType<T[P], MentorProfileGroupByOutputType[P]>
        }
      >
    >


  export type MentorProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    jobTitle?: boolean
    expertise?: boolean
    experience?: boolean
    linkedIn?: boolean
    maxMentees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorProfile"]>

  export type MentorProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    jobTitle?: boolean
    expertise?: boolean
    experience?: boolean
    linkedIn?: boolean
    maxMentees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorProfile"]>

  export type MentorProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    jobTitle?: boolean
    expertise?: boolean
    experience?: boolean
    linkedIn?: boolean
    maxMentees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorProfile"]>

  export type MentorProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    company?: boolean
    jobTitle?: boolean
    expertise?: boolean
    experience?: boolean
    linkedIn?: boolean
    maxMentees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MentorProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "company" | "jobTitle" | "expertise" | "experience" | "linkedIn" | "maxMentees" | "createdAt" | "updatedAt", ExtArgs["result"]["mentorProfile"]>
  export type MentorProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      company: string | null
      jobTitle: string | null
      expertise: string | null
      experience: string | null
      linkedIn: string | null
      maxMentees: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mentorProfile"]>
    composites: {}
  }

  type MentorProfileGetPayload<S extends boolean | null | undefined | MentorProfileDefaultArgs> = $Result.GetResult<Prisma.$MentorProfilePayload, S>

  type MentorProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorProfileCountAggregateInputType | true
    }

  export interface MentorProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorProfile'], meta: { name: 'MentorProfile' } }
    /**
     * Find zero or one MentorProfile that matches the filter.
     * @param {MentorProfileFindUniqueArgs} args - Arguments to find a MentorProfile
     * @example
     * // Get one MentorProfile
     * const mentorProfile = await prisma.mentorProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorProfileFindUniqueArgs>(args: SelectSubset<T, MentorProfileFindUniqueArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorProfileFindUniqueOrThrowArgs} args - Arguments to find a MentorProfile
     * @example
     * // Get one MentorProfile
     * const mentorProfile = await prisma.mentorProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorProfileFindFirstArgs} args - Arguments to find a MentorProfile
     * @example
     * // Get one MentorProfile
     * const mentorProfile = await prisma.mentorProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorProfileFindFirstArgs>(args?: SelectSubset<T, MentorProfileFindFirstArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorProfileFindFirstOrThrowArgs} args - Arguments to find a MentorProfile
     * @example
     * // Get one MentorProfile
     * const mentorProfile = await prisma.mentorProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorProfiles
     * const mentorProfiles = await prisma.mentorProfile.findMany()
     * 
     * // Get first 10 MentorProfiles
     * const mentorProfiles = await prisma.mentorProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorProfileWithIdOnly = await prisma.mentorProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorProfileFindManyArgs>(args?: SelectSubset<T, MentorProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorProfile.
     * @param {MentorProfileCreateArgs} args - Arguments to create a MentorProfile.
     * @example
     * // Create one MentorProfile
     * const MentorProfile = await prisma.mentorProfile.create({
     *   data: {
     *     // ... data to create a MentorProfile
     *   }
     * })
     * 
     */
    create<T extends MentorProfileCreateArgs>(args: SelectSubset<T, MentorProfileCreateArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorProfiles.
     * @param {MentorProfileCreateManyArgs} args - Arguments to create many MentorProfiles.
     * @example
     * // Create many MentorProfiles
     * const mentorProfile = await prisma.mentorProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorProfileCreateManyArgs>(args?: SelectSubset<T, MentorProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorProfiles and returns the data saved in the database.
     * @param {MentorProfileCreateManyAndReturnArgs} args - Arguments to create many MentorProfiles.
     * @example
     * // Create many MentorProfiles
     * const mentorProfile = await prisma.mentorProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorProfiles and only return the `id`
     * const mentorProfileWithIdOnly = await prisma.mentorProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorProfile.
     * @param {MentorProfileDeleteArgs} args - Arguments to delete one MentorProfile.
     * @example
     * // Delete one MentorProfile
     * const MentorProfile = await prisma.mentorProfile.delete({
     *   where: {
     *     // ... filter to delete one MentorProfile
     *   }
     * })
     * 
     */
    delete<T extends MentorProfileDeleteArgs>(args: SelectSubset<T, MentorProfileDeleteArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorProfile.
     * @param {MentorProfileUpdateArgs} args - Arguments to update one MentorProfile.
     * @example
     * // Update one MentorProfile
     * const mentorProfile = await prisma.mentorProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorProfileUpdateArgs>(args: SelectSubset<T, MentorProfileUpdateArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorProfiles.
     * @param {MentorProfileDeleteManyArgs} args - Arguments to filter MentorProfiles to delete.
     * @example
     * // Delete a few MentorProfiles
     * const { count } = await prisma.mentorProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorProfileDeleteManyArgs>(args?: SelectSubset<T, MentorProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorProfiles
     * const mentorProfile = await prisma.mentorProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorProfileUpdateManyArgs>(args: SelectSubset<T, MentorProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorProfiles and returns the data updated in the database.
     * @param {MentorProfileUpdateManyAndReturnArgs} args - Arguments to update many MentorProfiles.
     * @example
     * // Update many MentorProfiles
     * const mentorProfile = await prisma.mentorProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorProfiles and only return the `id`
     * const mentorProfileWithIdOnly = await prisma.mentorProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorProfile.
     * @param {MentorProfileUpsertArgs} args - Arguments to update or create a MentorProfile.
     * @example
     * // Update or create a MentorProfile
     * const mentorProfile = await prisma.mentorProfile.upsert({
     *   create: {
     *     // ... data to create a MentorProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorProfile we want to update
     *   }
     * })
     */
    upsert<T extends MentorProfileUpsertArgs>(args: SelectSubset<T, MentorProfileUpsertArgs<ExtArgs>>): Prisma__MentorProfileClient<$Result.GetResult<Prisma.$MentorProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorProfileCountArgs} args - Arguments to filter MentorProfiles to count.
     * @example
     * // Count the number of MentorProfiles
     * const count = await prisma.mentorProfile.count({
     *   where: {
     *     // ... the filter for the MentorProfiles we want to count
     *   }
     * })
    **/
    count<T extends MentorProfileCountArgs>(
      args?: Subset<T, MentorProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorProfileAggregateArgs>(args: Subset<T, MentorProfileAggregateArgs>): Prisma.PrismaPromise<GetMentorProfileAggregateType<T>>

    /**
     * Group by MentorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorProfileGroupByArgs['orderBy'] }
        : { orderBy?: MentorProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorProfile model
   */
  readonly fields: MentorProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorProfile model
   */
  interface MentorProfileFieldRefs {
    readonly id: FieldRef<"MentorProfile", 'String'>
    readonly userId: FieldRef<"MentorProfile", 'String'>
    readonly company: FieldRef<"MentorProfile", 'String'>
    readonly jobTitle: FieldRef<"MentorProfile", 'String'>
    readonly expertise: FieldRef<"MentorProfile", 'String'>
    readonly experience: FieldRef<"MentorProfile", 'String'>
    readonly linkedIn: FieldRef<"MentorProfile", 'String'>
    readonly maxMentees: FieldRef<"MentorProfile", 'Int'>
    readonly createdAt: FieldRef<"MentorProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"MentorProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MentorProfile findUnique
   */
  export type MentorProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * Filter, which MentorProfile to fetch.
     */
    where: MentorProfileWhereUniqueInput
  }

  /**
   * MentorProfile findUniqueOrThrow
   */
  export type MentorProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * Filter, which MentorProfile to fetch.
     */
    where: MentorProfileWhereUniqueInput
  }

  /**
   * MentorProfile findFirst
   */
  export type MentorProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * Filter, which MentorProfile to fetch.
     */
    where?: MentorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorProfiles to fetch.
     */
    orderBy?: MentorProfileOrderByWithRelationInput | MentorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorProfiles.
     */
    cursor?: MentorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorProfiles.
     */
    distinct?: MentorProfileScalarFieldEnum | MentorProfileScalarFieldEnum[]
  }

  /**
   * MentorProfile findFirstOrThrow
   */
  export type MentorProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * Filter, which MentorProfile to fetch.
     */
    where?: MentorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorProfiles to fetch.
     */
    orderBy?: MentorProfileOrderByWithRelationInput | MentorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorProfiles.
     */
    cursor?: MentorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorProfiles.
     */
    distinct?: MentorProfileScalarFieldEnum | MentorProfileScalarFieldEnum[]
  }

  /**
   * MentorProfile findMany
   */
  export type MentorProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * Filter, which MentorProfiles to fetch.
     */
    where?: MentorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorProfiles to fetch.
     */
    orderBy?: MentorProfileOrderByWithRelationInput | MentorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorProfiles.
     */
    cursor?: MentorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorProfiles.
     */
    skip?: number
    distinct?: MentorProfileScalarFieldEnum | MentorProfileScalarFieldEnum[]
  }

  /**
   * MentorProfile create
   */
  export type MentorProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorProfile.
     */
    data: XOR<MentorProfileCreateInput, MentorProfileUncheckedCreateInput>
  }

  /**
   * MentorProfile createMany
   */
  export type MentorProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorProfiles.
     */
    data: MentorProfileCreateManyInput | MentorProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorProfile createManyAndReturn
   */
  export type MentorProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * The data used to create many MentorProfiles.
     */
    data: MentorProfileCreateManyInput | MentorProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorProfile update
   */
  export type MentorProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorProfile.
     */
    data: XOR<MentorProfileUpdateInput, MentorProfileUncheckedUpdateInput>
    /**
     * Choose, which MentorProfile to update.
     */
    where: MentorProfileWhereUniqueInput
  }

  /**
   * MentorProfile updateMany
   */
  export type MentorProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorProfiles.
     */
    data: XOR<MentorProfileUpdateManyMutationInput, MentorProfileUncheckedUpdateManyInput>
    /**
     * Filter which MentorProfiles to update
     */
    where?: MentorProfileWhereInput
    /**
     * Limit how many MentorProfiles to update.
     */
    limit?: number
  }

  /**
   * MentorProfile updateManyAndReturn
   */
  export type MentorProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * The data used to update MentorProfiles.
     */
    data: XOR<MentorProfileUpdateManyMutationInput, MentorProfileUncheckedUpdateManyInput>
    /**
     * Filter which MentorProfiles to update
     */
    where?: MentorProfileWhereInput
    /**
     * Limit how many MentorProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorProfile upsert
   */
  export type MentorProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorProfile to update in case it exists.
     */
    where: MentorProfileWhereUniqueInput
    /**
     * In case the MentorProfile found by the `where` argument doesn't exist, create a new MentorProfile with this data.
     */
    create: XOR<MentorProfileCreateInput, MentorProfileUncheckedCreateInput>
    /**
     * In case the MentorProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorProfileUpdateInput, MentorProfileUncheckedUpdateInput>
  }

  /**
   * MentorProfile delete
   */
  export type MentorProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
    /**
     * Filter which MentorProfile to delete.
     */
    where: MentorProfileWhereUniqueInput
  }

  /**
   * MentorProfile deleteMany
   */
  export type MentorProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorProfiles to delete
     */
    where?: MentorProfileWhereInput
    /**
     * Limit how many MentorProfiles to delete.
     */
    limit?: number
  }

  /**
   * MentorProfile without action
   */
  export type MentorProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorProfile
     */
    select?: MentorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorProfile
     */
    omit?: MentorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorProfileInclude<ExtArgs> | null
  }


  /**
   * Model MenteeProfile
   */

  export type AggregateMenteeProfile = {
    _count: MenteeProfileCountAggregateOutputType | null
    _avg: MenteeProfileAvgAggregateOutputType | null
    _sum: MenteeProfileSumAggregateOutputType | null
    _min: MenteeProfileMinAggregateOutputType | null
    _max: MenteeProfileMaxAggregateOutputType | null
  }

  export type MenteeProfileAvgAggregateOutputType = {
    year: number | null
  }

  export type MenteeProfileSumAggregateOutputType = {
    year: number | null
  }

  export type MenteeProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    studentId: string | null
    major: string | null
    year: number | null
    careerGoals: string | null
    skills: string | null
    strengths: string | null
    weaknesses: string | null
    currentChallenges: string | null
    expectations: string | null
    background: string | null
    experience: string | null
    endGoals: string | null
    startupIdeas: string | null
    personalNotes: string | null
    isOnboardingComplete: boolean | null
    onboardingCompletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenteeProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    studentId: string | null
    major: string | null
    year: number | null
    careerGoals: string | null
    skills: string | null
    strengths: string | null
    weaknesses: string | null
    currentChallenges: string | null
    expectations: string | null
    background: string | null
    experience: string | null
    endGoals: string | null
    startupIdeas: string | null
    personalNotes: string | null
    isOnboardingComplete: boolean | null
    onboardingCompletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenteeProfileCountAggregateOutputType = {
    id: number
    userId: number
    studentId: number
    major: number
    year: number
    careerGoals: number
    skills: number
    strengths: number
    weaknesses: number
    currentChallenges: number
    expectations: number
    background: number
    experience: number
    endGoals: number
    startupIdeas: number
    personalNotes: number
    isOnboardingComplete: number
    onboardingCompletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenteeProfileAvgAggregateInputType = {
    year?: true
  }

  export type MenteeProfileSumAggregateInputType = {
    year?: true
  }

  export type MenteeProfileMinAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    major?: true
    year?: true
    careerGoals?: true
    skills?: true
    strengths?: true
    weaknesses?: true
    currentChallenges?: true
    expectations?: true
    background?: true
    experience?: true
    endGoals?: true
    startupIdeas?: true
    personalNotes?: true
    isOnboardingComplete?: true
    onboardingCompletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenteeProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    major?: true
    year?: true
    careerGoals?: true
    skills?: true
    strengths?: true
    weaknesses?: true
    currentChallenges?: true
    expectations?: true
    background?: true
    experience?: true
    endGoals?: true
    startupIdeas?: true
    personalNotes?: true
    isOnboardingComplete?: true
    onboardingCompletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenteeProfileCountAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    major?: true
    year?: true
    careerGoals?: true
    skills?: true
    strengths?: true
    weaknesses?: true
    currentChallenges?: true
    expectations?: true
    background?: true
    experience?: true
    endGoals?: true
    startupIdeas?: true
    personalNotes?: true
    isOnboardingComplete?: true
    onboardingCompletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenteeProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeProfile to aggregate.
     */
    where?: MenteeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeProfiles to fetch.
     */
    orderBy?: MenteeProfileOrderByWithRelationInput | MenteeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteeProfiles
    **/
    _count?: true | MenteeProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenteeProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenteeProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteeProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteeProfileMaxAggregateInputType
  }

  export type GetMenteeProfileAggregateType<T extends MenteeProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteeProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteeProfile[P]>
      : GetScalarType<T[P], AggregateMenteeProfile[P]>
  }




  export type MenteeProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeProfileWhereInput
    orderBy?: MenteeProfileOrderByWithAggregationInput | MenteeProfileOrderByWithAggregationInput[]
    by: MenteeProfileScalarFieldEnum[] | MenteeProfileScalarFieldEnum
    having?: MenteeProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteeProfileCountAggregateInputType | true
    _avg?: MenteeProfileAvgAggregateInputType
    _sum?: MenteeProfileSumAggregateInputType
    _min?: MenteeProfileMinAggregateInputType
    _max?: MenteeProfileMaxAggregateInputType
  }

  export type MenteeProfileGroupByOutputType = {
    id: string
    userId: string
    studentId: string | null
    major: string | null
    year: number | null
    careerGoals: string | null
    skills: string | null
    strengths: string | null
    weaknesses: string | null
    currentChallenges: string | null
    expectations: string | null
    background: string | null
    experience: string | null
    endGoals: string | null
    startupIdeas: string | null
    personalNotes: string | null
    isOnboardingComplete: boolean
    onboardingCompletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MenteeProfileCountAggregateOutputType | null
    _avg: MenteeProfileAvgAggregateOutputType | null
    _sum: MenteeProfileSumAggregateOutputType | null
    _min: MenteeProfileMinAggregateOutputType | null
    _max: MenteeProfileMaxAggregateOutputType | null
  }

  type GetMenteeProfileGroupByPayload<T extends MenteeProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteeProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteeProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteeProfileGroupByOutputType[P]>
            : GetScalarType<T[P], MenteeProfileGroupByOutputType[P]>
        }
      >
    >


  export type MenteeProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    major?: boolean
    year?: boolean
    careerGoals?: boolean
    skills?: boolean
    strengths?: boolean
    weaknesses?: boolean
    currentChallenges?: boolean
    expectations?: boolean
    background?: boolean
    experience?: boolean
    endGoals?: boolean
    startupIdeas?: boolean
    personalNotes?: boolean
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeProfile"]>

  export type MenteeProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    major?: boolean
    year?: boolean
    careerGoals?: boolean
    skills?: boolean
    strengths?: boolean
    weaknesses?: boolean
    currentChallenges?: boolean
    expectations?: boolean
    background?: boolean
    experience?: boolean
    endGoals?: boolean
    startupIdeas?: boolean
    personalNotes?: boolean
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeProfile"]>

  export type MenteeProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    major?: boolean
    year?: boolean
    careerGoals?: boolean
    skills?: boolean
    strengths?: boolean
    weaknesses?: boolean
    currentChallenges?: boolean
    expectations?: boolean
    background?: boolean
    experience?: boolean
    endGoals?: boolean
    startupIdeas?: boolean
    personalNotes?: boolean
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeProfile"]>

  export type MenteeProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    studentId?: boolean
    major?: boolean
    year?: boolean
    careerGoals?: boolean
    skills?: boolean
    strengths?: boolean
    weaknesses?: boolean
    currentChallenges?: boolean
    expectations?: boolean
    background?: boolean
    experience?: boolean
    endGoals?: boolean
    startupIdeas?: boolean
    personalNotes?: boolean
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenteeProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studentId" | "major" | "year" | "careerGoals" | "skills" | "strengths" | "weaknesses" | "currentChallenges" | "expectations" | "background" | "experience" | "endGoals" | "startupIdeas" | "personalNotes" | "isOnboardingComplete" | "onboardingCompletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["menteeProfile"]>
  export type MenteeProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MenteeProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteeProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      studentId: string | null
      major: string | null
      year: number | null
      careerGoals: string | null
      skills: string | null
      strengths: string | null
      weaknesses: string | null
      currentChallenges: string | null
      expectations: string | null
      background: string | null
      experience: string | null
      endGoals: string | null
      startupIdeas: string | null
      personalNotes: string | null
      isOnboardingComplete: boolean
      onboardingCompletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menteeProfile"]>
    composites: {}
  }

  type MenteeProfileGetPayload<S extends boolean | null | undefined | MenteeProfileDefaultArgs> = $Result.GetResult<Prisma.$MenteeProfilePayload, S>

  type MenteeProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteeProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteeProfileCountAggregateInputType | true
    }

  export interface MenteeProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteeProfile'], meta: { name: 'MenteeProfile' } }
    /**
     * Find zero or one MenteeProfile that matches the filter.
     * @param {MenteeProfileFindUniqueArgs} args - Arguments to find a MenteeProfile
     * @example
     * // Get one MenteeProfile
     * const menteeProfile = await prisma.menteeProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteeProfileFindUniqueArgs>(args: SelectSubset<T, MenteeProfileFindUniqueArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteeProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteeProfileFindUniqueOrThrowArgs} args - Arguments to find a MenteeProfile
     * @example
     * // Get one MenteeProfile
     * const menteeProfile = await prisma.menteeProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteeProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteeProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeProfileFindFirstArgs} args - Arguments to find a MenteeProfile
     * @example
     * // Get one MenteeProfile
     * const menteeProfile = await prisma.menteeProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteeProfileFindFirstArgs>(args?: SelectSubset<T, MenteeProfileFindFirstArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeProfileFindFirstOrThrowArgs} args - Arguments to find a MenteeProfile
     * @example
     * // Get one MenteeProfile
     * const menteeProfile = await prisma.menteeProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteeProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteeProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteeProfiles
     * const menteeProfiles = await prisma.menteeProfile.findMany()
     * 
     * // Get first 10 MenteeProfiles
     * const menteeProfiles = await prisma.menteeProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menteeProfileWithIdOnly = await prisma.menteeProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenteeProfileFindManyArgs>(args?: SelectSubset<T, MenteeProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteeProfile.
     * @param {MenteeProfileCreateArgs} args - Arguments to create a MenteeProfile.
     * @example
     * // Create one MenteeProfile
     * const MenteeProfile = await prisma.menteeProfile.create({
     *   data: {
     *     // ... data to create a MenteeProfile
     *   }
     * })
     * 
     */
    create<T extends MenteeProfileCreateArgs>(args: SelectSubset<T, MenteeProfileCreateArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteeProfiles.
     * @param {MenteeProfileCreateManyArgs} args - Arguments to create many MenteeProfiles.
     * @example
     * // Create many MenteeProfiles
     * const menteeProfile = await prisma.menteeProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteeProfileCreateManyArgs>(args?: SelectSubset<T, MenteeProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteeProfiles and returns the data saved in the database.
     * @param {MenteeProfileCreateManyAndReturnArgs} args - Arguments to create many MenteeProfiles.
     * @example
     * // Create many MenteeProfiles
     * const menteeProfile = await prisma.menteeProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteeProfiles and only return the `id`
     * const menteeProfileWithIdOnly = await prisma.menteeProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteeProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteeProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteeProfile.
     * @param {MenteeProfileDeleteArgs} args - Arguments to delete one MenteeProfile.
     * @example
     * // Delete one MenteeProfile
     * const MenteeProfile = await prisma.menteeProfile.delete({
     *   where: {
     *     // ... filter to delete one MenteeProfile
     *   }
     * })
     * 
     */
    delete<T extends MenteeProfileDeleteArgs>(args: SelectSubset<T, MenteeProfileDeleteArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteeProfile.
     * @param {MenteeProfileUpdateArgs} args - Arguments to update one MenteeProfile.
     * @example
     * // Update one MenteeProfile
     * const menteeProfile = await prisma.menteeProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteeProfileUpdateArgs>(args: SelectSubset<T, MenteeProfileUpdateArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteeProfiles.
     * @param {MenteeProfileDeleteManyArgs} args - Arguments to filter MenteeProfiles to delete.
     * @example
     * // Delete a few MenteeProfiles
     * const { count } = await prisma.menteeProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteeProfileDeleteManyArgs>(args?: SelectSubset<T, MenteeProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteeProfiles
     * const menteeProfile = await prisma.menteeProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteeProfileUpdateManyArgs>(args: SelectSubset<T, MenteeProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeProfiles and returns the data updated in the database.
     * @param {MenteeProfileUpdateManyAndReturnArgs} args - Arguments to update many MenteeProfiles.
     * @example
     * // Update many MenteeProfiles
     * const menteeProfile = await prisma.menteeProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteeProfiles and only return the `id`
     * const menteeProfileWithIdOnly = await prisma.menteeProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteeProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteeProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteeProfile.
     * @param {MenteeProfileUpsertArgs} args - Arguments to update or create a MenteeProfile.
     * @example
     * // Update or create a MenteeProfile
     * const menteeProfile = await prisma.menteeProfile.upsert({
     *   create: {
     *     // ... data to create a MenteeProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteeProfile we want to update
     *   }
     * })
     */
    upsert<T extends MenteeProfileUpsertArgs>(args: SelectSubset<T, MenteeProfileUpsertArgs<ExtArgs>>): Prisma__MenteeProfileClient<$Result.GetResult<Prisma.$MenteeProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeProfileCountArgs} args - Arguments to filter MenteeProfiles to count.
     * @example
     * // Count the number of MenteeProfiles
     * const count = await prisma.menteeProfile.count({
     *   where: {
     *     // ... the filter for the MenteeProfiles we want to count
     *   }
     * })
    **/
    count<T extends MenteeProfileCountArgs>(
      args?: Subset<T, MenteeProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteeProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteeProfileAggregateArgs>(args: Subset<T, MenteeProfileAggregateArgs>): Prisma.PrismaPromise<GetMenteeProfileAggregateType<T>>

    /**
     * Group by MenteeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteeProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteeProfileGroupByArgs['orderBy'] }
        : { orderBy?: MenteeProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteeProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteeProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteeProfile model
   */
  readonly fields: MenteeProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteeProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteeProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteeProfile model
   */
  interface MenteeProfileFieldRefs {
    readonly id: FieldRef<"MenteeProfile", 'String'>
    readonly userId: FieldRef<"MenteeProfile", 'String'>
    readonly studentId: FieldRef<"MenteeProfile", 'String'>
    readonly major: FieldRef<"MenteeProfile", 'String'>
    readonly year: FieldRef<"MenteeProfile", 'Int'>
    readonly careerGoals: FieldRef<"MenteeProfile", 'String'>
    readonly skills: FieldRef<"MenteeProfile", 'String'>
    readonly strengths: FieldRef<"MenteeProfile", 'String'>
    readonly weaknesses: FieldRef<"MenteeProfile", 'String'>
    readonly currentChallenges: FieldRef<"MenteeProfile", 'String'>
    readonly expectations: FieldRef<"MenteeProfile", 'String'>
    readonly background: FieldRef<"MenteeProfile", 'String'>
    readonly experience: FieldRef<"MenteeProfile", 'String'>
    readonly endGoals: FieldRef<"MenteeProfile", 'String'>
    readonly startupIdeas: FieldRef<"MenteeProfile", 'String'>
    readonly personalNotes: FieldRef<"MenteeProfile", 'String'>
    readonly isOnboardingComplete: FieldRef<"MenteeProfile", 'Boolean'>
    readonly onboardingCompletedAt: FieldRef<"MenteeProfile", 'DateTime'>
    readonly createdAt: FieldRef<"MenteeProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"MenteeProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenteeProfile findUnique
   */
  export type MenteeProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * Filter, which MenteeProfile to fetch.
     */
    where: MenteeProfileWhereUniqueInput
  }

  /**
   * MenteeProfile findUniqueOrThrow
   */
  export type MenteeProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * Filter, which MenteeProfile to fetch.
     */
    where: MenteeProfileWhereUniqueInput
  }

  /**
   * MenteeProfile findFirst
   */
  export type MenteeProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * Filter, which MenteeProfile to fetch.
     */
    where?: MenteeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeProfiles to fetch.
     */
    orderBy?: MenteeProfileOrderByWithRelationInput | MenteeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeProfiles.
     */
    cursor?: MenteeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeProfiles.
     */
    distinct?: MenteeProfileScalarFieldEnum | MenteeProfileScalarFieldEnum[]
  }

  /**
   * MenteeProfile findFirstOrThrow
   */
  export type MenteeProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * Filter, which MenteeProfile to fetch.
     */
    where?: MenteeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeProfiles to fetch.
     */
    orderBy?: MenteeProfileOrderByWithRelationInput | MenteeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeProfiles.
     */
    cursor?: MenteeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeProfiles.
     */
    distinct?: MenteeProfileScalarFieldEnum | MenteeProfileScalarFieldEnum[]
  }

  /**
   * MenteeProfile findMany
   */
  export type MenteeProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * Filter, which MenteeProfiles to fetch.
     */
    where?: MenteeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeProfiles to fetch.
     */
    orderBy?: MenteeProfileOrderByWithRelationInput | MenteeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteeProfiles.
     */
    cursor?: MenteeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeProfiles.
     */
    skip?: number
    distinct?: MenteeProfileScalarFieldEnum | MenteeProfileScalarFieldEnum[]
  }

  /**
   * MenteeProfile create
   */
  export type MenteeProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteeProfile.
     */
    data: XOR<MenteeProfileCreateInput, MenteeProfileUncheckedCreateInput>
  }

  /**
   * MenteeProfile createMany
   */
  export type MenteeProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteeProfiles.
     */
    data: MenteeProfileCreateManyInput | MenteeProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteeProfile createManyAndReturn
   */
  export type MenteeProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * The data used to create many MenteeProfiles.
     */
    data: MenteeProfileCreateManyInput | MenteeProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeProfile update
   */
  export type MenteeProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteeProfile.
     */
    data: XOR<MenteeProfileUpdateInput, MenteeProfileUncheckedUpdateInput>
    /**
     * Choose, which MenteeProfile to update.
     */
    where: MenteeProfileWhereUniqueInput
  }

  /**
   * MenteeProfile updateMany
   */
  export type MenteeProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteeProfiles.
     */
    data: XOR<MenteeProfileUpdateManyMutationInput, MenteeProfileUncheckedUpdateManyInput>
    /**
     * Filter which MenteeProfiles to update
     */
    where?: MenteeProfileWhereInput
    /**
     * Limit how many MenteeProfiles to update.
     */
    limit?: number
  }

  /**
   * MenteeProfile updateManyAndReturn
   */
  export type MenteeProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * The data used to update MenteeProfiles.
     */
    data: XOR<MenteeProfileUpdateManyMutationInput, MenteeProfileUncheckedUpdateManyInput>
    /**
     * Filter which MenteeProfiles to update
     */
    where?: MenteeProfileWhereInput
    /**
     * Limit how many MenteeProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeProfile upsert
   */
  export type MenteeProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteeProfile to update in case it exists.
     */
    where: MenteeProfileWhereUniqueInput
    /**
     * In case the MenteeProfile found by the `where` argument doesn't exist, create a new MenteeProfile with this data.
     */
    create: XOR<MenteeProfileCreateInput, MenteeProfileUncheckedCreateInput>
    /**
     * In case the MenteeProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteeProfileUpdateInput, MenteeProfileUncheckedUpdateInput>
  }

  /**
   * MenteeProfile delete
   */
  export type MenteeProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
    /**
     * Filter which MenteeProfile to delete.
     */
    where: MenteeProfileWhereUniqueInput
  }

  /**
   * MenteeProfile deleteMany
   */
  export type MenteeProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeProfiles to delete
     */
    where?: MenteeProfileWhereInput
    /**
     * Limit how many MenteeProfiles to delete.
     */
    limit?: number
  }

  /**
   * MenteeProfile without action
   */
  export type MenteeProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeProfile
     */
    select?: MenteeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeProfile
     */
    omit?: MenteeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeProfileInclude<ExtArgs> | null
  }


  /**
   * Model ProgramCycle
   */

  export type AggregateProgramCycle = {
    _count: ProgramCycleCountAggregateOutputType | null
    _min: ProgramCycleMinAggregateOutputType | null
    _max: ProgramCycleMaxAggregateOutputType | null
  }

  export type ProgramCycleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCycleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCycleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramCycleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCycleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCycleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramCycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramCycle to aggregate.
     */
    where?: ProgramCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCycles to fetch.
     */
    orderBy?: ProgramCycleOrderByWithRelationInput | ProgramCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramCycles
    **/
    _count?: true | ProgramCycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramCycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramCycleMaxAggregateInputType
  }

  export type GetProgramCycleAggregateType<T extends ProgramCycleAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramCycle[P]>
      : GetScalarType<T[P], AggregateProgramCycle[P]>
  }




  export type ProgramCycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramCycleWhereInput
    orderBy?: ProgramCycleOrderByWithAggregationInput | ProgramCycleOrderByWithAggregationInput[]
    by: ProgramCycleScalarFieldEnum[] | ProgramCycleScalarFieldEnum
    having?: ProgramCycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCycleCountAggregateInputType | true
    _min?: ProgramCycleMinAggregateInputType
    _max?: ProgramCycleMaxAggregateInputType
  }

  export type ProgramCycleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ProgramCycleCountAggregateOutputType | null
    _min: ProgramCycleMinAggregateOutputType | null
    _max: ProgramCycleMaxAggregateOutputType | null
  }

  type GetProgramCycleGroupByPayload<T extends ProgramCycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramCycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramCycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramCycleGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramCycleGroupByOutputType[P]>
        }
      >
    >


  export type ProgramCycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorships?: boolean | ProgramCycle$mentorshipsArgs<ExtArgs>
    _count?: boolean | ProgramCycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programCycle"]>

  export type ProgramCycleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programCycle"]>

  export type ProgramCycleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programCycle"]>

  export type ProgramCycleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramCycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "startDate" | "endDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["programCycle"]>
  export type ProgramCycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorships?: boolean | ProgramCycle$mentorshipsArgs<ExtArgs>
    _count?: boolean | ProgramCycleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramCycleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProgramCycleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProgramCyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramCycle"
    objects: {
      mentorships: Prisma.$MentorshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["programCycle"]>
    composites: {}
  }

  type ProgramCycleGetPayload<S extends boolean | null | undefined | ProgramCycleDefaultArgs> = $Result.GetResult<Prisma.$ProgramCyclePayload, S>

  type ProgramCycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramCycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCycleCountAggregateInputType | true
    }

  export interface ProgramCycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramCycle'], meta: { name: 'ProgramCycle' } }
    /**
     * Find zero or one ProgramCycle that matches the filter.
     * @param {ProgramCycleFindUniqueArgs} args - Arguments to find a ProgramCycle
     * @example
     * // Get one ProgramCycle
     * const programCycle = await prisma.programCycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramCycleFindUniqueArgs>(args: SelectSubset<T, ProgramCycleFindUniqueArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramCycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramCycleFindUniqueOrThrowArgs} args - Arguments to find a ProgramCycle
     * @example
     * // Get one ProgramCycle
     * const programCycle = await prisma.programCycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramCycleFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramCycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramCycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCycleFindFirstArgs} args - Arguments to find a ProgramCycle
     * @example
     * // Get one ProgramCycle
     * const programCycle = await prisma.programCycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramCycleFindFirstArgs>(args?: SelectSubset<T, ProgramCycleFindFirstArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramCycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCycleFindFirstOrThrowArgs} args - Arguments to find a ProgramCycle
     * @example
     * // Get one ProgramCycle
     * const programCycle = await prisma.programCycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramCycleFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramCycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramCycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramCycles
     * const programCycles = await prisma.programCycle.findMany()
     * 
     * // Get first 10 ProgramCycles
     * const programCycles = await prisma.programCycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programCycleWithIdOnly = await prisma.programCycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramCycleFindManyArgs>(args?: SelectSubset<T, ProgramCycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramCycle.
     * @param {ProgramCycleCreateArgs} args - Arguments to create a ProgramCycle.
     * @example
     * // Create one ProgramCycle
     * const ProgramCycle = await prisma.programCycle.create({
     *   data: {
     *     // ... data to create a ProgramCycle
     *   }
     * })
     * 
     */
    create<T extends ProgramCycleCreateArgs>(args: SelectSubset<T, ProgramCycleCreateArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramCycles.
     * @param {ProgramCycleCreateManyArgs} args - Arguments to create many ProgramCycles.
     * @example
     * // Create many ProgramCycles
     * const programCycle = await prisma.programCycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCycleCreateManyArgs>(args?: SelectSubset<T, ProgramCycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramCycles and returns the data saved in the database.
     * @param {ProgramCycleCreateManyAndReturnArgs} args - Arguments to create many ProgramCycles.
     * @example
     * // Create many ProgramCycles
     * const programCycle = await prisma.programCycle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramCycles and only return the `id`
     * const programCycleWithIdOnly = await prisma.programCycle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCycleCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCycleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramCycle.
     * @param {ProgramCycleDeleteArgs} args - Arguments to delete one ProgramCycle.
     * @example
     * // Delete one ProgramCycle
     * const ProgramCycle = await prisma.programCycle.delete({
     *   where: {
     *     // ... filter to delete one ProgramCycle
     *   }
     * })
     * 
     */
    delete<T extends ProgramCycleDeleteArgs>(args: SelectSubset<T, ProgramCycleDeleteArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramCycle.
     * @param {ProgramCycleUpdateArgs} args - Arguments to update one ProgramCycle.
     * @example
     * // Update one ProgramCycle
     * const programCycle = await prisma.programCycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramCycleUpdateArgs>(args: SelectSubset<T, ProgramCycleUpdateArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramCycles.
     * @param {ProgramCycleDeleteManyArgs} args - Arguments to filter ProgramCycles to delete.
     * @example
     * // Delete a few ProgramCycles
     * const { count } = await prisma.programCycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramCycleDeleteManyArgs>(args?: SelectSubset<T, ProgramCycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramCycles
     * const programCycle = await prisma.programCycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramCycleUpdateManyArgs>(args: SelectSubset<T, ProgramCycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramCycles and returns the data updated in the database.
     * @param {ProgramCycleUpdateManyAndReturnArgs} args - Arguments to update many ProgramCycles.
     * @example
     * // Update many ProgramCycles
     * const programCycle = await prisma.programCycle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramCycles and only return the `id`
     * const programCycleWithIdOnly = await prisma.programCycle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramCycleUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramCycleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramCycle.
     * @param {ProgramCycleUpsertArgs} args - Arguments to update or create a ProgramCycle.
     * @example
     * // Update or create a ProgramCycle
     * const programCycle = await prisma.programCycle.upsert({
     *   create: {
     *     // ... data to create a ProgramCycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramCycle we want to update
     *   }
     * })
     */
    upsert<T extends ProgramCycleUpsertArgs>(args: SelectSubset<T, ProgramCycleUpsertArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCycleCountArgs} args - Arguments to filter ProgramCycles to count.
     * @example
     * // Count the number of ProgramCycles
     * const count = await prisma.programCycle.count({
     *   where: {
     *     // ... the filter for the ProgramCycles we want to count
     *   }
     * })
    **/
    count<T extends ProgramCycleCountArgs>(
      args?: Subset<T, ProgramCycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramCycleAggregateArgs>(args: Subset<T, ProgramCycleAggregateArgs>): Prisma.PrismaPromise<GetProgramCycleAggregateType<T>>

    /**
     * Group by ProgramCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramCycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramCycleGroupByArgs['orderBy'] }
        : { orderBy?: ProgramCycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramCycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramCycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramCycle model
   */
  readonly fields: ProgramCycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramCycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramCycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentorships<T extends ProgramCycle$mentorshipsArgs<ExtArgs> = {}>(args?: Subset<T, ProgramCycle$mentorshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramCycle model
   */
  interface ProgramCycleFieldRefs {
    readonly id: FieldRef<"ProgramCycle", 'String'>
    readonly name: FieldRef<"ProgramCycle", 'String'>
    readonly description: FieldRef<"ProgramCycle", 'String'>
    readonly startDate: FieldRef<"ProgramCycle", 'DateTime'>
    readonly endDate: FieldRef<"ProgramCycle", 'DateTime'>
    readonly status: FieldRef<"ProgramCycle", 'String'>
    readonly createdAt: FieldRef<"ProgramCycle", 'DateTime'>
    readonly updatedAt: FieldRef<"ProgramCycle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgramCycle findUnique
   */
  export type ProgramCycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCycle to fetch.
     */
    where: ProgramCycleWhereUniqueInput
  }

  /**
   * ProgramCycle findUniqueOrThrow
   */
  export type ProgramCycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCycle to fetch.
     */
    where: ProgramCycleWhereUniqueInput
  }

  /**
   * ProgramCycle findFirst
   */
  export type ProgramCycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCycle to fetch.
     */
    where?: ProgramCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCycles to fetch.
     */
    orderBy?: ProgramCycleOrderByWithRelationInput | ProgramCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramCycles.
     */
    cursor?: ProgramCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramCycles.
     */
    distinct?: ProgramCycleScalarFieldEnum | ProgramCycleScalarFieldEnum[]
  }

  /**
   * ProgramCycle findFirstOrThrow
   */
  export type ProgramCycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCycle to fetch.
     */
    where?: ProgramCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCycles to fetch.
     */
    orderBy?: ProgramCycleOrderByWithRelationInput | ProgramCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramCycles.
     */
    cursor?: ProgramCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramCycles.
     */
    distinct?: ProgramCycleScalarFieldEnum | ProgramCycleScalarFieldEnum[]
  }

  /**
   * ProgramCycle findMany
   */
  export type ProgramCycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramCycles to fetch.
     */
    where?: ProgramCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramCycles to fetch.
     */
    orderBy?: ProgramCycleOrderByWithRelationInput | ProgramCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramCycles.
     */
    cursor?: ProgramCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramCycles.
     */
    skip?: number
    distinct?: ProgramCycleScalarFieldEnum | ProgramCycleScalarFieldEnum[]
  }

  /**
   * ProgramCycle create
   */
  export type ProgramCycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramCycle.
     */
    data: XOR<ProgramCycleCreateInput, ProgramCycleUncheckedCreateInput>
  }

  /**
   * ProgramCycle createMany
   */
  export type ProgramCycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramCycles.
     */
    data: ProgramCycleCreateManyInput | ProgramCycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramCycle createManyAndReturn
   */
  export type ProgramCycleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * The data used to create many ProgramCycles.
     */
    data: ProgramCycleCreateManyInput | ProgramCycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramCycle update
   */
  export type ProgramCycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramCycle.
     */
    data: XOR<ProgramCycleUpdateInput, ProgramCycleUncheckedUpdateInput>
    /**
     * Choose, which ProgramCycle to update.
     */
    where: ProgramCycleWhereUniqueInput
  }

  /**
   * ProgramCycle updateMany
   */
  export type ProgramCycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramCycles.
     */
    data: XOR<ProgramCycleUpdateManyMutationInput, ProgramCycleUncheckedUpdateManyInput>
    /**
     * Filter which ProgramCycles to update
     */
    where?: ProgramCycleWhereInput
    /**
     * Limit how many ProgramCycles to update.
     */
    limit?: number
  }

  /**
   * ProgramCycle updateManyAndReturn
   */
  export type ProgramCycleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * The data used to update ProgramCycles.
     */
    data: XOR<ProgramCycleUpdateManyMutationInput, ProgramCycleUncheckedUpdateManyInput>
    /**
     * Filter which ProgramCycles to update
     */
    where?: ProgramCycleWhereInput
    /**
     * Limit how many ProgramCycles to update.
     */
    limit?: number
  }

  /**
   * ProgramCycle upsert
   */
  export type ProgramCycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramCycle to update in case it exists.
     */
    where: ProgramCycleWhereUniqueInput
    /**
     * In case the ProgramCycle found by the `where` argument doesn't exist, create a new ProgramCycle with this data.
     */
    create: XOR<ProgramCycleCreateInput, ProgramCycleUncheckedCreateInput>
    /**
     * In case the ProgramCycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramCycleUpdateInput, ProgramCycleUncheckedUpdateInput>
  }

  /**
   * ProgramCycle delete
   */
  export type ProgramCycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
    /**
     * Filter which ProgramCycle to delete.
     */
    where: ProgramCycleWhereUniqueInput
  }

  /**
   * ProgramCycle deleteMany
   */
  export type ProgramCycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramCycles to delete
     */
    where?: ProgramCycleWhereInput
    /**
     * Limit how many ProgramCycles to delete.
     */
    limit?: number
  }

  /**
   * ProgramCycle.mentorships
   */
  export type ProgramCycle$mentorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    where?: MentorshipWhereInput
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    cursor?: MentorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * ProgramCycle without action
   */
  export type ProgramCycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCycle
     */
    select?: ProgramCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramCycle
     */
    omit?: ProgramCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramCycleInclude<ExtArgs> | null
  }


  /**
   * Model Mentorship
   */

  export type AggregateMentorship = {
    _count: MentorshipCountAggregateOutputType | null
    _avg: MentorshipAvgAggregateOutputType | null
    _sum: MentorshipSumAggregateOutputType | null
    _min: MentorshipMinAggregateOutputType | null
    _max: MentorshipMaxAggregateOutputType | null
  }

  export type MentorshipAvgAggregateOutputType = {
    maxMentees: number | null
  }

  export type MentorshipSumAggregateOutputType = {
    maxMentees: number | null
  }

  export type MentorshipMinAggregateOutputType = {
    id: string | null
    mentorId: string | null
    type: string | null
    status: string | null
    programCycleId: string | null
    startDate: Date | null
    endDate: Date | null
    maxMentees: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MentorshipMaxAggregateOutputType = {
    id: string | null
    mentorId: string | null
    type: string | null
    status: string | null
    programCycleId: string | null
    startDate: Date | null
    endDate: Date | null
    maxMentees: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MentorshipCountAggregateOutputType = {
    id: number
    mentorId: number
    type: number
    status: number
    programCycleId: number
    startDate: number
    endDate: number
    maxMentees: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MentorshipAvgAggregateInputType = {
    maxMentees?: true
  }

  export type MentorshipSumAggregateInputType = {
    maxMentees?: true
  }

  export type MentorshipMinAggregateInputType = {
    id?: true
    mentorId?: true
    type?: true
    status?: true
    programCycleId?: true
    startDate?: true
    endDate?: true
    maxMentees?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MentorshipMaxAggregateInputType = {
    id?: true
    mentorId?: true
    type?: true
    status?: true
    programCycleId?: true
    startDate?: true
    endDate?: true
    maxMentees?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MentorshipCountAggregateInputType = {
    id?: true
    mentorId?: true
    type?: true
    status?: true
    programCycleId?: true
    startDate?: true
    endDate?: true
    maxMentees?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MentorshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentorship to aggregate.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentorships
    **/
    _count?: true | MentorshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorshipMaxAggregateInputType
  }

  export type GetMentorshipAggregateType<T extends MentorshipAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorship[P]>
      : GetScalarType<T[P], AggregateMentorship[P]>
  }




  export type MentorshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipWhereInput
    orderBy?: MentorshipOrderByWithAggregationInput | MentorshipOrderByWithAggregationInput[]
    by: MentorshipScalarFieldEnum[] | MentorshipScalarFieldEnum
    having?: MentorshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorshipCountAggregateInputType | true
    _avg?: MentorshipAvgAggregateInputType
    _sum?: MentorshipSumAggregateInputType
    _min?: MentorshipMinAggregateInputType
    _max?: MentorshipMaxAggregateInputType
  }

  export type MentorshipGroupByOutputType = {
    id: string
    mentorId: string
    type: string
    status: string
    programCycleId: string
    startDate: Date
    endDate: Date
    maxMentees: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MentorshipCountAggregateOutputType | null
    _avg: MentorshipAvgAggregateOutputType | null
    _sum: MentorshipSumAggregateOutputType | null
    _min: MentorshipMinAggregateOutputType | null
    _max: MentorshipMaxAggregateOutputType | null
  }

  type GetMentorshipGroupByPayload<T extends MentorshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorshipGroupByOutputType[P]>
            : GetScalarType<T[P], MentorshipGroupByOutputType[P]>
        }
      >
    >


  export type MentorshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    type?: boolean
    status?: boolean
    programCycleId?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    programCycle?: boolean | ProgramCycleDefaultArgs<ExtArgs>
    mentees?: boolean | Mentorship$menteesArgs<ExtArgs>
    meetings?: boolean | Mentorship$meetingsArgs<ExtArgs>
    goals?: boolean | Mentorship$goalsArgs<ExtArgs>
    feedbacks?: boolean | Mentorship$feedbacksArgs<ExtArgs>
    _count?: boolean | MentorshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorship"]>

  export type MentorshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    type?: boolean
    status?: boolean
    programCycleId?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    programCycle?: boolean | ProgramCycleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorship"]>

  export type MentorshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    type?: boolean
    status?: boolean
    programCycleId?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    programCycle?: boolean | ProgramCycleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorship"]>

  export type MentorshipSelectScalar = {
    id?: boolean
    mentorId?: boolean
    type?: boolean
    status?: boolean
    programCycleId?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MentorshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mentorId" | "type" | "status" | "programCycleId" | "startDate" | "endDate" | "maxMentees" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["mentorship"]>
  export type MentorshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    programCycle?: boolean | ProgramCycleDefaultArgs<ExtArgs>
    mentees?: boolean | Mentorship$menteesArgs<ExtArgs>
    meetings?: boolean | Mentorship$meetingsArgs<ExtArgs>
    goals?: boolean | Mentorship$goalsArgs<ExtArgs>
    feedbacks?: boolean | Mentorship$feedbacksArgs<ExtArgs>
    _count?: boolean | MentorshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MentorshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    programCycle?: boolean | ProgramCycleDefaultArgs<ExtArgs>
  }
  export type MentorshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    programCycle?: boolean | ProgramCycleDefaultArgs<ExtArgs>
  }

  export type $MentorshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mentorship"
    objects: {
      mentor: Prisma.$UserPayload<ExtArgs>
      programCycle: Prisma.$ProgramCyclePayload<ExtArgs>
      mentees: Prisma.$MentorshipMenteePayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      goals: Prisma.$GoalPayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mentorId: string
      type: string
      status: string
      programCycleId: string
      startDate: Date
      endDate: Date
      maxMentees: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mentorship"]>
    composites: {}
  }

  type MentorshipGetPayload<S extends boolean | null | undefined | MentorshipDefaultArgs> = $Result.GetResult<Prisma.$MentorshipPayload, S>

  type MentorshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorshipCountAggregateInputType | true
    }

  export interface MentorshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mentorship'], meta: { name: 'Mentorship' } }
    /**
     * Find zero or one Mentorship that matches the filter.
     * @param {MentorshipFindUniqueArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorshipFindUniqueArgs>(args: SelectSubset<T, MentorshipFindUniqueArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mentorship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorshipFindUniqueOrThrowArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorshipFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentorship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipFindFirstArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorshipFindFirstArgs>(args?: SelectSubset<T, MentorshipFindFirstArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentorship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipFindFirstOrThrowArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorshipFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mentorships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentorships
     * const mentorships = await prisma.mentorship.findMany()
     * 
     * // Get first 10 Mentorships
     * const mentorships = await prisma.mentorship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorshipWithIdOnly = await prisma.mentorship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorshipFindManyArgs>(args?: SelectSubset<T, MentorshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mentorship.
     * @param {MentorshipCreateArgs} args - Arguments to create a Mentorship.
     * @example
     * // Create one Mentorship
     * const Mentorship = await prisma.mentorship.create({
     *   data: {
     *     // ... data to create a Mentorship
     *   }
     * })
     * 
     */
    create<T extends MentorshipCreateArgs>(args: SelectSubset<T, MentorshipCreateArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mentorships.
     * @param {MentorshipCreateManyArgs} args - Arguments to create many Mentorships.
     * @example
     * // Create many Mentorships
     * const mentorship = await prisma.mentorship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorshipCreateManyArgs>(args?: SelectSubset<T, MentorshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentorships and returns the data saved in the database.
     * @param {MentorshipCreateManyAndReturnArgs} args - Arguments to create many Mentorships.
     * @example
     * // Create many Mentorships
     * const mentorship = await prisma.mentorship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentorships and only return the `id`
     * const mentorshipWithIdOnly = await prisma.mentorship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorshipCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mentorship.
     * @param {MentorshipDeleteArgs} args - Arguments to delete one Mentorship.
     * @example
     * // Delete one Mentorship
     * const Mentorship = await prisma.mentorship.delete({
     *   where: {
     *     // ... filter to delete one Mentorship
     *   }
     * })
     * 
     */
    delete<T extends MentorshipDeleteArgs>(args: SelectSubset<T, MentorshipDeleteArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mentorship.
     * @param {MentorshipUpdateArgs} args - Arguments to update one Mentorship.
     * @example
     * // Update one Mentorship
     * const mentorship = await prisma.mentorship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorshipUpdateArgs>(args: SelectSubset<T, MentorshipUpdateArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mentorships.
     * @param {MentorshipDeleteManyArgs} args - Arguments to filter Mentorships to delete.
     * @example
     * // Delete a few Mentorships
     * const { count } = await prisma.mentorship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorshipDeleteManyArgs>(args?: SelectSubset<T, MentorshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentorships
     * const mentorship = await prisma.mentorship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorshipUpdateManyArgs>(args: SelectSubset<T, MentorshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentorships and returns the data updated in the database.
     * @param {MentorshipUpdateManyAndReturnArgs} args - Arguments to update many Mentorships.
     * @example
     * // Update many Mentorships
     * const mentorship = await prisma.mentorship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mentorships and only return the `id`
     * const mentorshipWithIdOnly = await prisma.mentorship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorshipUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mentorship.
     * @param {MentorshipUpsertArgs} args - Arguments to update or create a Mentorship.
     * @example
     * // Update or create a Mentorship
     * const mentorship = await prisma.mentorship.upsert({
     *   create: {
     *     // ... data to create a Mentorship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentorship we want to update
     *   }
     * })
     */
    upsert<T extends MentorshipUpsertArgs>(args: SelectSubset<T, MentorshipUpsertArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mentorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipCountArgs} args - Arguments to filter Mentorships to count.
     * @example
     * // Count the number of Mentorships
     * const count = await prisma.mentorship.count({
     *   where: {
     *     // ... the filter for the Mentorships we want to count
     *   }
     * })
    **/
    count<T extends MentorshipCountArgs>(
      args?: Subset<T, MentorshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mentorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorshipAggregateArgs>(args: Subset<T, MentorshipAggregateArgs>): Prisma.PrismaPromise<GetMentorshipAggregateType<T>>

    /**
     * Group by Mentorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorshipGroupByArgs['orderBy'] }
        : { orderBy?: MentorshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mentorship model
   */
  readonly fields: MentorshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mentorship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    programCycle<T extends ProgramCycleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramCycleDefaultArgs<ExtArgs>>): Prisma__ProgramCycleClient<$Result.GetResult<Prisma.$ProgramCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mentees<T extends Mentorship$menteesArgs<ExtArgs> = {}>(args?: Subset<T, Mentorship$menteesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetings<T extends Mentorship$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Mentorship$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goals<T extends Mentorship$goalsArgs<ExtArgs> = {}>(args?: Subset<T, Mentorship$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends Mentorship$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Mentorship$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mentorship model
   */
  interface MentorshipFieldRefs {
    readonly id: FieldRef<"Mentorship", 'String'>
    readonly mentorId: FieldRef<"Mentorship", 'String'>
    readonly type: FieldRef<"Mentorship", 'String'>
    readonly status: FieldRef<"Mentorship", 'String'>
    readonly programCycleId: FieldRef<"Mentorship", 'String'>
    readonly startDate: FieldRef<"Mentorship", 'DateTime'>
    readonly endDate: FieldRef<"Mentorship", 'DateTime'>
    readonly maxMentees: FieldRef<"Mentorship", 'Int'>
    readonly notes: FieldRef<"Mentorship", 'String'>
    readonly createdAt: FieldRef<"Mentorship", 'DateTime'>
    readonly updatedAt: FieldRef<"Mentorship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mentorship findUnique
   */
  export type MentorshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship findUniqueOrThrow
   */
  export type MentorshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship findFirst
   */
  export type MentorshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentorships.
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentorships.
     */
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * Mentorship findFirstOrThrow
   */
  export type MentorshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentorships.
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentorships.
     */
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * Mentorship findMany
   */
  export type MentorshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorships to fetch.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentorships.
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * Mentorship create
   */
  export type MentorshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Mentorship.
     */
    data: XOR<MentorshipCreateInput, MentorshipUncheckedCreateInput>
  }

  /**
   * Mentorship createMany
   */
  export type MentorshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentorships.
     */
    data: MentorshipCreateManyInput | MentorshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mentorship createManyAndReturn
   */
  export type MentorshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * The data used to create many Mentorships.
     */
    data: MentorshipCreateManyInput | MentorshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentorship update
   */
  export type MentorshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Mentorship.
     */
    data: XOR<MentorshipUpdateInput, MentorshipUncheckedUpdateInput>
    /**
     * Choose, which Mentorship to update.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship updateMany
   */
  export type MentorshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentorships.
     */
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyInput>
    /**
     * Filter which Mentorships to update
     */
    where?: MentorshipWhereInput
    /**
     * Limit how many Mentorships to update.
     */
    limit?: number
  }

  /**
   * Mentorship updateManyAndReturn
   */
  export type MentorshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * The data used to update Mentorships.
     */
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyInput>
    /**
     * Filter which Mentorships to update
     */
    where?: MentorshipWhereInput
    /**
     * Limit how many Mentorships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentorship upsert
   */
  export type MentorshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Mentorship to update in case it exists.
     */
    where: MentorshipWhereUniqueInput
    /**
     * In case the Mentorship found by the `where` argument doesn't exist, create a new Mentorship with this data.
     */
    create: XOR<MentorshipCreateInput, MentorshipUncheckedCreateInput>
    /**
     * In case the Mentorship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorshipUpdateInput, MentorshipUncheckedUpdateInput>
  }

  /**
   * Mentorship delete
   */
  export type MentorshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter which Mentorship to delete.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship deleteMany
   */
  export type MentorshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentorships to delete
     */
    where?: MentorshipWhereInput
    /**
     * Limit how many Mentorships to delete.
     */
    limit?: number
  }

  /**
   * Mentorship.mentees
   */
  export type Mentorship$menteesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    where?: MentorshipMenteeWhereInput
    orderBy?: MentorshipMenteeOrderByWithRelationInput | MentorshipMenteeOrderByWithRelationInput[]
    cursor?: MentorshipMenteeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipMenteeScalarFieldEnum | MentorshipMenteeScalarFieldEnum[]
  }

  /**
   * Mentorship.meetings
   */
  export type Mentorship$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Mentorship.goals
   */
  export type Mentorship$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Mentorship.feedbacks
   */
  export type Mentorship$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Mentorship without action
   */
  export type MentorshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
  }


  /**
   * Model MentorshipMentee
   */

  export type AggregateMentorshipMentee = {
    _count: MentorshipMenteeCountAggregateOutputType | null
    _min: MentorshipMenteeMinAggregateOutputType | null
    _max: MentorshipMenteeMaxAggregateOutputType | null
  }

  export type MentorshipMenteeMinAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    menteeId: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type MentorshipMenteeMaxAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    menteeId: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type MentorshipMenteeCountAggregateOutputType = {
    id: number
    mentorshipId: number
    menteeId: number
    joinedAt: number
    status: number
    _all: number
  }


  export type MentorshipMenteeMinAggregateInputType = {
    id?: true
    mentorshipId?: true
    menteeId?: true
    joinedAt?: true
    status?: true
  }

  export type MentorshipMenteeMaxAggregateInputType = {
    id?: true
    mentorshipId?: true
    menteeId?: true
    joinedAt?: true
    status?: true
  }

  export type MentorshipMenteeCountAggregateInputType = {
    id?: true
    mentorshipId?: true
    menteeId?: true
    joinedAt?: true
    status?: true
    _all?: true
  }

  export type MentorshipMenteeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorshipMentee to aggregate.
     */
    where?: MentorshipMenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipMentees to fetch.
     */
    orderBy?: MentorshipMenteeOrderByWithRelationInput | MentorshipMenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorshipMenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipMentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipMentees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorshipMentees
    **/
    _count?: true | MentorshipMenteeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorshipMenteeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorshipMenteeMaxAggregateInputType
  }

  export type GetMentorshipMenteeAggregateType<T extends MentorshipMenteeAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorshipMentee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorshipMentee[P]>
      : GetScalarType<T[P], AggregateMentorshipMentee[P]>
  }




  export type MentorshipMenteeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipMenteeWhereInput
    orderBy?: MentorshipMenteeOrderByWithAggregationInput | MentorshipMenteeOrderByWithAggregationInput[]
    by: MentorshipMenteeScalarFieldEnum[] | MentorshipMenteeScalarFieldEnum
    having?: MentorshipMenteeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorshipMenteeCountAggregateInputType | true
    _min?: MentorshipMenteeMinAggregateInputType
    _max?: MentorshipMenteeMaxAggregateInputType
  }

  export type MentorshipMenteeGroupByOutputType = {
    id: string
    mentorshipId: string
    menteeId: string
    joinedAt: Date
    status: string
    _count: MentorshipMenteeCountAggregateOutputType | null
    _min: MentorshipMenteeMinAggregateOutputType | null
    _max: MentorshipMenteeMaxAggregateOutputType | null
  }

  type GetMentorshipMenteeGroupByPayload<T extends MentorshipMenteeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorshipMenteeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorshipMenteeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorshipMenteeGroupByOutputType[P]>
            : GetScalarType<T[P], MentorshipMenteeGroupByOutputType[P]>
        }
      >
    >


  export type MentorshipMenteeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    menteeId?: boolean
    joinedAt?: boolean
    status?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorshipMentee"]>

  export type MentorshipMenteeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    menteeId?: boolean
    joinedAt?: boolean
    status?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorshipMentee"]>

  export type MentorshipMenteeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    menteeId?: boolean
    joinedAt?: boolean
    status?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorshipMentee"]>

  export type MentorshipMenteeSelectScalar = {
    id?: boolean
    mentorshipId?: boolean
    menteeId?: boolean
    joinedAt?: boolean
    status?: boolean
  }

  export type MentorshipMenteeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mentorshipId" | "menteeId" | "joinedAt" | "status", ExtArgs["result"]["mentorshipMentee"]>
  export type MentorshipMenteeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorshipMenteeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorshipMenteeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorshipMenteePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorshipMentee"
    objects: {
      mentorship: Prisma.$MentorshipPayload<ExtArgs>
      mentee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mentorshipId: string
      menteeId: string
      joinedAt: Date
      status: string
    }, ExtArgs["result"]["mentorshipMentee"]>
    composites: {}
  }

  type MentorshipMenteeGetPayload<S extends boolean | null | undefined | MentorshipMenteeDefaultArgs> = $Result.GetResult<Prisma.$MentorshipMenteePayload, S>

  type MentorshipMenteeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorshipMenteeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorshipMenteeCountAggregateInputType | true
    }

  export interface MentorshipMenteeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorshipMentee'], meta: { name: 'MentorshipMentee' } }
    /**
     * Find zero or one MentorshipMentee that matches the filter.
     * @param {MentorshipMenteeFindUniqueArgs} args - Arguments to find a MentorshipMentee
     * @example
     * // Get one MentorshipMentee
     * const mentorshipMentee = await prisma.mentorshipMentee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorshipMenteeFindUniqueArgs>(args: SelectSubset<T, MentorshipMenteeFindUniqueArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorshipMentee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorshipMenteeFindUniqueOrThrowArgs} args - Arguments to find a MentorshipMentee
     * @example
     * // Get one MentorshipMentee
     * const mentorshipMentee = await prisma.mentorshipMentee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorshipMenteeFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorshipMenteeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorshipMentee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipMenteeFindFirstArgs} args - Arguments to find a MentorshipMentee
     * @example
     * // Get one MentorshipMentee
     * const mentorshipMentee = await prisma.mentorshipMentee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorshipMenteeFindFirstArgs>(args?: SelectSubset<T, MentorshipMenteeFindFirstArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorshipMentee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipMenteeFindFirstOrThrowArgs} args - Arguments to find a MentorshipMentee
     * @example
     * // Get one MentorshipMentee
     * const mentorshipMentee = await prisma.mentorshipMentee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorshipMenteeFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorshipMenteeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorshipMentees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipMenteeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorshipMentees
     * const mentorshipMentees = await prisma.mentorshipMentee.findMany()
     * 
     * // Get first 10 MentorshipMentees
     * const mentorshipMentees = await prisma.mentorshipMentee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorshipMenteeWithIdOnly = await prisma.mentorshipMentee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorshipMenteeFindManyArgs>(args?: SelectSubset<T, MentorshipMenteeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorshipMentee.
     * @param {MentorshipMenteeCreateArgs} args - Arguments to create a MentorshipMentee.
     * @example
     * // Create one MentorshipMentee
     * const MentorshipMentee = await prisma.mentorshipMentee.create({
     *   data: {
     *     // ... data to create a MentorshipMentee
     *   }
     * })
     * 
     */
    create<T extends MentorshipMenteeCreateArgs>(args: SelectSubset<T, MentorshipMenteeCreateArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorshipMentees.
     * @param {MentorshipMenteeCreateManyArgs} args - Arguments to create many MentorshipMentees.
     * @example
     * // Create many MentorshipMentees
     * const mentorshipMentee = await prisma.mentorshipMentee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorshipMenteeCreateManyArgs>(args?: SelectSubset<T, MentorshipMenteeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorshipMentees and returns the data saved in the database.
     * @param {MentorshipMenteeCreateManyAndReturnArgs} args - Arguments to create many MentorshipMentees.
     * @example
     * // Create many MentorshipMentees
     * const mentorshipMentee = await prisma.mentorshipMentee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorshipMentees and only return the `id`
     * const mentorshipMenteeWithIdOnly = await prisma.mentorshipMentee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorshipMenteeCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorshipMenteeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorshipMentee.
     * @param {MentorshipMenteeDeleteArgs} args - Arguments to delete one MentorshipMentee.
     * @example
     * // Delete one MentorshipMentee
     * const MentorshipMentee = await prisma.mentorshipMentee.delete({
     *   where: {
     *     // ... filter to delete one MentorshipMentee
     *   }
     * })
     * 
     */
    delete<T extends MentorshipMenteeDeleteArgs>(args: SelectSubset<T, MentorshipMenteeDeleteArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorshipMentee.
     * @param {MentorshipMenteeUpdateArgs} args - Arguments to update one MentorshipMentee.
     * @example
     * // Update one MentorshipMentee
     * const mentorshipMentee = await prisma.mentorshipMentee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorshipMenteeUpdateArgs>(args: SelectSubset<T, MentorshipMenteeUpdateArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorshipMentees.
     * @param {MentorshipMenteeDeleteManyArgs} args - Arguments to filter MentorshipMentees to delete.
     * @example
     * // Delete a few MentorshipMentees
     * const { count } = await prisma.mentorshipMentee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorshipMenteeDeleteManyArgs>(args?: SelectSubset<T, MentorshipMenteeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorshipMentees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipMenteeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorshipMentees
     * const mentorshipMentee = await prisma.mentorshipMentee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorshipMenteeUpdateManyArgs>(args: SelectSubset<T, MentorshipMenteeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorshipMentees and returns the data updated in the database.
     * @param {MentorshipMenteeUpdateManyAndReturnArgs} args - Arguments to update many MentorshipMentees.
     * @example
     * // Update many MentorshipMentees
     * const mentorshipMentee = await prisma.mentorshipMentee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorshipMentees and only return the `id`
     * const mentorshipMenteeWithIdOnly = await prisma.mentorshipMentee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorshipMenteeUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorshipMenteeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorshipMentee.
     * @param {MentorshipMenteeUpsertArgs} args - Arguments to update or create a MentorshipMentee.
     * @example
     * // Update or create a MentorshipMentee
     * const mentorshipMentee = await prisma.mentorshipMentee.upsert({
     *   create: {
     *     // ... data to create a MentorshipMentee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorshipMentee we want to update
     *   }
     * })
     */
    upsert<T extends MentorshipMenteeUpsertArgs>(args: SelectSubset<T, MentorshipMenteeUpsertArgs<ExtArgs>>): Prisma__MentorshipMenteeClient<$Result.GetResult<Prisma.$MentorshipMenteePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorshipMentees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipMenteeCountArgs} args - Arguments to filter MentorshipMentees to count.
     * @example
     * // Count the number of MentorshipMentees
     * const count = await prisma.mentorshipMentee.count({
     *   where: {
     *     // ... the filter for the MentorshipMentees we want to count
     *   }
     * })
    **/
    count<T extends MentorshipMenteeCountArgs>(
      args?: Subset<T, MentorshipMenteeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorshipMenteeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorshipMentee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipMenteeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorshipMenteeAggregateArgs>(args: Subset<T, MentorshipMenteeAggregateArgs>): Prisma.PrismaPromise<GetMentorshipMenteeAggregateType<T>>

    /**
     * Group by MentorshipMentee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipMenteeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorshipMenteeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorshipMenteeGroupByArgs['orderBy'] }
        : { orderBy?: MentorshipMenteeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorshipMenteeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorshipMenteeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorshipMentee model
   */
  readonly fields: MentorshipMenteeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorshipMentee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorshipMenteeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentorship<T extends MentorshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorshipDefaultArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mentee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorshipMentee model
   */
  interface MentorshipMenteeFieldRefs {
    readonly id: FieldRef<"MentorshipMentee", 'String'>
    readonly mentorshipId: FieldRef<"MentorshipMentee", 'String'>
    readonly menteeId: FieldRef<"MentorshipMentee", 'String'>
    readonly joinedAt: FieldRef<"MentorshipMentee", 'DateTime'>
    readonly status: FieldRef<"MentorshipMentee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MentorshipMentee findUnique
   */
  export type MentorshipMenteeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipMentee to fetch.
     */
    where: MentorshipMenteeWhereUniqueInput
  }

  /**
   * MentorshipMentee findUniqueOrThrow
   */
  export type MentorshipMenteeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipMentee to fetch.
     */
    where: MentorshipMenteeWhereUniqueInput
  }

  /**
   * MentorshipMentee findFirst
   */
  export type MentorshipMenteeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipMentee to fetch.
     */
    where?: MentorshipMenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipMentees to fetch.
     */
    orderBy?: MentorshipMenteeOrderByWithRelationInput | MentorshipMenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorshipMentees.
     */
    cursor?: MentorshipMenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipMentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipMentees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorshipMentees.
     */
    distinct?: MentorshipMenteeScalarFieldEnum | MentorshipMenteeScalarFieldEnum[]
  }

  /**
   * MentorshipMentee findFirstOrThrow
   */
  export type MentorshipMenteeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipMentee to fetch.
     */
    where?: MentorshipMenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipMentees to fetch.
     */
    orderBy?: MentorshipMenteeOrderByWithRelationInput | MentorshipMenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorshipMentees.
     */
    cursor?: MentorshipMenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipMentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipMentees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorshipMentees.
     */
    distinct?: MentorshipMenteeScalarFieldEnum | MentorshipMenteeScalarFieldEnum[]
  }

  /**
   * MentorshipMentee findMany
   */
  export type MentorshipMenteeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipMentees to fetch.
     */
    where?: MentorshipMenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipMentees to fetch.
     */
    orderBy?: MentorshipMenteeOrderByWithRelationInput | MentorshipMenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorshipMentees.
     */
    cursor?: MentorshipMenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipMentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipMentees.
     */
    skip?: number
    distinct?: MentorshipMenteeScalarFieldEnum | MentorshipMenteeScalarFieldEnum[]
  }

  /**
   * MentorshipMentee create
   */
  export type MentorshipMenteeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorshipMentee.
     */
    data: XOR<MentorshipMenteeCreateInput, MentorshipMenteeUncheckedCreateInput>
  }

  /**
   * MentorshipMentee createMany
   */
  export type MentorshipMenteeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorshipMentees.
     */
    data: MentorshipMenteeCreateManyInput | MentorshipMenteeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorshipMentee createManyAndReturn
   */
  export type MentorshipMenteeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * The data used to create many MentorshipMentees.
     */
    data: MentorshipMenteeCreateManyInput | MentorshipMenteeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorshipMentee update
   */
  export type MentorshipMenteeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorshipMentee.
     */
    data: XOR<MentorshipMenteeUpdateInput, MentorshipMenteeUncheckedUpdateInput>
    /**
     * Choose, which MentorshipMentee to update.
     */
    where: MentorshipMenteeWhereUniqueInput
  }

  /**
   * MentorshipMentee updateMany
   */
  export type MentorshipMenteeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorshipMentees.
     */
    data: XOR<MentorshipMenteeUpdateManyMutationInput, MentorshipMenteeUncheckedUpdateManyInput>
    /**
     * Filter which MentorshipMentees to update
     */
    where?: MentorshipMenteeWhereInput
    /**
     * Limit how many MentorshipMentees to update.
     */
    limit?: number
  }

  /**
   * MentorshipMentee updateManyAndReturn
   */
  export type MentorshipMenteeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * The data used to update MentorshipMentees.
     */
    data: XOR<MentorshipMenteeUpdateManyMutationInput, MentorshipMenteeUncheckedUpdateManyInput>
    /**
     * Filter which MentorshipMentees to update
     */
    where?: MentorshipMenteeWhereInput
    /**
     * Limit how many MentorshipMentees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorshipMentee upsert
   */
  export type MentorshipMenteeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorshipMentee to update in case it exists.
     */
    where: MentorshipMenteeWhereUniqueInput
    /**
     * In case the MentorshipMentee found by the `where` argument doesn't exist, create a new MentorshipMentee with this data.
     */
    create: XOR<MentorshipMenteeCreateInput, MentorshipMenteeUncheckedCreateInput>
    /**
     * In case the MentorshipMentee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorshipMenteeUpdateInput, MentorshipMenteeUncheckedUpdateInput>
  }

  /**
   * MentorshipMentee delete
   */
  export type MentorshipMenteeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
    /**
     * Filter which MentorshipMentee to delete.
     */
    where: MentorshipMenteeWhereUniqueInput
  }

  /**
   * MentorshipMentee deleteMany
   */
  export type MentorshipMenteeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorshipMentees to delete
     */
    where?: MentorshipMenteeWhereInput
    /**
     * Limit how many MentorshipMentees to delete.
     */
    limit?: number
  }

  /**
   * MentorshipMentee without action
   */
  export type MentorshipMenteeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipMentee
     */
    select?: MentorshipMenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipMentee
     */
    omit?: MentorshipMenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipMenteeInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    duration: number | null
  }

  export type MeetingSumAggregateOutputType = {
    duration: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    type: string | null
    meetingType: string | null
    scheduledAt: Date | null
    duration: number | null
    location: string | null
    meetingUrl: string | null
    status: string | null
    qrToken: string | null
    qrExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    type: string | null
    meetingType: string | null
    scheduledAt: Date | null
    duration: number | null
    location: string | null
    meetingUrl: string | null
    status: string | null
    qrToken: string | null
    qrExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    mentorshipId: number
    creatorId: number
    title: number
    description: number
    type: number
    meetingType: number
    scheduledAt: number
    duration: number
    location: number
    meetingUrl: number
    status: number
    qrToken: number
    qrExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    duration?: true
  }

  export type MeetingSumAggregateInputType = {
    duration?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    mentorshipId?: true
    creatorId?: true
    title?: true
    description?: true
    type?: true
    meetingType?: true
    scheduledAt?: true
    duration?: true
    location?: true
    meetingUrl?: true
    status?: true
    qrToken?: true
    qrExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    mentorshipId?: true
    creatorId?: true
    title?: true
    description?: true
    type?: true
    meetingType?: true
    scheduledAt?: true
    duration?: true
    location?: true
    meetingUrl?: true
    status?: true
    qrToken?: true
    qrExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    mentorshipId?: true
    creatorId?: true
    title?: true
    description?: true
    type?: true
    meetingType?: true
    scheduledAt?: true
    duration?: true
    location?: true
    meetingUrl?: true
    status?: true
    qrToken?: true
    qrExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: string
    mentorshipId: string
    creatorId: string
    title: string
    description: string | null
    type: string
    meetingType: string
    scheduledAt: Date
    duration: number
    location: string | null
    meetingUrl: string | null
    status: string
    qrToken: string | null
    qrExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    meetingType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    location?: boolean
    meetingUrl?: boolean
    status?: boolean
    qrToken?: boolean
    qrExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    attendances?: boolean | Meeting$attendancesArgs<ExtArgs>
    minutes?: boolean | Meeting$minutesArgs<ExtArgs>
    sessionReflections?: boolean | Meeting$sessionReflectionsArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    meetingType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    location?: boolean
    meetingUrl?: boolean
    status?: boolean
    qrToken?: boolean
    qrExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    meetingType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    location?: boolean
    meetingUrl?: boolean
    status?: boolean
    qrToken?: boolean
    qrExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectScalar = {
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    meetingType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    location?: boolean
    meetingUrl?: boolean
    status?: boolean
    qrToken?: boolean
    qrExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mentorshipId" | "creatorId" | "title" | "description" | "type" | "meetingType" | "scheduledAt" | "duration" | "location" | "meetingUrl" | "status" | "qrToken" | "qrExpiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["meeting"]>
  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    attendances?: boolean | Meeting$attendancesArgs<ExtArgs>
    minutes?: boolean | Meeting$minutesArgs<ExtArgs>
    sessionReflections?: boolean | Meeting$sessionReflectionsArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      mentorship: Prisma.$MentorshipPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      minutes: Prisma.$MeetingMinutesPayload<ExtArgs>[]
      sessionReflections: Prisma.$SessionReflectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mentorshipId: string
      creatorId: string
      title: string
      description: string | null
      type: string
      meetingType: string
      scheduledAt: Date
      duration: number
      location: string | null
      meetingUrl: string | null
      status: string
      qrToken: string | null
      qrExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meetings and returns the data saved in the database.
     * @param {MeetingCreateManyAndReturnArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings and returns the data updated in the database.
     * @param {MeetingUpdateManyAndReturnArgs} args - Arguments to update many Meetings.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeetingUpdateManyAndReturnArgs>(args: SelectSubset<T, MeetingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentorship<T extends MentorshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorshipDefaultArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendances<T extends Meeting$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    minutes<T extends Meeting$minutesArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$minutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionReflections<T extends Meeting$sessionReflectionsArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$sessionReflectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'String'>
    readonly mentorshipId: FieldRef<"Meeting", 'String'>
    readonly creatorId: FieldRef<"Meeting", 'String'>
    readonly title: FieldRef<"Meeting", 'String'>
    readonly description: FieldRef<"Meeting", 'String'>
    readonly type: FieldRef<"Meeting", 'String'>
    readonly meetingType: FieldRef<"Meeting", 'String'>
    readonly scheduledAt: FieldRef<"Meeting", 'DateTime'>
    readonly duration: FieldRef<"Meeting", 'Int'>
    readonly location: FieldRef<"Meeting", 'String'>
    readonly meetingUrl: FieldRef<"Meeting", 'String'>
    readonly status: FieldRef<"Meeting", 'String'>
    readonly qrToken: FieldRef<"Meeting", 'String'>
    readonly qrExpiresAt: FieldRef<"Meeting", 'DateTime'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"Meeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting createManyAndReturn
   */
  export type MeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
  }

  /**
   * Meeting updateManyAndReturn
   */
  export type MeetingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to delete.
     */
    limit?: number
  }

  /**
   * Meeting.attendances
   */
  export type Meeting$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Meeting.minutes
   */
  export type Meeting$minutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    where?: MeetingMinutesWhereInput
    orderBy?: MeetingMinutesOrderByWithRelationInput | MeetingMinutesOrderByWithRelationInput[]
    cursor?: MeetingMinutesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingMinutesScalarFieldEnum | MeetingMinutesScalarFieldEnum[]
  }

  /**
   * Meeting.sessionReflections
   */
  export type Meeting$sessionReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    where?: SessionReflectionWhereInput
    orderBy?: SessionReflectionOrderByWithRelationInput | SessionReflectionOrderByWithRelationInput[]
    cursor?: SessionReflectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionReflectionScalarFieldEnum | SessionReflectionScalarFieldEnum[]
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    checkInLat: number | null
    checkInLng: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    checkInLat: number | null
    checkInLng: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    checkInLat: number | null
    checkInLng: number | null
    deviceHash: string | null
    status: string | null
    verifiedAt: Date | null
    createdAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    checkInLat: number | null
    checkInLng: number | null
    deviceHash: string | null
    status: string | null
    verifiedAt: Date | null
    createdAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    meetingId: number
    userId: number
    checkInTime: number
    checkOutTime: number
    checkInLat: number
    checkInLng: number
    deviceHash: number
    status: number
    verifiedAt: number
    createdAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    checkInLat?: true
    checkInLng?: true
  }

  export type AttendanceSumAggregateInputType = {
    checkInLat?: true
    checkInLng?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    checkInLat?: true
    checkInLng?: true
    deviceHash?: true
    status?: true
    verifiedAt?: true
    createdAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    checkInLat?: true
    checkInLng?: true
    deviceHash?: true
    status?: true
    verifiedAt?: true
    createdAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    checkInLat?: true
    checkInLng?: true
    deviceHash?: true
    status?: true
    verifiedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    meetingId: string
    userId: string
    checkInTime: Date | null
    checkOutTime: Date | null
    checkInLat: number | null
    checkInLng: number | null
    deviceHash: string | null
    status: string
    verifiedAt: Date | null
    createdAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    checkInLat?: boolean
    checkInLng?: boolean
    deviceHash?: boolean
    status?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    checkInLat?: boolean
    checkInLng?: boolean
    deviceHash?: boolean
    status?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    checkInLat?: boolean
    checkInLng?: boolean
    deviceHash?: boolean
    status?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    checkInLat?: boolean
    checkInLng?: boolean
    deviceHash?: boolean
    status?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "meetingId" | "userId" | "checkInTime" | "checkOutTime" | "checkInLat" | "checkInLng" | "deviceHash" | "status" | "verifiedAt" | "createdAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingId: string
      userId: string
      checkInTime: Date | null
      checkOutTime: Date | null
      checkInLat: number | null
      checkInLng: number | null
      deviceHash: string | null
      status: string
      verifiedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingDefaultArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly meetingId: FieldRef<"Attendance", 'String'>
    readonly userId: FieldRef<"Attendance", 'String'>
    readonly checkInTime: FieldRef<"Attendance", 'DateTime'>
    readonly checkOutTime: FieldRef<"Attendance", 'DateTime'>
    readonly checkInLat: FieldRef<"Attendance", 'Float'>
    readonly checkInLng: FieldRef<"Attendance", 'Float'>
    readonly deviceHash: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'String'>
    readonly verifiedAt: FieldRef<"Attendance", 'DateTime'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model MeetingMinutes
   */

  export type AggregateMeetingMinutes = {
    _count: MeetingMinutesCountAggregateOutputType | null
    _min: MeetingMinutesMinAggregateOutputType | null
    _max: MeetingMinutesMaxAggregateOutputType | null
  }

  export type MeetingMinutesMinAggregateOutputType = {
    id: string | null
    meetingId: string | null
    authorId: string | null
    agenda: string | null
    keyPoints: string | null
    actionItems: string | null
    outcome: string | null
    attachments: string | null
    status: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingMinutesMaxAggregateOutputType = {
    id: string | null
    meetingId: string | null
    authorId: string | null
    agenda: string | null
    keyPoints: string | null
    actionItems: string | null
    outcome: string | null
    attachments: string | null
    status: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingMinutesCountAggregateOutputType = {
    id: number
    meetingId: number
    authorId: number
    agenda: number
    keyPoints: number
    actionItems: number
    outcome: number
    attachments: number
    status: number
    submittedAt: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingMinutesMinAggregateInputType = {
    id?: true
    meetingId?: true
    authorId?: true
    agenda?: true
    keyPoints?: true
    actionItems?: true
    outcome?: true
    attachments?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingMinutesMaxAggregateInputType = {
    id?: true
    meetingId?: true
    authorId?: true
    agenda?: true
    keyPoints?: true
    actionItems?: true
    outcome?: true
    attachments?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingMinutesCountAggregateInputType = {
    id?: true
    meetingId?: true
    authorId?: true
    agenda?: true
    keyPoints?: true
    actionItems?: true
    outcome?: true
    attachments?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingMinutesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingMinutes to aggregate.
     */
    where?: MeetingMinutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingMinutes to fetch.
     */
    orderBy?: MeetingMinutesOrderByWithRelationInput | MeetingMinutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingMinutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingMinutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingMinutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeetingMinutes
    **/
    _count?: true | MeetingMinutesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinutesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMinutesMaxAggregateInputType
  }

  export type GetMeetingMinutesAggregateType<T extends MeetingMinutesAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingMinutes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingMinutes[P]>
      : GetScalarType<T[P], AggregateMeetingMinutes[P]>
  }




  export type MeetingMinutesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingMinutesWhereInput
    orderBy?: MeetingMinutesOrderByWithAggregationInput | MeetingMinutesOrderByWithAggregationInput[]
    by: MeetingMinutesScalarFieldEnum[] | MeetingMinutesScalarFieldEnum
    having?: MeetingMinutesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingMinutesCountAggregateInputType | true
    _min?: MeetingMinutesMinAggregateInputType
    _max?: MeetingMinutesMaxAggregateInputType
  }

  export type MeetingMinutesGroupByOutputType = {
    id: string
    meetingId: string
    authorId: string
    agenda: string | null
    keyPoints: string | null
    actionItems: string | null
    outcome: string | null
    attachments: string | null
    status: string
    submittedAt: Date | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MeetingMinutesCountAggregateOutputType | null
    _min: MeetingMinutesMinAggregateOutputType | null
    _max: MeetingMinutesMaxAggregateOutputType | null
  }

  type GetMeetingMinutesGroupByPayload<T extends MeetingMinutesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingMinutesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingMinutesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingMinutesGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingMinutesGroupByOutputType[P]>
        }
      >
    >


  export type MeetingMinutesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    authorId?: boolean
    agenda?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    outcome?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingMinutes"]>

  export type MeetingMinutesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    authorId?: boolean
    agenda?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    outcome?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingMinutes"]>

  export type MeetingMinutesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    authorId?: boolean
    agenda?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    outcome?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingMinutes"]>

  export type MeetingMinutesSelectScalar = {
    id?: boolean
    meetingId?: boolean
    authorId?: boolean
    agenda?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    outcome?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingMinutesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "meetingId" | "authorId" | "agenda" | "keyPoints" | "actionItems" | "outcome" | "attachments" | "status" | "submittedAt" | "approvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["meetingMinutes"]>
  export type MeetingMinutesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingMinutesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingMinutesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeetingMinutesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeetingMinutes"
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingId: string
      authorId: string
      agenda: string | null
      keyPoints: string | null
      actionItems: string | null
      outcome: string | null
      attachments: string | null
      status: string
      submittedAt: Date | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meetingMinutes"]>
    composites: {}
  }

  type MeetingMinutesGetPayload<S extends boolean | null | undefined | MeetingMinutesDefaultArgs> = $Result.GetResult<Prisma.$MeetingMinutesPayload, S>

  type MeetingMinutesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingMinutesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingMinutesCountAggregateInputType | true
    }

  export interface MeetingMinutesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeetingMinutes'], meta: { name: 'MeetingMinutes' } }
    /**
     * Find zero or one MeetingMinutes that matches the filter.
     * @param {MeetingMinutesFindUniqueArgs} args - Arguments to find a MeetingMinutes
     * @example
     * // Get one MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingMinutesFindUniqueArgs>(args: SelectSubset<T, MeetingMinutesFindUniqueArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MeetingMinutes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingMinutesFindUniqueOrThrowArgs} args - Arguments to find a MeetingMinutes
     * @example
     * // Get one MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingMinutesFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingMinutesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingMinutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingMinutesFindFirstArgs} args - Arguments to find a MeetingMinutes
     * @example
     * // Get one MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingMinutesFindFirstArgs>(args?: SelectSubset<T, MeetingMinutesFindFirstArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingMinutes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingMinutesFindFirstOrThrowArgs} args - Arguments to find a MeetingMinutes
     * @example
     * // Get one MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingMinutesFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingMinutesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MeetingMinutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingMinutesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.findMany()
     * 
     * // Get first 10 MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingMinutesWithIdOnly = await prisma.meetingMinutes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingMinutesFindManyArgs>(args?: SelectSubset<T, MeetingMinutesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MeetingMinutes.
     * @param {MeetingMinutesCreateArgs} args - Arguments to create a MeetingMinutes.
     * @example
     * // Create one MeetingMinutes
     * const MeetingMinutes = await prisma.meetingMinutes.create({
     *   data: {
     *     // ... data to create a MeetingMinutes
     *   }
     * })
     * 
     */
    create<T extends MeetingMinutesCreateArgs>(args: SelectSubset<T, MeetingMinutesCreateArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MeetingMinutes.
     * @param {MeetingMinutesCreateManyArgs} args - Arguments to create many MeetingMinutes.
     * @example
     * // Create many MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingMinutesCreateManyArgs>(args?: SelectSubset<T, MeetingMinutesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeetingMinutes and returns the data saved in the database.
     * @param {MeetingMinutesCreateManyAndReturnArgs} args - Arguments to create many MeetingMinutes.
     * @example
     * // Create many MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeetingMinutes and only return the `id`
     * const meetingMinutesWithIdOnly = await prisma.meetingMinutes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingMinutesCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingMinutesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MeetingMinutes.
     * @param {MeetingMinutesDeleteArgs} args - Arguments to delete one MeetingMinutes.
     * @example
     * // Delete one MeetingMinutes
     * const MeetingMinutes = await prisma.meetingMinutes.delete({
     *   where: {
     *     // ... filter to delete one MeetingMinutes
     *   }
     * })
     * 
     */
    delete<T extends MeetingMinutesDeleteArgs>(args: SelectSubset<T, MeetingMinutesDeleteArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MeetingMinutes.
     * @param {MeetingMinutesUpdateArgs} args - Arguments to update one MeetingMinutes.
     * @example
     * // Update one MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingMinutesUpdateArgs>(args: SelectSubset<T, MeetingMinutesUpdateArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MeetingMinutes.
     * @param {MeetingMinutesDeleteManyArgs} args - Arguments to filter MeetingMinutes to delete.
     * @example
     * // Delete a few MeetingMinutes
     * const { count } = await prisma.meetingMinutes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingMinutesDeleteManyArgs>(args?: SelectSubset<T, MeetingMinutesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingMinutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingMinutesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingMinutesUpdateManyArgs>(args: SelectSubset<T, MeetingMinutesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingMinutes and returns the data updated in the database.
     * @param {MeetingMinutesUpdateManyAndReturnArgs} args - Arguments to update many MeetingMinutes.
     * @example
     * // Update many MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MeetingMinutes and only return the `id`
     * const meetingMinutesWithIdOnly = await prisma.meetingMinutes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeetingMinutesUpdateManyAndReturnArgs>(args: SelectSubset<T, MeetingMinutesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MeetingMinutes.
     * @param {MeetingMinutesUpsertArgs} args - Arguments to update or create a MeetingMinutes.
     * @example
     * // Update or create a MeetingMinutes
     * const meetingMinutes = await prisma.meetingMinutes.upsert({
     *   create: {
     *     // ... data to create a MeetingMinutes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingMinutes we want to update
     *   }
     * })
     */
    upsert<T extends MeetingMinutesUpsertArgs>(args: SelectSubset<T, MeetingMinutesUpsertArgs<ExtArgs>>): Prisma__MeetingMinutesClient<$Result.GetResult<Prisma.$MeetingMinutesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MeetingMinutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingMinutesCountArgs} args - Arguments to filter MeetingMinutes to count.
     * @example
     * // Count the number of MeetingMinutes
     * const count = await prisma.meetingMinutes.count({
     *   where: {
     *     // ... the filter for the MeetingMinutes we want to count
     *   }
     * })
    **/
    count<T extends MeetingMinutesCountArgs>(
      args?: Subset<T, MeetingMinutesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingMinutesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeetingMinutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingMinutesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingMinutesAggregateArgs>(args: Subset<T, MeetingMinutesAggregateArgs>): Prisma.PrismaPromise<GetMeetingMinutesAggregateType<T>>

    /**
     * Group by MeetingMinutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingMinutesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingMinutesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingMinutesGroupByArgs['orderBy'] }
        : { orderBy?: MeetingMinutesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingMinutesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingMinutesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeetingMinutes model
   */
  readonly fields: MeetingMinutesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingMinutes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingMinutesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingDefaultArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeetingMinutes model
   */
  interface MeetingMinutesFieldRefs {
    readonly id: FieldRef<"MeetingMinutes", 'String'>
    readonly meetingId: FieldRef<"MeetingMinutes", 'String'>
    readonly authorId: FieldRef<"MeetingMinutes", 'String'>
    readonly agenda: FieldRef<"MeetingMinutes", 'String'>
    readonly keyPoints: FieldRef<"MeetingMinutes", 'String'>
    readonly actionItems: FieldRef<"MeetingMinutes", 'String'>
    readonly outcome: FieldRef<"MeetingMinutes", 'String'>
    readonly attachments: FieldRef<"MeetingMinutes", 'String'>
    readonly status: FieldRef<"MeetingMinutes", 'String'>
    readonly submittedAt: FieldRef<"MeetingMinutes", 'DateTime'>
    readonly approvedAt: FieldRef<"MeetingMinutes", 'DateTime'>
    readonly createdAt: FieldRef<"MeetingMinutes", 'DateTime'>
    readonly updatedAt: FieldRef<"MeetingMinutes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeetingMinutes findUnique
   */
  export type MeetingMinutesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * Filter, which MeetingMinutes to fetch.
     */
    where: MeetingMinutesWhereUniqueInput
  }

  /**
   * MeetingMinutes findUniqueOrThrow
   */
  export type MeetingMinutesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * Filter, which MeetingMinutes to fetch.
     */
    where: MeetingMinutesWhereUniqueInput
  }

  /**
   * MeetingMinutes findFirst
   */
  export type MeetingMinutesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * Filter, which MeetingMinutes to fetch.
     */
    where?: MeetingMinutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingMinutes to fetch.
     */
    orderBy?: MeetingMinutesOrderByWithRelationInput | MeetingMinutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingMinutes.
     */
    cursor?: MeetingMinutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingMinutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingMinutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingMinutes.
     */
    distinct?: MeetingMinutesScalarFieldEnum | MeetingMinutesScalarFieldEnum[]
  }

  /**
   * MeetingMinutes findFirstOrThrow
   */
  export type MeetingMinutesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * Filter, which MeetingMinutes to fetch.
     */
    where?: MeetingMinutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingMinutes to fetch.
     */
    orderBy?: MeetingMinutesOrderByWithRelationInput | MeetingMinutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingMinutes.
     */
    cursor?: MeetingMinutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingMinutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingMinutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingMinutes.
     */
    distinct?: MeetingMinutesScalarFieldEnum | MeetingMinutesScalarFieldEnum[]
  }

  /**
   * MeetingMinutes findMany
   */
  export type MeetingMinutesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * Filter, which MeetingMinutes to fetch.
     */
    where?: MeetingMinutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingMinutes to fetch.
     */
    orderBy?: MeetingMinutesOrderByWithRelationInput | MeetingMinutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeetingMinutes.
     */
    cursor?: MeetingMinutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingMinutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingMinutes.
     */
    skip?: number
    distinct?: MeetingMinutesScalarFieldEnum | MeetingMinutesScalarFieldEnum[]
  }

  /**
   * MeetingMinutes create
   */
  export type MeetingMinutesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * The data needed to create a MeetingMinutes.
     */
    data: XOR<MeetingMinutesCreateInput, MeetingMinutesUncheckedCreateInput>
  }

  /**
   * MeetingMinutes createMany
   */
  export type MeetingMinutesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeetingMinutes.
     */
    data: MeetingMinutesCreateManyInput | MeetingMinutesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingMinutes createManyAndReturn
   */
  export type MeetingMinutesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * The data used to create many MeetingMinutes.
     */
    data: MeetingMinutesCreateManyInput | MeetingMinutesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingMinutes update
   */
  export type MeetingMinutesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * The data needed to update a MeetingMinutes.
     */
    data: XOR<MeetingMinutesUpdateInput, MeetingMinutesUncheckedUpdateInput>
    /**
     * Choose, which MeetingMinutes to update.
     */
    where: MeetingMinutesWhereUniqueInput
  }

  /**
   * MeetingMinutes updateMany
   */
  export type MeetingMinutesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeetingMinutes.
     */
    data: XOR<MeetingMinutesUpdateManyMutationInput, MeetingMinutesUncheckedUpdateManyInput>
    /**
     * Filter which MeetingMinutes to update
     */
    where?: MeetingMinutesWhereInput
    /**
     * Limit how many MeetingMinutes to update.
     */
    limit?: number
  }

  /**
   * MeetingMinutes updateManyAndReturn
   */
  export type MeetingMinutesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * The data used to update MeetingMinutes.
     */
    data: XOR<MeetingMinutesUpdateManyMutationInput, MeetingMinutesUncheckedUpdateManyInput>
    /**
     * Filter which MeetingMinutes to update
     */
    where?: MeetingMinutesWhereInput
    /**
     * Limit how many MeetingMinutes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingMinutes upsert
   */
  export type MeetingMinutesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * The filter to search for the MeetingMinutes to update in case it exists.
     */
    where: MeetingMinutesWhereUniqueInput
    /**
     * In case the MeetingMinutes found by the `where` argument doesn't exist, create a new MeetingMinutes with this data.
     */
    create: XOR<MeetingMinutesCreateInput, MeetingMinutesUncheckedCreateInput>
    /**
     * In case the MeetingMinutes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingMinutesUpdateInput, MeetingMinutesUncheckedUpdateInput>
  }

  /**
   * MeetingMinutes delete
   */
  export type MeetingMinutesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
    /**
     * Filter which MeetingMinutes to delete.
     */
    where: MeetingMinutesWhereUniqueInput
  }

  /**
   * MeetingMinutes deleteMany
   */
  export type MeetingMinutesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingMinutes to delete
     */
    where?: MeetingMinutesWhereInput
    /**
     * Limit how many MeetingMinutes to delete.
     */
    limit?: number
  }

  /**
   * MeetingMinutes without action
   */
  export type MeetingMinutesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingMinutes
     */
    select?: MeetingMinutesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingMinutes
     */
    omit?: MeetingMinutesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingMinutesInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type GoalSumAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type GoalMinAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    category: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    completedAt: Date | null
    mentorConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalMaxAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    category: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    completedAt: Date | null
    mentorConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    mentorshipId: number
    creatorId: number
    title: number
    description: number
    category: number
    targetValue: number
    currentValue: number
    unit: number
    status: number
    priority: number
    dueDate: number
    completedAt: number
    mentorConfirmed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type GoalSumAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    mentorshipId?: true
    creatorId?: true
    title?: true
    description?: true
    category?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    mentorConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    mentorshipId?: true
    creatorId?: true
    title?: true
    description?: true
    category?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    mentorConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    mentorshipId?: true
    creatorId?: true
    title?: true
    description?: true
    category?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    mentorConfirmed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: string
    mentorshipId: string
    creatorId: string
    title: string
    description: string | null
    category: string
    targetValue: number | null
    currentValue: number
    unit: string | null
    status: string
    priority: string
    dueDate: Date | null
    completedAt: Date | null
    mentorConfirmed: boolean
    createdAt: Date
    updatedAt: Date
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    progressNotes?: boolean | Goal$progressNotesArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectScalar = {
    id?: boolean
    mentorshipId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mentorshipId" | "creatorId" | "title" | "description" | "category" | "targetValue" | "currentValue" | "unit" | "status" | "priority" | "dueDate" | "completedAt" | "mentorConfirmed" | "createdAt" | "updatedAt", ExtArgs["result"]["goal"]>
  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    progressNotes?: boolean | Goal$progressNotesArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      mentorship: Prisma.$MentorshipPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      progressNotes: Prisma.$ProgressNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mentorshipId: string
      creatorId: string
      title: string
      description: string | null
      category: string
      targetValue: number | null
      currentValue: number
      unit: string | null
      status: string
      priority: string
      dueDate: Date | null
      completedAt: Date | null
      mentorConfirmed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals and returns the data updated in the database.
     * @param {GoalUpdateManyAndReturnArgs} args - Arguments to update many Goals.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoalUpdateManyAndReturnArgs>(args: SelectSubset<T, GoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentorship<T extends MentorshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorshipDefaultArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    progressNotes<T extends Goal$progressNotesArgs<ExtArgs> = {}>(args?: Subset<T, Goal$progressNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'String'>
    readonly mentorshipId: FieldRef<"Goal", 'String'>
    readonly creatorId: FieldRef<"Goal", 'String'>
    readonly title: FieldRef<"Goal", 'String'>
    readonly description: FieldRef<"Goal", 'String'>
    readonly category: FieldRef<"Goal", 'String'>
    readonly targetValue: FieldRef<"Goal", 'Int'>
    readonly currentValue: FieldRef<"Goal", 'Int'>
    readonly unit: FieldRef<"Goal", 'String'>
    readonly status: FieldRef<"Goal", 'String'>
    readonly priority: FieldRef<"Goal", 'String'>
    readonly dueDate: FieldRef<"Goal", 'DateTime'>
    readonly completedAt: FieldRef<"Goal", 'DateTime'>
    readonly mentorConfirmed: FieldRef<"Goal", 'Boolean'>
    readonly createdAt: FieldRef<"Goal", 'DateTime'>
    readonly updatedAt: FieldRef<"Goal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
  }

  /**
   * Goal updateManyAndReturn
   */
  export type GoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to delete.
     */
    limit?: number
  }

  /**
   * Goal.progressNotes
   */
  export type Goal$progressNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    where?: ProgressNoteWhereInput
    orderBy?: ProgressNoteOrderByWithRelationInput | ProgressNoteOrderByWithRelationInput[]
    cursor?: ProgressNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressNoteScalarFieldEnum | ProgressNoteScalarFieldEnum[]
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model ProgressNote
   */

  export type AggregateProgressNote = {
    _count: ProgressNoteCountAggregateOutputType | null
    _avg: ProgressNoteAvgAggregateOutputType | null
    _sum: ProgressNoteSumAggregateOutputType | null
    _min: ProgressNoteMinAggregateOutputType | null
    _max: ProgressNoteMaxAggregateOutputType | null
  }

  export type ProgressNoteAvgAggregateOutputType = {
    value: number | null
  }

  export type ProgressNoteSumAggregateOutputType = {
    value: number | null
  }

  export type ProgressNoteMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    note: string | null
    value: number | null
    createdAt: Date | null
  }

  export type ProgressNoteMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    note: string | null
    value: number | null
    createdAt: Date | null
  }

  export type ProgressNoteCountAggregateOutputType = {
    id: number
    goalId: number
    note: number
    value: number
    createdAt: number
    _all: number
  }


  export type ProgressNoteAvgAggregateInputType = {
    value?: true
  }

  export type ProgressNoteSumAggregateInputType = {
    value?: true
  }

  export type ProgressNoteMinAggregateInputType = {
    id?: true
    goalId?: true
    note?: true
    value?: true
    createdAt?: true
  }

  export type ProgressNoteMaxAggregateInputType = {
    id?: true
    goalId?: true
    note?: true
    value?: true
    createdAt?: true
  }

  export type ProgressNoteCountAggregateInputType = {
    id?: true
    goalId?: true
    note?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type ProgressNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressNote to aggregate.
     */
    where?: ProgressNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressNotes to fetch.
     */
    orderBy?: ProgressNoteOrderByWithRelationInput | ProgressNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgressNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgressNotes
    **/
    _count?: true | ProgressNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgressNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgressNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgressNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgressNoteMaxAggregateInputType
  }

  export type GetProgressNoteAggregateType<T extends ProgressNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateProgressNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgressNote[P]>
      : GetScalarType<T[P], AggregateProgressNote[P]>
  }




  export type ProgressNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressNoteWhereInput
    orderBy?: ProgressNoteOrderByWithAggregationInput | ProgressNoteOrderByWithAggregationInput[]
    by: ProgressNoteScalarFieldEnum[] | ProgressNoteScalarFieldEnum
    having?: ProgressNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgressNoteCountAggregateInputType | true
    _avg?: ProgressNoteAvgAggregateInputType
    _sum?: ProgressNoteSumAggregateInputType
    _min?: ProgressNoteMinAggregateInputType
    _max?: ProgressNoteMaxAggregateInputType
  }

  export type ProgressNoteGroupByOutputType = {
    id: string
    goalId: string
    note: string
    value: number | null
    createdAt: Date
    _count: ProgressNoteCountAggregateOutputType | null
    _avg: ProgressNoteAvgAggregateOutputType | null
    _sum: ProgressNoteSumAggregateOutputType | null
    _min: ProgressNoteMinAggregateOutputType | null
    _max: ProgressNoteMaxAggregateOutputType | null
  }

  type GetProgressNoteGroupByPayload<T extends ProgressNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgressNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgressNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgressNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ProgressNoteGroupByOutputType[P]>
        }
      >
    >


  export type ProgressNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    note?: boolean
    value?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressNote"]>

  export type ProgressNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    note?: boolean
    value?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressNote"]>

  export type ProgressNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    note?: boolean
    value?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressNote"]>

  export type ProgressNoteSelectScalar = {
    id?: boolean
    goalId?: boolean
    note?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type ProgressNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goalId" | "note" | "value" | "createdAt", ExtArgs["result"]["progressNote"]>
  export type ProgressNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type ProgressNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type ProgressNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }

  export type $ProgressNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgressNote"
    objects: {
      goal: Prisma.$GoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      note: string
      value: number | null
      createdAt: Date
    }, ExtArgs["result"]["progressNote"]>
    composites: {}
  }

  type ProgressNoteGetPayload<S extends boolean | null | undefined | ProgressNoteDefaultArgs> = $Result.GetResult<Prisma.$ProgressNotePayload, S>

  type ProgressNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgressNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgressNoteCountAggregateInputType | true
    }

  export interface ProgressNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgressNote'], meta: { name: 'ProgressNote' } }
    /**
     * Find zero or one ProgressNote that matches the filter.
     * @param {ProgressNoteFindUniqueArgs} args - Arguments to find a ProgressNote
     * @example
     * // Get one ProgressNote
     * const progressNote = await prisma.progressNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgressNoteFindUniqueArgs>(args: SelectSubset<T, ProgressNoteFindUniqueArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgressNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgressNoteFindUniqueOrThrowArgs} args - Arguments to find a ProgressNote
     * @example
     * // Get one ProgressNote
     * const progressNote = await prisma.progressNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgressNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgressNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressNoteFindFirstArgs} args - Arguments to find a ProgressNote
     * @example
     * // Get one ProgressNote
     * const progressNote = await prisma.progressNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgressNoteFindFirstArgs>(args?: SelectSubset<T, ProgressNoteFindFirstArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressNoteFindFirstOrThrowArgs} args - Arguments to find a ProgressNote
     * @example
     * // Get one ProgressNote
     * const progressNote = await prisma.progressNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgressNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgressNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgressNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgressNotes
     * const progressNotes = await prisma.progressNote.findMany()
     * 
     * // Get first 10 ProgressNotes
     * const progressNotes = await prisma.progressNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progressNoteWithIdOnly = await prisma.progressNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgressNoteFindManyArgs>(args?: SelectSubset<T, ProgressNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgressNote.
     * @param {ProgressNoteCreateArgs} args - Arguments to create a ProgressNote.
     * @example
     * // Create one ProgressNote
     * const ProgressNote = await prisma.progressNote.create({
     *   data: {
     *     // ... data to create a ProgressNote
     *   }
     * })
     * 
     */
    create<T extends ProgressNoteCreateArgs>(args: SelectSubset<T, ProgressNoteCreateArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgressNotes.
     * @param {ProgressNoteCreateManyArgs} args - Arguments to create many ProgressNotes.
     * @example
     * // Create many ProgressNotes
     * const progressNote = await prisma.progressNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgressNoteCreateManyArgs>(args?: SelectSubset<T, ProgressNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgressNotes and returns the data saved in the database.
     * @param {ProgressNoteCreateManyAndReturnArgs} args - Arguments to create many ProgressNotes.
     * @example
     * // Create many ProgressNotes
     * const progressNote = await prisma.progressNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgressNotes and only return the `id`
     * const progressNoteWithIdOnly = await prisma.progressNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgressNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgressNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgressNote.
     * @param {ProgressNoteDeleteArgs} args - Arguments to delete one ProgressNote.
     * @example
     * // Delete one ProgressNote
     * const ProgressNote = await prisma.progressNote.delete({
     *   where: {
     *     // ... filter to delete one ProgressNote
     *   }
     * })
     * 
     */
    delete<T extends ProgressNoteDeleteArgs>(args: SelectSubset<T, ProgressNoteDeleteArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgressNote.
     * @param {ProgressNoteUpdateArgs} args - Arguments to update one ProgressNote.
     * @example
     * // Update one ProgressNote
     * const progressNote = await prisma.progressNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgressNoteUpdateArgs>(args: SelectSubset<T, ProgressNoteUpdateArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgressNotes.
     * @param {ProgressNoteDeleteManyArgs} args - Arguments to filter ProgressNotes to delete.
     * @example
     * // Delete a few ProgressNotes
     * const { count } = await prisma.progressNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgressNoteDeleteManyArgs>(args?: SelectSubset<T, ProgressNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgressNotes
     * const progressNote = await prisma.progressNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgressNoteUpdateManyArgs>(args: SelectSubset<T, ProgressNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressNotes and returns the data updated in the database.
     * @param {ProgressNoteUpdateManyAndReturnArgs} args - Arguments to update many ProgressNotes.
     * @example
     * // Update many ProgressNotes
     * const progressNote = await prisma.progressNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgressNotes and only return the `id`
     * const progressNoteWithIdOnly = await prisma.progressNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgressNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgressNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgressNote.
     * @param {ProgressNoteUpsertArgs} args - Arguments to update or create a ProgressNote.
     * @example
     * // Update or create a ProgressNote
     * const progressNote = await prisma.progressNote.upsert({
     *   create: {
     *     // ... data to create a ProgressNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgressNote we want to update
     *   }
     * })
     */
    upsert<T extends ProgressNoteUpsertArgs>(args: SelectSubset<T, ProgressNoteUpsertArgs<ExtArgs>>): Prisma__ProgressNoteClient<$Result.GetResult<Prisma.$ProgressNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgressNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressNoteCountArgs} args - Arguments to filter ProgressNotes to count.
     * @example
     * // Count the number of ProgressNotes
     * const count = await prisma.progressNote.count({
     *   where: {
     *     // ... the filter for the ProgressNotes we want to count
     *   }
     * })
    **/
    count<T extends ProgressNoteCountArgs>(
      args?: Subset<T, ProgressNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgressNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgressNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgressNoteAggregateArgs>(args: Subset<T, ProgressNoteAggregateArgs>): Prisma.PrismaPromise<GetProgressNoteAggregateType<T>>

    /**
     * Group by ProgressNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgressNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgressNoteGroupByArgs['orderBy'] }
        : { orderBy?: ProgressNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgressNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgressNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgressNote model
   */
  readonly fields: ProgressNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgressNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgressNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends GoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoalDefaultArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgressNote model
   */
  interface ProgressNoteFieldRefs {
    readonly id: FieldRef<"ProgressNote", 'String'>
    readonly goalId: FieldRef<"ProgressNote", 'String'>
    readonly note: FieldRef<"ProgressNote", 'String'>
    readonly value: FieldRef<"ProgressNote", 'Int'>
    readonly createdAt: FieldRef<"ProgressNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgressNote findUnique
   */
  export type ProgressNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * Filter, which ProgressNote to fetch.
     */
    where: ProgressNoteWhereUniqueInput
  }

  /**
   * ProgressNote findUniqueOrThrow
   */
  export type ProgressNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * Filter, which ProgressNote to fetch.
     */
    where: ProgressNoteWhereUniqueInput
  }

  /**
   * ProgressNote findFirst
   */
  export type ProgressNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * Filter, which ProgressNote to fetch.
     */
    where?: ProgressNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressNotes to fetch.
     */
    orderBy?: ProgressNoteOrderByWithRelationInput | ProgressNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressNotes.
     */
    cursor?: ProgressNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressNotes.
     */
    distinct?: ProgressNoteScalarFieldEnum | ProgressNoteScalarFieldEnum[]
  }

  /**
   * ProgressNote findFirstOrThrow
   */
  export type ProgressNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * Filter, which ProgressNote to fetch.
     */
    where?: ProgressNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressNotes to fetch.
     */
    orderBy?: ProgressNoteOrderByWithRelationInput | ProgressNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressNotes.
     */
    cursor?: ProgressNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressNotes.
     */
    distinct?: ProgressNoteScalarFieldEnum | ProgressNoteScalarFieldEnum[]
  }

  /**
   * ProgressNote findMany
   */
  export type ProgressNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * Filter, which ProgressNotes to fetch.
     */
    where?: ProgressNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressNotes to fetch.
     */
    orderBy?: ProgressNoteOrderByWithRelationInput | ProgressNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgressNotes.
     */
    cursor?: ProgressNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressNotes.
     */
    skip?: number
    distinct?: ProgressNoteScalarFieldEnum | ProgressNoteScalarFieldEnum[]
  }

  /**
   * ProgressNote create
   */
  export type ProgressNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgressNote.
     */
    data: XOR<ProgressNoteCreateInput, ProgressNoteUncheckedCreateInput>
  }

  /**
   * ProgressNote createMany
   */
  export type ProgressNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgressNotes.
     */
    data: ProgressNoteCreateManyInput | ProgressNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgressNote createManyAndReturn
   */
  export type ProgressNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * The data used to create many ProgressNotes.
     */
    data: ProgressNoteCreateManyInput | ProgressNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressNote update
   */
  export type ProgressNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgressNote.
     */
    data: XOR<ProgressNoteUpdateInput, ProgressNoteUncheckedUpdateInput>
    /**
     * Choose, which ProgressNote to update.
     */
    where: ProgressNoteWhereUniqueInput
  }

  /**
   * ProgressNote updateMany
   */
  export type ProgressNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgressNotes.
     */
    data: XOR<ProgressNoteUpdateManyMutationInput, ProgressNoteUncheckedUpdateManyInput>
    /**
     * Filter which ProgressNotes to update
     */
    where?: ProgressNoteWhereInput
    /**
     * Limit how many ProgressNotes to update.
     */
    limit?: number
  }

  /**
   * ProgressNote updateManyAndReturn
   */
  export type ProgressNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * The data used to update ProgressNotes.
     */
    data: XOR<ProgressNoteUpdateManyMutationInput, ProgressNoteUncheckedUpdateManyInput>
    /**
     * Filter which ProgressNotes to update
     */
    where?: ProgressNoteWhereInput
    /**
     * Limit how many ProgressNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressNote upsert
   */
  export type ProgressNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgressNote to update in case it exists.
     */
    where: ProgressNoteWhereUniqueInput
    /**
     * In case the ProgressNote found by the `where` argument doesn't exist, create a new ProgressNote with this data.
     */
    create: XOR<ProgressNoteCreateInput, ProgressNoteUncheckedCreateInput>
    /**
     * In case the ProgressNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgressNoteUpdateInput, ProgressNoteUncheckedUpdateInput>
  }

  /**
   * ProgressNote delete
   */
  export type ProgressNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
    /**
     * Filter which ProgressNote to delete.
     */
    where: ProgressNoteWhereUniqueInput
  }

  /**
   * ProgressNote deleteMany
   */
  export type ProgressNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressNotes to delete
     */
    where?: ProgressNoteWhereInput
    /**
     * Limit how many ProgressNotes to delete.
     */
    limit?: number
  }

  /**
   * ProgressNote without action
   */
  export type ProgressNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressNote
     */
    select?: ProgressNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressNote
     */
    omit?: ProgressNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressNoteInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
    communication: number | null
    engagement: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
    communication: number | null
    engagement: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    fromUserId: string | null
    toUserId: string | null
    type: string | null
    rating: number | null
    communication: number | null
    engagement: number | null
    content: string | null
    strengths: string | null
    improvements: string | null
    isAnonymous: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    mentorshipId: string | null
    fromUserId: string | null
    toUserId: string | null
    type: string | null
    rating: number | null
    communication: number | null
    engagement: number | null
    content: string | null
    strengths: string | null
    improvements: string | null
    isAnonymous: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    mentorshipId: number
    fromUserId: number
    toUserId: number
    type: number
    rating: number
    communication: number
    engagement: number
    content: number
    strengths: number
    improvements: number
    isAnonymous: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
    communication?: true
    engagement?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
    communication?: true
    engagement?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    mentorshipId?: true
    fromUserId?: true
    toUserId?: true
    type?: true
    rating?: true
    communication?: true
    engagement?: true
    content?: true
    strengths?: true
    improvements?: true
    isAnonymous?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    mentorshipId?: true
    fromUserId?: true
    toUserId?: true
    type?: true
    rating?: true
    communication?: true
    engagement?: true
    content?: true
    strengths?: true
    improvements?: true
    isAnonymous?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    mentorshipId?: true
    fromUserId?: true
    toUserId?: true
    type?: true
    rating?: true
    communication?: true
    engagement?: true
    content?: true
    strengths?: true
    improvements?: true
    isAnonymous?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    mentorshipId: string
    fromUserId: string
    toUserId: string
    type: string
    rating: number | null
    communication: number | null
    engagement: number | null
    content: string | null
    strengths: string | null
    improvements: string | null
    isAnonymous: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    type?: boolean
    rating?: boolean
    communication?: boolean
    engagement?: boolean
    content?: boolean
    strengths?: boolean
    improvements?: boolean
    isAnonymous?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    type?: boolean
    rating?: boolean
    communication?: boolean
    engagement?: boolean
    content?: boolean
    strengths?: boolean
    improvements?: boolean
    isAnonymous?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorshipId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    type?: boolean
    rating?: boolean
    communication?: boolean
    engagement?: boolean
    content?: boolean
    strengths?: boolean
    improvements?: boolean
    isAnonymous?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    mentorshipId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    type?: boolean
    rating?: boolean
    communication?: boolean
    engagement?: boolean
    content?: boolean
    strengths?: boolean
    improvements?: boolean
    isAnonymous?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mentorshipId" | "fromUserId" | "toUserId" | "type" | "rating" | "communication" | "engagement" | "content" | "strengths" | "improvements" | "isAnonymous" | "createdAt" | "updatedAt", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentorship?: boolean | MentorshipDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      mentorship: Prisma.$MentorshipPayload<ExtArgs>
      fromUser: Prisma.$UserPayload<ExtArgs>
      toUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mentorshipId: string
      fromUserId: string
      toUserId: string
      type: string
      rating: number | null
      communication: number | null
      engagement: number | null
      content: string | null
      strengths: string | null
      improvements: string | null
      isAnonymous: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentorship<T extends MentorshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorshipDefaultArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly mentorshipId: FieldRef<"Feedback", 'String'>
    readonly fromUserId: FieldRef<"Feedback", 'String'>
    readonly toUserId: FieldRef<"Feedback", 'String'>
    readonly type: FieldRef<"Feedback", 'String'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly communication: FieldRef<"Feedback", 'Int'>
    readonly engagement: FieldRef<"Feedback", 'Int'>
    readonly content: FieldRef<"Feedback", 'String'>
    readonly strengths: FieldRef<"Feedback", 'String'>
    readonly improvements: FieldRef<"Feedback", 'String'>
    readonly isAnonymous: FieldRef<"Feedback", 'Boolean'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ResourceSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    fileUrl: string | null
    linkUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    category: string | null
    tags: string | null
    visibility: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    fileUrl: string | null
    linkUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    category: string | null
    tags: string | null
    visibility: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    fileUrl: number
    linkUrl: number
    fileName: number
    fileSize: number
    mimeType: number
    category: number
    tags: number
    visibility: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    fileSize?: true
  }

  export type ResourceSumAggregateInputType = {
    fileSize?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    fileUrl?: true
    linkUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    category?: true
    tags?: true
    visibility?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    fileUrl?: true
    linkUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    category?: true
    tags?: true
    visibility?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    fileUrl?: true
    linkUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    category?: true
    tags?: true
    visibility?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: string
    fileUrl: string | null
    linkUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    category: string | null
    tags: string | null
    visibility: string
    uploadedById: string
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    fileUrl?: boolean
    linkUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    category?: boolean
    tags?: boolean
    visibility?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    fileUrl?: boolean
    linkUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    category?: boolean
    tags?: boolean
    visibility?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    fileUrl?: boolean
    linkUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    category?: boolean
    tags?: boolean
    visibility?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    fileUrl?: boolean
    linkUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    category?: boolean
    tags?: boolean
    visibility?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "fileUrl" | "linkUrl" | "fileName" | "fileSize" | "mimeType" | "category" | "tags" | "visibility" | "uploadedById" | "createdAt" | "updatedAt", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: string
      fileUrl: string | null
      linkUrl: string | null
      fileName: string | null
      fileSize: number | null
      mimeType: string | null
      category: string | null
      tags: string | null
      visibility: string
      uploadedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'String'>
    readonly fileUrl: FieldRef<"Resource", 'String'>
    readonly linkUrl: FieldRef<"Resource", 'String'>
    readonly fileName: FieldRef<"Resource", 'String'>
    readonly fileSize: FieldRef<"Resource", 'Int'>
    readonly mimeType: FieldRef<"Resource", 'String'>
    readonly category: FieldRef<"Resource", 'String'>
    readonly tags: FieldRef<"Resource", 'String'>
    readonly visibility: FieldRef<"Resource", 'String'>
    readonly uploadedById: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model Portfolio
   */

  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  export type PortfolioAvgAggregateOutputType = {
    finalGoalsAchieved: number | null
  }

  export type PortfolioSumAggregateOutputType = {
    finalGoalsAchieved: number | null
  }

  export type PortfolioMinAggregateOutputType = {
    id: string | null
    menteeId: string | null
    personalityMbti: string | null
    personalityDisc: string | null
    personalityHolland: string | null
    competencies: string | null
    shortTermGoals: string | null
    longTermGoals: string | null
    initialCompletedAt: Date | null
    initialStrengths: string | null
    initialWeaknesses: string | null
    initialChallenges: string | null
    initialStartupIdeas: string | null
    initialPersonalNotes: string | null
    finalGoalsAchieved: number | null
    finalSkillsGained: string | null
    finalMentorFeedback: string | null
    finalSelfAssessment: string | null
    finalRecommendations: string | null
    finalStrengths: string | null
    finalWeaknesses: string | null
    finalChallenges: string | null
    finalStartupIdeas: string | null
    finalPersonalNotes: string | null
    finalCompletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioMaxAggregateOutputType = {
    id: string | null
    menteeId: string | null
    personalityMbti: string | null
    personalityDisc: string | null
    personalityHolland: string | null
    competencies: string | null
    shortTermGoals: string | null
    longTermGoals: string | null
    initialCompletedAt: Date | null
    initialStrengths: string | null
    initialWeaknesses: string | null
    initialChallenges: string | null
    initialStartupIdeas: string | null
    initialPersonalNotes: string | null
    finalGoalsAchieved: number | null
    finalSkillsGained: string | null
    finalMentorFeedback: string | null
    finalSelfAssessment: string | null
    finalRecommendations: string | null
    finalStrengths: string | null
    finalWeaknesses: string | null
    finalChallenges: string | null
    finalStartupIdeas: string | null
    finalPersonalNotes: string | null
    finalCompletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioCountAggregateOutputType = {
    id: number
    menteeId: number
    personalityMbti: number
    personalityDisc: number
    personalityHolland: number
    competencies: number
    shortTermGoals: number
    longTermGoals: number
    initialCompletedAt: number
    initialStrengths: number
    initialWeaknesses: number
    initialChallenges: number
    initialStartupIdeas: number
    initialPersonalNotes: number
    finalGoalsAchieved: number
    finalSkillsGained: number
    finalMentorFeedback: number
    finalSelfAssessment: number
    finalRecommendations: number
    finalStrengths: number
    finalWeaknesses: number
    finalChallenges: number
    finalStartupIdeas: number
    finalPersonalNotes: number
    finalCompletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioAvgAggregateInputType = {
    finalGoalsAchieved?: true
  }

  export type PortfolioSumAggregateInputType = {
    finalGoalsAchieved?: true
  }

  export type PortfolioMinAggregateInputType = {
    id?: true
    menteeId?: true
    personalityMbti?: true
    personalityDisc?: true
    personalityHolland?: true
    competencies?: true
    shortTermGoals?: true
    longTermGoals?: true
    initialCompletedAt?: true
    initialStrengths?: true
    initialWeaknesses?: true
    initialChallenges?: true
    initialStartupIdeas?: true
    initialPersonalNotes?: true
    finalGoalsAchieved?: true
    finalSkillsGained?: true
    finalMentorFeedback?: true
    finalSelfAssessment?: true
    finalRecommendations?: true
    finalStrengths?: true
    finalWeaknesses?: true
    finalChallenges?: true
    finalStartupIdeas?: true
    finalPersonalNotes?: true
    finalCompletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioMaxAggregateInputType = {
    id?: true
    menteeId?: true
    personalityMbti?: true
    personalityDisc?: true
    personalityHolland?: true
    competencies?: true
    shortTermGoals?: true
    longTermGoals?: true
    initialCompletedAt?: true
    initialStrengths?: true
    initialWeaknesses?: true
    initialChallenges?: true
    initialStartupIdeas?: true
    initialPersonalNotes?: true
    finalGoalsAchieved?: true
    finalSkillsGained?: true
    finalMentorFeedback?: true
    finalSelfAssessment?: true
    finalRecommendations?: true
    finalStrengths?: true
    finalWeaknesses?: true
    finalChallenges?: true
    finalStartupIdeas?: true
    finalPersonalNotes?: true
    finalCompletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioCountAggregateInputType = {
    id?: true
    menteeId?: true
    personalityMbti?: true
    personalityDisc?: true
    personalityHolland?: true
    competencies?: true
    shortTermGoals?: true
    longTermGoals?: true
    initialCompletedAt?: true
    initialStrengths?: true
    initialWeaknesses?: true
    initialChallenges?: true
    initialStartupIdeas?: true
    initialPersonalNotes?: true
    finalGoalsAchieved?: true
    finalSkillsGained?: true
    finalMentorFeedback?: true
    finalSelfAssessment?: true
    finalRecommendations?: true
    finalStrengths?: true
    finalWeaknesses?: true
    finalChallenges?: true
    finalStartupIdeas?: true
    finalPersonalNotes?: true
    finalCompletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolio to aggregate.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Portfolios
    **/
    _count?: true | PortfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioMaxAggregateInputType
  }

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>
  }




  export type PortfolioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithAggregationInput | PortfolioOrderByWithAggregationInput[]
    by: PortfolioScalarFieldEnum[] | PortfolioScalarFieldEnum
    having?: PortfolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCountAggregateInputType | true
    _avg?: PortfolioAvgAggregateInputType
    _sum?: PortfolioSumAggregateInputType
    _min?: PortfolioMinAggregateInputType
    _max?: PortfolioMaxAggregateInputType
  }

  export type PortfolioGroupByOutputType = {
    id: string
    menteeId: string
    personalityMbti: string | null
    personalityDisc: string | null
    personalityHolland: string | null
    competencies: string | null
    shortTermGoals: string | null
    longTermGoals: string | null
    initialCompletedAt: Date | null
    initialStrengths: string | null
    initialWeaknesses: string | null
    initialChallenges: string | null
    initialStartupIdeas: string | null
    initialPersonalNotes: string | null
    finalGoalsAchieved: number | null
    finalSkillsGained: string | null
    finalMentorFeedback: string | null
    finalSelfAssessment: string | null
    finalRecommendations: string | null
    finalStrengths: string | null
    finalWeaknesses: string | null
    finalChallenges: string | null
    finalStartupIdeas: string | null
    finalPersonalNotes: string | null
    finalCompletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  type GetPortfolioGroupByPayload<T extends PortfolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menteeId?: boolean
    personalityMbti?: boolean
    personalityDisc?: boolean
    personalityHolland?: boolean
    competencies?: boolean
    shortTermGoals?: boolean
    longTermGoals?: boolean
    initialCompletedAt?: boolean
    initialStrengths?: boolean
    initialWeaknesses?: boolean
    initialChallenges?: boolean
    initialStartupIdeas?: boolean
    initialPersonalNotes?: boolean
    finalGoalsAchieved?: boolean
    finalSkillsGained?: boolean
    finalMentorFeedback?: boolean
    finalSelfAssessment?: boolean
    finalRecommendations?: boolean
    finalStrengths?: boolean
    finalWeaknesses?: boolean
    finalChallenges?: boolean
    finalStartupIdeas?: boolean
    finalPersonalNotes?: boolean
    finalCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menteeId?: boolean
    personalityMbti?: boolean
    personalityDisc?: boolean
    personalityHolland?: boolean
    competencies?: boolean
    shortTermGoals?: boolean
    longTermGoals?: boolean
    initialCompletedAt?: boolean
    initialStrengths?: boolean
    initialWeaknesses?: boolean
    initialChallenges?: boolean
    initialStartupIdeas?: boolean
    initialPersonalNotes?: boolean
    finalGoalsAchieved?: boolean
    finalSkillsGained?: boolean
    finalMentorFeedback?: boolean
    finalSelfAssessment?: boolean
    finalRecommendations?: boolean
    finalStrengths?: boolean
    finalWeaknesses?: boolean
    finalChallenges?: boolean
    finalStartupIdeas?: boolean
    finalPersonalNotes?: boolean
    finalCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menteeId?: boolean
    personalityMbti?: boolean
    personalityDisc?: boolean
    personalityHolland?: boolean
    competencies?: boolean
    shortTermGoals?: boolean
    longTermGoals?: boolean
    initialCompletedAt?: boolean
    initialStrengths?: boolean
    initialWeaknesses?: boolean
    initialChallenges?: boolean
    initialStartupIdeas?: boolean
    initialPersonalNotes?: boolean
    finalGoalsAchieved?: boolean
    finalSkillsGained?: boolean
    finalMentorFeedback?: boolean
    finalSelfAssessment?: boolean
    finalRecommendations?: boolean
    finalStrengths?: boolean
    finalWeaknesses?: boolean
    finalChallenges?: boolean
    finalStartupIdeas?: boolean
    finalPersonalNotes?: boolean
    finalCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectScalar = {
    id?: boolean
    menteeId?: boolean
    personalityMbti?: boolean
    personalityDisc?: boolean
    personalityHolland?: boolean
    competencies?: boolean
    shortTermGoals?: boolean
    longTermGoals?: boolean
    initialCompletedAt?: boolean
    initialStrengths?: boolean
    initialWeaknesses?: boolean
    initialChallenges?: boolean
    initialStartupIdeas?: boolean
    initialPersonalNotes?: boolean
    finalGoalsAchieved?: boolean
    finalSkillsGained?: boolean
    finalMentorFeedback?: boolean
    finalSelfAssessment?: boolean
    finalRecommendations?: boolean
    finalStrengths?: boolean
    finalWeaknesses?: boolean
    finalChallenges?: boolean
    finalStartupIdeas?: boolean
    finalPersonalNotes?: boolean
    finalCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menteeId" | "personalityMbti" | "personalityDisc" | "personalityHolland" | "competencies" | "shortTermGoals" | "longTermGoals" | "initialCompletedAt" | "initialStrengths" | "initialWeaknesses" | "initialChallenges" | "initialStartupIdeas" | "initialPersonalNotes" | "finalGoalsAchieved" | "finalSkillsGained" | "finalMentorFeedback" | "finalSelfAssessment" | "finalRecommendations" | "finalStrengths" | "finalWeaknesses" | "finalChallenges" | "finalStartupIdeas" | "finalPersonalNotes" | "finalCompletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolio"]>
  export type PortfolioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PortfolioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Portfolio"
    objects: {
      mentee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      menteeId: string
      personalityMbti: string | null
      personalityDisc: string | null
      personalityHolland: string | null
      competencies: string | null
      shortTermGoals: string | null
      longTermGoals: string | null
      initialCompletedAt: Date | null
      initialStrengths: string | null
      initialWeaknesses: string | null
      initialChallenges: string | null
      initialStartupIdeas: string | null
      initialPersonalNotes: string | null
      finalGoalsAchieved: number | null
      finalSkillsGained: string | null
      finalMentorFeedback: string | null
      finalSelfAssessment: string | null
      finalRecommendations: string | null
      finalStrengths: string | null
      finalWeaknesses: string | null
      finalChallenges: string | null
      finalStartupIdeas: string | null
      finalPersonalNotes: string | null
      finalCompletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolio"]>
    composites: {}
  }

  type PortfolioGetPayload<S extends boolean | null | undefined | PortfolioDefaultArgs> = $Result.GetResult<Prisma.$PortfolioPayload, S>

  type PortfolioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioCountAggregateInputType | true
    }

  export interface PortfolioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Portfolio'], meta: { name: 'Portfolio' } }
    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {PortfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioFindUniqueArgs>(args: SelectSubset<T, PortfolioFindUniqueArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Portfolio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioFindFirstArgs>(args?: SelectSubset<T, PortfolioFindFirstArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     * 
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioFindManyArgs>(args?: SelectSubset<T, PortfolioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Portfolio.
     * @param {PortfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     * 
     */
    create<T extends PortfolioCreateArgs>(args: SelectSubset<T, PortfolioCreateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Portfolios.
     * @param {PortfolioCreateManyArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioCreateManyArgs>(args?: SelectSubset<T, PortfolioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Portfolios and returns the data saved in the database.
     * @param {PortfolioCreateManyAndReturnArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Portfolio.
     * @param {PortfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     * 
     */
    delete<T extends PortfolioDeleteArgs>(args: SelectSubset<T, PortfolioDeleteArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Portfolio.
     * @param {PortfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioUpdateArgs>(args: SelectSubset<T, PortfolioUpdateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Portfolios.
     * @param {PortfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioDeleteManyArgs>(args?: SelectSubset<T, PortfolioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioUpdateManyArgs>(args: SelectSubset<T, PortfolioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios and returns the data updated in the database.
     * @param {PortfolioUpdateManyAndReturnArgs} args - Arguments to update many Portfolios.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Portfolio.
     * @param {PortfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioUpsertArgs>(args: SelectSubset<T, PortfolioUpsertArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
    **/
    count<T extends PortfolioCountArgs>(
      args?: Subset<T, PortfolioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioAggregateArgs>(args: Subset<T, PortfolioAggregateArgs>): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Portfolio model
   */
  readonly fields: PortfolioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Portfolio model
   */
  interface PortfolioFieldRefs {
    readonly id: FieldRef<"Portfolio", 'String'>
    readonly menteeId: FieldRef<"Portfolio", 'String'>
    readonly personalityMbti: FieldRef<"Portfolio", 'String'>
    readonly personalityDisc: FieldRef<"Portfolio", 'String'>
    readonly personalityHolland: FieldRef<"Portfolio", 'String'>
    readonly competencies: FieldRef<"Portfolio", 'String'>
    readonly shortTermGoals: FieldRef<"Portfolio", 'String'>
    readonly longTermGoals: FieldRef<"Portfolio", 'String'>
    readonly initialCompletedAt: FieldRef<"Portfolio", 'DateTime'>
    readonly initialStrengths: FieldRef<"Portfolio", 'String'>
    readonly initialWeaknesses: FieldRef<"Portfolio", 'String'>
    readonly initialChallenges: FieldRef<"Portfolio", 'String'>
    readonly initialStartupIdeas: FieldRef<"Portfolio", 'String'>
    readonly initialPersonalNotes: FieldRef<"Portfolio", 'String'>
    readonly finalGoalsAchieved: FieldRef<"Portfolio", 'Int'>
    readonly finalSkillsGained: FieldRef<"Portfolio", 'String'>
    readonly finalMentorFeedback: FieldRef<"Portfolio", 'String'>
    readonly finalSelfAssessment: FieldRef<"Portfolio", 'String'>
    readonly finalRecommendations: FieldRef<"Portfolio", 'String'>
    readonly finalStrengths: FieldRef<"Portfolio", 'String'>
    readonly finalWeaknesses: FieldRef<"Portfolio", 'String'>
    readonly finalChallenges: FieldRef<"Portfolio", 'String'>
    readonly finalStartupIdeas: FieldRef<"Portfolio", 'String'>
    readonly finalPersonalNotes: FieldRef<"Portfolio", 'String'>
    readonly finalCompletedAt: FieldRef<"Portfolio", 'DateTime'>
    readonly createdAt: FieldRef<"Portfolio", 'DateTime'>
    readonly updatedAt: FieldRef<"Portfolio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Portfolio findUnique
   */
  export type PortfolioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findUniqueOrThrow
   */
  export type PortfolioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findFirst
   */
  export type PortfolioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findFirstOrThrow
   */
  export type PortfolioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findMany
   */
  export type PortfolioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolios to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio create
   */
  export type PortfolioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to create a Portfolio.
     */
    data: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
  }

  /**
   * Portfolio createMany
   */
  export type PortfolioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portfolio createManyAndReturn
   */
  export type PortfolioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio update
   */
  export type PortfolioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to update a Portfolio.
     */
    data: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
    /**
     * Choose, which Portfolio to update.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio updateMany
   */
  export type PortfolioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
  }

  /**
   * Portfolio updateManyAndReturn
   */
  export type PortfolioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio upsert
   */
  export type PortfolioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The filter to search for the Portfolio to update in case it exists.
     */
    where: PortfolioWhereUniqueInput
    /**
     * In case the Portfolio found by the `where` argument doesn't exist, create a new Portfolio with this data.
     */
    create: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
    /**
     * In case the Portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
  }

  /**
   * Portfolio delete
   */
  export type PortfolioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter which Portfolio to delete.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio deleteMany
   */
  export type PortfolioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolios to delete
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to delete.
     */
    limit?: number
  }

  /**
   * Portfolio without action
   */
  export type PortfolioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
  }


  /**
   * Model Availability
   */

  export type AggregateAvailability = {
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  export type AvailabilityAvgAggregateOutputType = {
    dayOfWeek: number | null
    duration: number | null
  }

  export type AvailabilitySumAggregateOutputType = {
    dayOfWeek: number | null
    duration: number | null
  }

  export type AvailabilityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityCountAggregateOutputType = {
    id: number
    userId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    duration: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvailabilityAvgAggregateInputType = {
    dayOfWeek?: true
    duration?: true
  }

  export type AvailabilitySumAggregateInputType = {
    dayOfWeek?: true
    duration?: true
  }

  export type AvailabilityMinAggregateInputType = {
    id?: true
    userId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityMaxAggregateInputType = {
    id?: true
    userId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityCountAggregateInputType = {
    id?: true
    userId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availability to aggregate.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Availabilities
    **/
    _count?: true | AvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityMaxAggregateInputType
  }

  export type GetAvailabilityAggregateType<T extends AvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailability[P]>
      : GetScalarType<T[P], AggregateAvailability[P]>
  }




  export type AvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithAggregationInput | AvailabilityOrderByWithAggregationInput[]
    by: AvailabilityScalarFieldEnum[] | AvailabilityScalarFieldEnum
    having?: AvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityCountAggregateInputType | true
    _avg?: AvailabilityAvgAggregateInputType
    _sum?: AvailabilitySumAggregateInputType
    _min?: AvailabilityMinAggregateInputType
    _max?: AvailabilityMaxAggregateInputType
  }

  export type AvailabilityGroupByOutputType = {
    id: string
    userId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  type GetAvailabilityGroupByPayload<T extends AvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectScalar = {
    id?: boolean
    userId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dayOfWeek" | "startTime" | "endTime" | "duration" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["availability"]>
  export type AvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Availability"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dayOfWeek: number
      startTime: string
      endTime: string
      duration: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["availability"]>
    composites: {}
  }

  type AvailabilityGetPayload<S extends boolean | null | undefined | AvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityPayload, S>

  type AvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailabilityCountAggregateInputType | true
    }

  export interface AvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Availability'], meta: { name: 'Availability' } }
    /**
     * Find zero or one Availability that matches the filter.
     * @param {AvailabilityFindUniqueArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityFindUniqueArgs>(args: SelectSubset<T, AvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Availability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailabilityFindUniqueOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityFindFirstArgs>(args?: SelectSubset<T, AvailabilityFindFirstArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Availabilities
     * const availabilities = await prisma.availability.findMany()
     * 
     * // Get first 10 Availabilities
     * const availabilities = await prisma.availability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilityWithIdOnly = await prisma.availability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilityFindManyArgs>(args?: SelectSubset<T, AvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Availability.
     * @param {AvailabilityCreateArgs} args - Arguments to create a Availability.
     * @example
     * // Create one Availability
     * const Availability = await prisma.availability.create({
     *   data: {
     *     // ... data to create a Availability
     *   }
     * })
     * 
     */
    create<T extends AvailabilityCreateArgs>(args: SelectSubset<T, AvailabilityCreateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Availabilities.
     * @param {AvailabilityCreateManyArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityCreateManyArgs>(args?: SelectSubset<T, AvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Availabilities and returns the data saved in the database.
     * @param {AvailabilityCreateManyAndReturnArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Availability.
     * @param {AvailabilityDeleteArgs} args - Arguments to delete one Availability.
     * @example
     * // Delete one Availability
     * const Availability = await prisma.availability.delete({
     *   where: {
     *     // ... filter to delete one Availability
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityDeleteArgs>(args: SelectSubset<T, AvailabilityDeleteArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Availability.
     * @param {AvailabilityUpdateArgs} args - Arguments to update one Availability.
     * @example
     * // Update one Availability
     * const availability = await prisma.availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityUpdateArgs>(args: SelectSubset<T, AvailabilityUpdateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Availabilities.
     * @param {AvailabilityDeleteManyArgs} args - Arguments to filter Availabilities to delete.
     * @example
     * // Delete a few Availabilities
     * const { count } = await prisma.availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityDeleteManyArgs>(args?: SelectSubset<T, AvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityUpdateManyArgs>(args: SelectSubset<T, AvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities and returns the data updated in the database.
     * @param {AvailabilityUpdateManyAndReturnArgs} args - Arguments to update many Availabilities.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Availability.
     * @param {AvailabilityUpsertArgs} args - Arguments to update or create a Availability.
     * @example
     * // Update or create a Availability
     * const availability = await prisma.availability.upsert({
     *   create: {
     *     // ... data to create a Availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Availability we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityUpsertArgs>(args: SelectSubset<T, AvailabilityUpsertArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityCountArgs} args - Arguments to filter Availabilities to count.
     * @example
     * // Count the number of Availabilities
     * const count = await prisma.availability.count({
     *   where: {
     *     // ... the filter for the Availabilities we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityCountArgs>(
      args?: Subset<T, AvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityAggregateArgs>(args: Subset<T, AvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityAggregateType<T>>

    /**
     * Group by Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Availability model
   */
  readonly fields: AvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Availability model
   */
  interface AvailabilityFieldRefs {
    readonly id: FieldRef<"Availability", 'String'>
    readonly userId: FieldRef<"Availability", 'String'>
    readonly dayOfWeek: FieldRef<"Availability", 'Int'>
    readonly startTime: FieldRef<"Availability", 'String'>
    readonly endTime: FieldRef<"Availability", 'String'>
    readonly duration: FieldRef<"Availability", 'Int'>
    readonly isActive: FieldRef<"Availability", 'Boolean'>
    readonly createdAt: FieldRef<"Availability", 'DateTime'>
    readonly updatedAt: FieldRef<"Availability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Availability findUnique
   */
  export type AvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findUniqueOrThrow
   */
  export type AvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findFirst
   */
  export type AvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findFirstOrThrow
   */
  export type AvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findMany
   */
  export type AvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availabilities to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability create
   */
  export type AvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Availability.
     */
    data: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
  }

  /**
   * Availability createMany
   */
  export type AvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Availability createManyAndReturn
   */
  export type AvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability update
   */
  export type AvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Availability.
     */
    data: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
    /**
     * Choose, which Availability to update.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability updateMany
   */
  export type AvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
  }

  /**
   * Availability updateManyAndReturn
   */
  export type AvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability upsert
   */
  export type AvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Availability to update in case it exists.
     */
    where: AvailabilityWhereUniqueInput
    /**
     * In case the Availability found by the `where` argument doesn't exist, create a new Availability with this data.
     */
    create: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
    /**
     * In case the Availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
  }

  /**
   * Availability delete
   */
  export type AvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter which Availability to delete.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability deleteMany
   */
  export type AvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availabilities to delete
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to delete.
     */
    limit?: number
  }

  /**
   * Availability without action
   */
  export type AvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    link: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    link: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    link: number
    isRead: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    link?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    link?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    link?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    link: string | null
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "link" | "isRead" | "readAt" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      link: string | null
      isRead: boolean
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SessionReflection
   */

  export type AggregateSessionReflection = {
    _count: SessionReflectionCountAggregateOutputType | null
    _min: SessionReflectionMinAggregateOutputType | null
    _max: SessionReflectionMaxAggregateOutputType | null
  }

  export type SessionReflectionMinAggregateOutputType = {
    id: string | null
    meetingId: string | null
    menteeId: string | null
    content: string | null
    mentorConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionReflectionMaxAggregateOutputType = {
    id: string | null
    meetingId: string | null
    menteeId: string | null
    content: string | null
    mentorConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionReflectionCountAggregateOutputType = {
    id: number
    meetingId: number
    menteeId: number
    content: number
    mentorConfirmed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionReflectionMinAggregateInputType = {
    id?: true
    meetingId?: true
    menteeId?: true
    content?: true
    mentorConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionReflectionMaxAggregateInputType = {
    id?: true
    meetingId?: true
    menteeId?: true
    content?: true
    mentorConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionReflectionCountAggregateInputType = {
    id?: true
    meetingId?: true
    menteeId?: true
    content?: true
    mentorConfirmed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionReflectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionReflection to aggregate.
     */
    where?: SessionReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionReflections to fetch.
     */
    orderBy?: SessionReflectionOrderByWithRelationInput | SessionReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionReflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionReflections
    **/
    _count?: true | SessionReflectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionReflectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionReflectionMaxAggregateInputType
  }

  export type GetSessionReflectionAggregateType<T extends SessionReflectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionReflection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionReflection[P]>
      : GetScalarType<T[P], AggregateSessionReflection[P]>
  }




  export type SessionReflectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionReflectionWhereInput
    orderBy?: SessionReflectionOrderByWithAggregationInput | SessionReflectionOrderByWithAggregationInput[]
    by: SessionReflectionScalarFieldEnum[] | SessionReflectionScalarFieldEnum
    having?: SessionReflectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionReflectionCountAggregateInputType | true
    _min?: SessionReflectionMinAggregateInputType
    _max?: SessionReflectionMaxAggregateInputType
  }

  export type SessionReflectionGroupByOutputType = {
    id: string
    meetingId: string
    menteeId: string
    content: string | null
    mentorConfirmed: boolean
    createdAt: Date
    updatedAt: Date
    _count: SessionReflectionCountAggregateOutputType | null
    _min: SessionReflectionMinAggregateOutputType | null
    _max: SessionReflectionMaxAggregateOutputType | null
  }

  type GetSessionReflectionGroupByPayload<T extends SessionReflectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionReflectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionReflectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionReflectionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionReflectionGroupByOutputType[P]>
        }
      >
    >


  export type SessionReflectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    menteeId?: boolean
    content?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    todoItems?: boolean | SessionReflection$todoItemsArgs<ExtArgs>
    _count?: boolean | SessionReflectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionReflection"]>

  export type SessionReflectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    menteeId?: boolean
    content?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionReflection"]>

  export type SessionReflectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    menteeId?: boolean
    content?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionReflection"]>

  export type SessionReflectionSelectScalar = {
    id?: boolean
    meetingId?: boolean
    menteeId?: boolean
    content?: boolean
    mentorConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionReflectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "meetingId" | "menteeId" | "content" | "mentorConfirmed" | "createdAt" | "updatedAt", ExtArgs["result"]["sessionReflection"]>
  export type SessionReflectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    todoItems?: boolean | SessionReflection$todoItemsArgs<ExtArgs>
    _count?: boolean | SessionReflectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionReflectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionReflectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionReflectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionReflection"
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>
      mentee: Prisma.$UserPayload<ExtArgs>
      todoItems: Prisma.$TodoItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingId: string
      menteeId: string
      content: string | null
      mentorConfirmed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessionReflection"]>
    composites: {}
  }

  type SessionReflectionGetPayload<S extends boolean | null | undefined | SessionReflectionDefaultArgs> = $Result.GetResult<Prisma.$SessionReflectionPayload, S>

  type SessionReflectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionReflectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionReflectionCountAggregateInputType | true
    }

  export interface SessionReflectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionReflection'], meta: { name: 'SessionReflection' } }
    /**
     * Find zero or one SessionReflection that matches the filter.
     * @param {SessionReflectionFindUniqueArgs} args - Arguments to find a SessionReflection
     * @example
     * // Get one SessionReflection
     * const sessionReflection = await prisma.sessionReflection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionReflectionFindUniqueArgs>(args: SelectSubset<T, SessionReflectionFindUniqueArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionReflection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionReflectionFindUniqueOrThrowArgs} args - Arguments to find a SessionReflection
     * @example
     * // Get one SessionReflection
     * const sessionReflection = await prisma.sessionReflection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionReflectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionReflectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionReflection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionReflectionFindFirstArgs} args - Arguments to find a SessionReflection
     * @example
     * // Get one SessionReflection
     * const sessionReflection = await prisma.sessionReflection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionReflectionFindFirstArgs>(args?: SelectSubset<T, SessionReflectionFindFirstArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionReflection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionReflectionFindFirstOrThrowArgs} args - Arguments to find a SessionReflection
     * @example
     * // Get one SessionReflection
     * const sessionReflection = await prisma.sessionReflection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionReflectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionReflectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionReflections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionReflectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionReflections
     * const sessionReflections = await prisma.sessionReflection.findMany()
     * 
     * // Get first 10 SessionReflections
     * const sessionReflections = await prisma.sessionReflection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionReflectionWithIdOnly = await prisma.sessionReflection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionReflectionFindManyArgs>(args?: SelectSubset<T, SessionReflectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionReflection.
     * @param {SessionReflectionCreateArgs} args - Arguments to create a SessionReflection.
     * @example
     * // Create one SessionReflection
     * const SessionReflection = await prisma.sessionReflection.create({
     *   data: {
     *     // ... data to create a SessionReflection
     *   }
     * })
     * 
     */
    create<T extends SessionReflectionCreateArgs>(args: SelectSubset<T, SessionReflectionCreateArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionReflections.
     * @param {SessionReflectionCreateManyArgs} args - Arguments to create many SessionReflections.
     * @example
     * // Create many SessionReflections
     * const sessionReflection = await prisma.sessionReflection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionReflectionCreateManyArgs>(args?: SelectSubset<T, SessionReflectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionReflections and returns the data saved in the database.
     * @param {SessionReflectionCreateManyAndReturnArgs} args - Arguments to create many SessionReflections.
     * @example
     * // Create many SessionReflections
     * const sessionReflection = await prisma.sessionReflection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionReflections and only return the `id`
     * const sessionReflectionWithIdOnly = await prisma.sessionReflection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionReflectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionReflectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionReflection.
     * @param {SessionReflectionDeleteArgs} args - Arguments to delete one SessionReflection.
     * @example
     * // Delete one SessionReflection
     * const SessionReflection = await prisma.sessionReflection.delete({
     *   where: {
     *     // ... filter to delete one SessionReflection
     *   }
     * })
     * 
     */
    delete<T extends SessionReflectionDeleteArgs>(args: SelectSubset<T, SessionReflectionDeleteArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionReflection.
     * @param {SessionReflectionUpdateArgs} args - Arguments to update one SessionReflection.
     * @example
     * // Update one SessionReflection
     * const sessionReflection = await prisma.sessionReflection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionReflectionUpdateArgs>(args: SelectSubset<T, SessionReflectionUpdateArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionReflections.
     * @param {SessionReflectionDeleteManyArgs} args - Arguments to filter SessionReflections to delete.
     * @example
     * // Delete a few SessionReflections
     * const { count } = await prisma.sessionReflection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionReflectionDeleteManyArgs>(args?: SelectSubset<T, SessionReflectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionReflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionReflectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionReflections
     * const sessionReflection = await prisma.sessionReflection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionReflectionUpdateManyArgs>(args: SelectSubset<T, SessionReflectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionReflections and returns the data updated in the database.
     * @param {SessionReflectionUpdateManyAndReturnArgs} args - Arguments to update many SessionReflections.
     * @example
     * // Update many SessionReflections
     * const sessionReflection = await prisma.sessionReflection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionReflections and only return the `id`
     * const sessionReflectionWithIdOnly = await prisma.sessionReflection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionReflectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionReflectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionReflection.
     * @param {SessionReflectionUpsertArgs} args - Arguments to update or create a SessionReflection.
     * @example
     * // Update or create a SessionReflection
     * const sessionReflection = await prisma.sessionReflection.upsert({
     *   create: {
     *     // ... data to create a SessionReflection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionReflection we want to update
     *   }
     * })
     */
    upsert<T extends SessionReflectionUpsertArgs>(args: SelectSubset<T, SessionReflectionUpsertArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionReflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionReflectionCountArgs} args - Arguments to filter SessionReflections to count.
     * @example
     * // Count the number of SessionReflections
     * const count = await prisma.sessionReflection.count({
     *   where: {
     *     // ... the filter for the SessionReflections we want to count
     *   }
     * })
    **/
    count<T extends SessionReflectionCountArgs>(
      args?: Subset<T, SessionReflectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionReflectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionReflection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionReflectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionReflectionAggregateArgs>(args: Subset<T, SessionReflectionAggregateArgs>): Prisma.PrismaPromise<GetSessionReflectionAggregateType<T>>

    /**
     * Group by SessionReflection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionReflectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionReflectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionReflectionGroupByArgs['orderBy'] }
        : { orderBy?: SessionReflectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionReflectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionReflectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionReflection model
   */
  readonly fields: SessionReflectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionReflection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionReflectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingDefaultArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mentee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    todoItems<T extends SessionReflection$todoItemsArgs<ExtArgs> = {}>(args?: Subset<T, SessionReflection$todoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionReflection model
   */
  interface SessionReflectionFieldRefs {
    readonly id: FieldRef<"SessionReflection", 'String'>
    readonly meetingId: FieldRef<"SessionReflection", 'String'>
    readonly menteeId: FieldRef<"SessionReflection", 'String'>
    readonly content: FieldRef<"SessionReflection", 'String'>
    readonly mentorConfirmed: FieldRef<"SessionReflection", 'Boolean'>
    readonly createdAt: FieldRef<"SessionReflection", 'DateTime'>
    readonly updatedAt: FieldRef<"SessionReflection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionReflection findUnique
   */
  export type SessionReflectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * Filter, which SessionReflection to fetch.
     */
    where: SessionReflectionWhereUniqueInput
  }

  /**
   * SessionReflection findUniqueOrThrow
   */
  export type SessionReflectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * Filter, which SessionReflection to fetch.
     */
    where: SessionReflectionWhereUniqueInput
  }

  /**
   * SessionReflection findFirst
   */
  export type SessionReflectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * Filter, which SessionReflection to fetch.
     */
    where?: SessionReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionReflections to fetch.
     */
    orderBy?: SessionReflectionOrderByWithRelationInput | SessionReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionReflections.
     */
    cursor?: SessionReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionReflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionReflections.
     */
    distinct?: SessionReflectionScalarFieldEnum | SessionReflectionScalarFieldEnum[]
  }

  /**
   * SessionReflection findFirstOrThrow
   */
  export type SessionReflectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * Filter, which SessionReflection to fetch.
     */
    where?: SessionReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionReflections to fetch.
     */
    orderBy?: SessionReflectionOrderByWithRelationInput | SessionReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionReflections.
     */
    cursor?: SessionReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionReflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionReflections.
     */
    distinct?: SessionReflectionScalarFieldEnum | SessionReflectionScalarFieldEnum[]
  }

  /**
   * SessionReflection findMany
   */
  export type SessionReflectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * Filter, which SessionReflections to fetch.
     */
    where?: SessionReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionReflections to fetch.
     */
    orderBy?: SessionReflectionOrderByWithRelationInput | SessionReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionReflections.
     */
    cursor?: SessionReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionReflections.
     */
    skip?: number
    distinct?: SessionReflectionScalarFieldEnum | SessionReflectionScalarFieldEnum[]
  }

  /**
   * SessionReflection create
   */
  export type SessionReflectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionReflection.
     */
    data: XOR<SessionReflectionCreateInput, SessionReflectionUncheckedCreateInput>
  }

  /**
   * SessionReflection createMany
   */
  export type SessionReflectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionReflections.
     */
    data: SessionReflectionCreateManyInput | SessionReflectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionReflection createManyAndReturn
   */
  export type SessionReflectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * The data used to create many SessionReflections.
     */
    data: SessionReflectionCreateManyInput | SessionReflectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionReflection update
   */
  export type SessionReflectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionReflection.
     */
    data: XOR<SessionReflectionUpdateInput, SessionReflectionUncheckedUpdateInput>
    /**
     * Choose, which SessionReflection to update.
     */
    where: SessionReflectionWhereUniqueInput
  }

  /**
   * SessionReflection updateMany
   */
  export type SessionReflectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionReflections.
     */
    data: XOR<SessionReflectionUpdateManyMutationInput, SessionReflectionUncheckedUpdateManyInput>
    /**
     * Filter which SessionReflections to update
     */
    where?: SessionReflectionWhereInput
    /**
     * Limit how many SessionReflections to update.
     */
    limit?: number
  }

  /**
   * SessionReflection updateManyAndReturn
   */
  export type SessionReflectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * The data used to update SessionReflections.
     */
    data: XOR<SessionReflectionUpdateManyMutationInput, SessionReflectionUncheckedUpdateManyInput>
    /**
     * Filter which SessionReflections to update
     */
    where?: SessionReflectionWhereInput
    /**
     * Limit how many SessionReflections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionReflection upsert
   */
  export type SessionReflectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionReflection to update in case it exists.
     */
    where: SessionReflectionWhereUniqueInput
    /**
     * In case the SessionReflection found by the `where` argument doesn't exist, create a new SessionReflection with this data.
     */
    create: XOR<SessionReflectionCreateInput, SessionReflectionUncheckedCreateInput>
    /**
     * In case the SessionReflection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionReflectionUpdateInput, SessionReflectionUncheckedUpdateInput>
  }

  /**
   * SessionReflection delete
   */
  export type SessionReflectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    /**
     * Filter which SessionReflection to delete.
     */
    where: SessionReflectionWhereUniqueInput
  }

  /**
   * SessionReflection deleteMany
   */
  export type SessionReflectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionReflections to delete
     */
    where?: SessionReflectionWhereInput
    /**
     * Limit how many SessionReflections to delete.
     */
    limit?: number
  }

  /**
   * SessionReflection.todoItems
   */
  export type SessionReflection$todoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    where?: TodoItemWhereInput
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    cursor?: TodoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * SessionReflection without action
   */
  export type SessionReflectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
  }


  /**
   * Model TodoItem
   */

  export type AggregateTodoItem = {
    _count: TodoItemCountAggregateOutputType | null
    _min: TodoItemMinAggregateOutputType | null
    _max: TodoItemMaxAggregateOutputType | null
  }

  export type TodoItemMinAggregateOutputType = {
    id: string | null
    reflectionId: string | null
    menteeId: string | null
    title: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    startDate: Date | null
    column: string | null
    labels: string | null
    description: string | null
    attachments: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoItemMaxAggregateOutputType = {
    id: string | null
    reflectionId: string | null
    menteeId: string | null
    title: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    startDate: Date | null
    column: string | null
    labels: string | null
    description: string | null
    attachments: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoItemCountAggregateOutputType = {
    id: number
    reflectionId: number
    menteeId: number
    title: number
    status: number
    priority: number
    dueDate: number
    startDate: number
    column: number
    labels: number
    description: number
    attachments: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodoItemMinAggregateInputType = {
    id?: true
    reflectionId?: true
    menteeId?: true
    title?: true
    status?: true
    priority?: true
    dueDate?: true
    startDate?: true
    column?: true
    labels?: true
    description?: true
    attachments?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoItemMaxAggregateInputType = {
    id?: true
    reflectionId?: true
    menteeId?: true
    title?: true
    status?: true
    priority?: true
    dueDate?: true
    startDate?: true
    column?: true
    labels?: true
    description?: true
    attachments?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoItemCountAggregateInputType = {
    id?: true
    reflectionId?: true
    menteeId?: true
    title?: true
    status?: true
    priority?: true
    dueDate?: true
    startDate?: true
    column?: true
    labels?: true
    description?: true
    attachments?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TodoItem to aggregate.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoItems
    **/
    _count?: true | TodoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoItemMaxAggregateInputType
  }

  export type GetTodoItemAggregateType<T extends TodoItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoItem[P]>
      : GetScalarType<T[P], AggregateTodoItem[P]>
  }




  export type TodoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoItemWhereInput
    orderBy?: TodoItemOrderByWithAggregationInput | TodoItemOrderByWithAggregationInput[]
    by: TodoItemScalarFieldEnum[] | TodoItemScalarFieldEnum
    having?: TodoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoItemCountAggregateInputType | true
    _min?: TodoItemMinAggregateInputType
    _max?: TodoItemMaxAggregateInputType
  }

  export type TodoItemGroupByOutputType = {
    id: string
    reflectionId: string | null
    menteeId: string
    title: string
    status: string
    priority: string
    dueDate: Date | null
    startDate: Date | null
    column: string
    labels: string | null
    description: string | null
    attachments: string | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: TodoItemCountAggregateOutputType | null
    _min: TodoItemMinAggregateOutputType | null
    _max: TodoItemMaxAggregateOutputType | null
  }

  type GetTodoItemGroupByPayload<T extends TodoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TodoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoItemGroupByOutputType[P]>
            : GetScalarType<T[P], TodoItemGroupByOutputType[P]>
        }
      >
    >


  export type TodoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reflectionId?: boolean
    menteeId?: boolean
    title?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    startDate?: boolean
    column?: boolean
    labels?: boolean
    description?: boolean
    attachments?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reflection?: boolean | TodoItem$reflectionArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoItem"]>

  export type TodoItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reflectionId?: boolean
    menteeId?: boolean
    title?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    startDate?: boolean
    column?: boolean
    labels?: boolean
    description?: boolean
    attachments?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reflection?: boolean | TodoItem$reflectionArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoItem"]>

  export type TodoItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reflectionId?: boolean
    menteeId?: boolean
    title?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    startDate?: boolean
    column?: boolean
    labels?: boolean
    description?: boolean
    attachments?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reflection?: boolean | TodoItem$reflectionArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoItem"]>

  export type TodoItemSelectScalar = {
    id?: boolean
    reflectionId?: boolean
    menteeId?: boolean
    title?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    startDate?: boolean
    column?: boolean
    labels?: boolean
    description?: boolean
    attachments?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TodoItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reflectionId" | "menteeId" | "title" | "status" | "priority" | "dueDate" | "startDate" | "column" | "labels" | "description" | "attachments" | "comments" | "createdAt" | "updatedAt", ExtArgs["result"]["todoItem"]>
  export type TodoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reflection?: boolean | TodoItem$reflectionArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TodoItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reflection?: boolean | TodoItem$reflectionArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TodoItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reflection?: boolean | TodoItem$reflectionArgs<ExtArgs>
    mentee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TodoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TodoItem"
    objects: {
      reflection: Prisma.$SessionReflectionPayload<ExtArgs> | null
      mentee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reflectionId: string | null
      menteeId: string
      title: string
      status: string
      priority: string
      dueDate: Date | null
      startDate: Date | null
      column: string
      labels: string | null
      description: string | null
      attachments: string | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["todoItem"]>
    composites: {}
  }

  type TodoItemGetPayload<S extends boolean | null | undefined | TodoItemDefaultArgs> = $Result.GetResult<Prisma.$TodoItemPayload, S>

  type TodoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TodoItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TodoItemCountAggregateInputType | true
    }

  export interface TodoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TodoItem'], meta: { name: 'TodoItem' } }
    /**
     * Find zero or one TodoItem that matches the filter.
     * @param {TodoItemFindUniqueArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TodoItemFindUniqueArgs>(args: SelectSubset<T, TodoItemFindUniqueArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TodoItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TodoItemFindUniqueOrThrowArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TodoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TodoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TodoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemFindFirstArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TodoItemFindFirstArgs>(args?: SelectSubset<T, TodoItemFindFirstArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TodoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemFindFirstOrThrowArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TodoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TodoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TodoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoItems
     * const todoItems = await prisma.todoItem.findMany()
     * 
     * // Get first 10 TodoItems
     * const todoItems = await prisma.todoItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoItemWithIdOnly = await prisma.todoItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TodoItemFindManyArgs>(args?: SelectSubset<T, TodoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TodoItem.
     * @param {TodoItemCreateArgs} args - Arguments to create a TodoItem.
     * @example
     * // Create one TodoItem
     * const TodoItem = await prisma.todoItem.create({
     *   data: {
     *     // ... data to create a TodoItem
     *   }
     * })
     * 
     */
    create<T extends TodoItemCreateArgs>(args: SelectSubset<T, TodoItemCreateArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TodoItems.
     * @param {TodoItemCreateManyArgs} args - Arguments to create many TodoItems.
     * @example
     * // Create many TodoItems
     * const todoItem = await prisma.todoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TodoItemCreateManyArgs>(args?: SelectSubset<T, TodoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TodoItems and returns the data saved in the database.
     * @param {TodoItemCreateManyAndReturnArgs} args - Arguments to create many TodoItems.
     * @example
     * // Create many TodoItems
     * const todoItem = await prisma.todoItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TodoItems and only return the `id`
     * const todoItemWithIdOnly = await prisma.todoItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TodoItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TodoItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TodoItem.
     * @param {TodoItemDeleteArgs} args - Arguments to delete one TodoItem.
     * @example
     * // Delete one TodoItem
     * const TodoItem = await prisma.todoItem.delete({
     *   where: {
     *     // ... filter to delete one TodoItem
     *   }
     * })
     * 
     */
    delete<T extends TodoItemDeleteArgs>(args: SelectSubset<T, TodoItemDeleteArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TodoItem.
     * @param {TodoItemUpdateArgs} args - Arguments to update one TodoItem.
     * @example
     * // Update one TodoItem
     * const todoItem = await prisma.todoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TodoItemUpdateArgs>(args: SelectSubset<T, TodoItemUpdateArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TodoItems.
     * @param {TodoItemDeleteManyArgs} args - Arguments to filter TodoItems to delete.
     * @example
     * // Delete a few TodoItems
     * const { count } = await prisma.todoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TodoItemDeleteManyArgs>(args?: SelectSubset<T, TodoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoItems
     * const todoItem = await prisma.todoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TodoItemUpdateManyArgs>(args: SelectSubset<T, TodoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoItems and returns the data updated in the database.
     * @param {TodoItemUpdateManyAndReturnArgs} args - Arguments to update many TodoItems.
     * @example
     * // Update many TodoItems
     * const todoItem = await prisma.todoItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TodoItems and only return the `id`
     * const todoItemWithIdOnly = await prisma.todoItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TodoItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TodoItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TodoItem.
     * @param {TodoItemUpsertArgs} args - Arguments to update or create a TodoItem.
     * @example
     * // Update or create a TodoItem
     * const todoItem = await prisma.todoItem.upsert({
     *   create: {
     *     // ... data to create a TodoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoItem we want to update
     *   }
     * })
     */
    upsert<T extends TodoItemUpsertArgs>(args: SelectSubset<T, TodoItemUpsertArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TodoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemCountArgs} args - Arguments to filter TodoItems to count.
     * @example
     * // Count the number of TodoItems
     * const count = await prisma.todoItem.count({
     *   where: {
     *     // ... the filter for the TodoItems we want to count
     *   }
     * })
    **/
    count<T extends TodoItemCountArgs>(
      args?: Subset<T, TodoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoItemAggregateArgs>(args: Subset<T, TodoItemAggregateArgs>): Prisma.PrismaPromise<GetTodoItemAggregateType<T>>

    /**
     * Group by TodoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoItemGroupByArgs['orderBy'] }
        : { orderBy?: TodoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TodoItem model
   */
  readonly fields: TodoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TodoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reflection<T extends TodoItem$reflectionArgs<ExtArgs> = {}>(args?: Subset<T, TodoItem$reflectionArgs<ExtArgs>>): Prisma__SessionReflectionClient<$Result.GetResult<Prisma.$SessionReflectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mentee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TodoItem model
   */
  interface TodoItemFieldRefs {
    readonly id: FieldRef<"TodoItem", 'String'>
    readonly reflectionId: FieldRef<"TodoItem", 'String'>
    readonly menteeId: FieldRef<"TodoItem", 'String'>
    readonly title: FieldRef<"TodoItem", 'String'>
    readonly status: FieldRef<"TodoItem", 'String'>
    readonly priority: FieldRef<"TodoItem", 'String'>
    readonly dueDate: FieldRef<"TodoItem", 'DateTime'>
    readonly startDate: FieldRef<"TodoItem", 'DateTime'>
    readonly column: FieldRef<"TodoItem", 'String'>
    readonly labels: FieldRef<"TodoItem", 'String'>
    readonly description: FieldRef<"TodoItem", 'String'>
    readonly attachments: FieldRef<"TodoItem", 'String'>
    readonly comments: FieldRef<"TodoItem", 'String'>
    readonly createdAt: FieldRef<"TodoItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TodoItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TodoItem findUnique
   */
  export type TodoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem findUniqueOrThrow
   */
  export type TodoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem findFirst
   */
  export type TodoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoItems.
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoItems.
     */
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * TodoItem findFirstOrThrow
   */
  export type TodoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoItems.
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoItems.
     */
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * TodoItem findMany
   */
  export type TodoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItems to fetch.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoItems.
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * TodoItem create
   */
  export type TodoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TodoItem.
     */
    data: XOR<TodoItemCreateInput, TodoItemUncheckedCreateInput>
  }

  /**
   * TodoItem createMany
   */
  export type TodoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TodoItems.
     */
    data: TodoItemCreateManyInput | TodoItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TodoItem createManyAndReturn
   */
  export type TodoItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * The data used to create many TodoItems.
     */
    data: TodoItemCreateManyInput | TodoItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TodoItem update
   */
  export type TodoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TodoItem.
     */
    data: XOR<TodoItemUpdateInput, TodoItemUncheckedUpdateInput>
    /**
     * Choose, which TodoItem to update.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem updateMany
   */
  export type TodoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TodoItems.
     */
    data: XOR<TodoItemUpdateManyMutationInput, TodoItemUncheckedUpdateManyInput>
    /**
     * Filter which TodoItems to update
     */
    where?: TodoItemWhereInput
    /**
     * Limit how many TodoItems to update.
     */
    limit?: number
  }

  /**
   * TodoItem updateManyAndReturn
   */
  export type TodoItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * The data used to update TodoItems.
     */
    data: XOR<TodoItemUpdateManyMutationInput, TodoItemUncheckedUpdateManyInput>
    /**
     * Filter which TodoItems to update
     */
    where?: TodoItemWhereInput
    /**
     * Limit how many TodoItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TodoItem upsert
   */
  export type TodoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TodoItem to update in case it exists.
     */
    where: TodoItemWhereUniqueInput
    /**
     * In case the TodoItem found by the `where` argument doesn't exist, create a new TodoItem with this data.
     */
    create: XOR<TodoItemCreateInput, TodoItemUncheckedCreateInput>
    /**
     * In case the TodoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoItemUpdateInput, TodoItemUncheckedUpdateInput>
  }

  /**
   * TodoItem delete
   */
  export type TodoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter which TodoItem to delete.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem deleteMany
   */
  export type TodoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TodoItems to delete
     */
    where?: TodoItemWhereInput
    /**
     * Limit how many TodoItems to delete.
     */
    limit?: number
  }

  /**
   * TodoItem.reflection
   */
  export type TodoItem$reflectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionReflection
     */
    select?: SessionReflectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionReflection
     */
    omit?: SessionReflectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionReflectionInclude<ExtArgs> | null
    where?: SessionReflectionWhereInput
  }

  /**
   * TodoItem without action
   */
  export type TodoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityId: string | null
    entityType: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityId: string | null
    entityType: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityId: number
    entityType: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityId?: true
    entityType?: true
    metadata?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityId?: true
    entityType?: true
    metadata?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityId?: true
    entityType?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityId: string | null
    entityType: string | null
    metadata: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityId?: boolean
    entityType?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityId?: boolean
    entityType?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityId?: boolean
    entityType?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityId?: boolean
    entityType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityId" | "entityType" | "metadata" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityId: string | null
      entityType: string | null
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly entityType: FieldRef<"ActivityLog", 'String'>
    readonly metadata: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    userId: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    userId: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    userId: number
    assignedToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    userId?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    userId?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    userId?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    title: string
    description: string
    status: string
    priority: string
    userId: string
    assignedToId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    comments?: boolean | SupportTicket$commentsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "userId" | "assignedToId" | "createdAt" | "updatedAt", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    comments?: boolean | SupportTicket$commentsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$TicketCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: string
      priority: string
      userId: string
      assignedToId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends SupportTicket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends SupportTicket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly title: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly assignedToId: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.assignedTo
   */
  export type SupportTicket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket.comments
   */
  export type SupportTicket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    ticketId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type TicketCommentMinAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: string
    ticketId: string
    userId: string
    content: string
    createdAt: Date
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectScalar = {
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type TicketCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "userId" | "content" | "createdAt", ExtArgs["result"]["ticketComment"]>
  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      userId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketComments and returns the data saved in the database.
     * @param {TicketCommentCreateManyAndReturnArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments and returns the data updated in the database.
     * @param {TicketCommentUpdateManyAndReturnArgs} args - Arguments to update many TicketComments.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'String'>
    readonly ticketId: FieldRef<"TicketComment", 'String'>
    readonly userId: FieldRef<"TicketComment", 'String'>
    readonly content: FieldRef<"TicketComment", 'String'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketComment createManyAndReturn
   */
  export type TicketCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
  }

  /**
   * TicketComment updateManyAndReturn
   */
  export type TicketCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to delete.
     */
    limit?: number
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model WikiPage
   */

  export type AggregateWikiPage = {
    _count: WikiPageCountAggregateOutputType | null
    _min: WikiPageMinAggregateOutputType | null
    _max: WikiPageMaxAggregateOutputType | null
  }

  export type WikiPageMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    category: string | null
    visibility: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WikiPageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    category: string | null
    visibility: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WikiPageCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    category: number
    visibility: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WikiPageMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    visibility?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WikiPageMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    visibility?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WikiPageCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    visibility?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WikiPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WikiPage to aggregate.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WikiPages
    **/
    _count?: true | WikiPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WikiPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WikiPageMaxAggregateInputType
  }

  export type GetWikiPageAggregateType<T extends WikiPageAggregateArgs> = {
        [P in keyof T & keyof AggregateWikiPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWikiPage[P]>
      : GetScalarType<T[P], AggregateWikiPage[P]>
  }




  export type WikiPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WikiPageWhereInput
    orderBy?: WikiPageOrderByWithAggregationInput | WikiPageOrderByWithAggregationInput[]
    by: WikiPageScalarFieldEnum[] | WikiPageScalarFieldEnum
    having?: WikiPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WikiPageCountAggregateInputType | true
    _min?: WikiPageMinAggregateInputType
    _max?: WikiPageMaxAggregateInputType
  }

  export type WikiPageGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string | null
    category: string | null
    visibility: string
    authorId: string
    createdAt: Date
    updatedAt: Date
    _count: WikiPageCountAggregateOutputType | null
    _min: WikiPageMinAggregateOutputType | null
    _max: WikiPageMaxAggregateOutputType | null
  }

  type GetWikiPageGroupByPayload<T extends WikiPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WikiPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WikiPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WikiPageGroupByOutputType[P]>
            : GetScalarType<T[P], WikiPageGroupByOutputType[P]>
        }
      >
    >


  export type WikiPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    visibility?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    visibility?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    visibility?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    visibility?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WikiPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "category" | "visibility" | "authorId" | "createdAt" | "updatedAt", ExtArgs["result"]["wikiPage"]>
  export type WikiPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WikiPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WikiPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WikiPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WikiPage"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string | null
      category: string | null
      visibility: string
      authorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wikiPage"]>
    composites: {}
  }

  type WikiPageGetPayload<S extends boolean | null | undefined | WikiPageDefaultArgs> = $Result.GetResult<Prisma.$WikiPagePayload, S>

  type WikiPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WikiPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WikiPageCountAggregateInputType | true
    }

  export interface WikiPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WikiPage'], meta: { name: 'WikiPage' } }
    /**
     * Find zero or one WikiPage that matches the filter.
     * @param {WikiPageFindUniqueArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WikiPageFindUniqueArgs>(args: SelectSubset<T, WikiPageFindUniqueArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WikiPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WikiPageFindUniqueOrThrowArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WikiPageFindUniqueOrThrowArgs>(args: SelectSubset<T, WikiPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WikiPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindFirstArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WikiPageFindFirstArgs>(args?: SelectSubset<T, WikiPageFindFirstArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WikiPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindFirstOrThrowArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WikiPageFindFirstOrThrowArgs>(args?: SelectSubset<T, WikiPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WikiPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WikiPages
     * const wikiPages = await prisma.wikiPage.findMany()
     * 
     * // Get first 10 WikiPages
     * const wikiPages = await prisma.wikiPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WikiPageFindManyArgs>(args?: SelectSubset<T, WikiPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WikiPage.
     * @param {WikiPageCreateArgs} args - Arguments to create a WikiPage.
     * @example
     * // Create one WikiPage
     * const WikiPage = await prisma.wikiPage.create({
     *   data: {
     *     // ... data to create a WikiPage
     *   }
     * })
     * 
     */
    create<T extends WikiPageCreateArgs>(args: SelectSubset<T, WikiPageCreateArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WikiPages.
     * @param {WikiPageCreateManyArgs} args - Arguments to create many WikiPages.
     * @example
     * // Create many WikiPages
     * const wikiPage = await prisma.wikiPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WikiPageCreateManyArgs>(args?: SelectSubset<T, WikiPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WikiPages and returns the data saved in the database.
     * @param {WikiPageCreateManyAndReturnArgs} args - Arguments to create many WikiPages.
     * @example
     * // Create many WikiPages
     * const wikiPage = await prisma.wikiPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WikiPages and only return the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WikiPageCreateManyAndReturnArgs>(args?: SelectSubset<T, WikiPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WikiPage.
     * @param {WikiPageDeleteArgs} args - Arguments to delete one WikiPage.
     * @example
     * // Delete one WikiPage
     * const WikiPage = await prisma.wikiPage.delete({
     *   where: {
     *     // ... filter to delete one WikiPage
     *   }
     * })
     * 
     */
    delete<T extends WikiPageDeleteArgs>(args: SelectSubset<T, WikiPageDeleteArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WikiPage.
     * @param {WikiPageUpdateArgs} args - Arguments to update one WikiPage.
     * @example
     * // Update one WikiPage
     * const wikiPage = await prisma.wikiPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WikiPageUpdateArgs>(args: SelectSubset<T, WikiPageUpdateArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WikiPages.
     * @param {WikiPageDeleteManyArgs} args - Arguments to filter WikiPages to delete.
     * @example
     * // Delete a few WikiPages
     * const { count } = await prisma.wikiPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WikiPageDeleteManyArgs>(args?: SelectSubset<T, WikiPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WikiPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WikiPages
     * const wikiPage = await prisma.wikiPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WikiPageUpdateManyArgs>(args: SelectSubset<T, WikiPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WikiPages and returns the data updated in the database.
     * @param {WikiPageUpdateManyAndReturnArgs} args - Arguments to update many WikiPages.
     * @example
     * // Update many WikiPages
     * const wikiPage = await prisma.wikiPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WikiPages and only return the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WikiPageUpdateManyAndReturnArgs>(args: SelectSubset<T, WikiPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WikiPage.
     * @param {WikiPageUpsertArgs} args - Arguments to update or create a WikiPage.
     * @example
     * // Update or create a WikiPage
     * const wikiPage = await prisma.wikiPage.upsert({
     *   create: {
     *     // ... data to create a WikiPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WikiPage we want to update
     *   }
     * })
     */
    upsert<T extends WikiPageUpsertArgs>(args: SelectSubset<T, WikiPageUpsertArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WikiPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageCountArgs} args - Arguments to filter WikiPages to count.
     * @example
     * // Count the number of WikiPages
     * const count = await prisma.wikiPage.count({
     *   where: {
     *     // ... the filter for the WikiPages we want to count
     *   }
     * })
    **/
    count<T extends WikiPageCountArgs>(
      args?: Subset<T, WikiPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WikiPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WikiPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WikiPageAggregateArgs>(args: Subset<T, WikiPageAggregateArgs>): Prisma.PrismaPromise<GetWikiPageAggregateType<T>>

    /**
     * Group by WikiPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WikiPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WikiPageGroupByArgs['orderBy'] }
        : { orderBy?: WikiPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WikiPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWikiPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WikiPage model
   */
  readonly fields: WikiPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WikiPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WikiPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WikiPage model
   */
  interface WikiPageFieldRefs {
    readonly id: FieldRef<"WikiPage", 'String'>
    readonly title: FieldRef<"WikiPage", 'String'>
    readonly slug: FieldRef<"WikiPage", 'String'>
    readonly content: FieldRef<"WikiPage", 'String'>
    readonly category: FieldRef<"WikiPage", 'String'>
    readonly visibility: FieldRef<"WikiPage", 'String'>
    readonly authorId: FieldRef<"WikiPage", 'String'>
    readonly createdAt: FieldRef<"WikiPage", 'DateTime'>
    readonly updatedAt: FieldRef<"WikiPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WikiPage findUnique
   */
  export type WikiPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage findUniqueOrThrow
   */
  export type WikiPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage findFirst
   */
  export type WikiPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WikiPages.
     */
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage findFirstOrThrow
   */
  export type WikiPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WikiPages.
     */
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage findMany
   */
  export type WikiPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPages to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage create
   */
  export type WikiPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * The data needed to create a WikiPage.
     */
    data: XOR<WikiPageCreateInput, WikiPageUncheckedCreateInput>
  }

  /**
   * WikiPage createMany
   */
  export type WikiPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WikiPages.
     */
    data: WikiPageCreateManyInput | WikiPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WikiPage createManyAndReturn
   */
  export type WikiPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data used to create many WikiPages.
     */
    data: WikiPageCreateManyInput | WikiPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WikiPage update
   */
  export type WikiPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * The data needed to update a WikiPage.
     */
    data: XOR<WikiPageUpdateInput, WikiPageUncheckedUpdateInput>
    /**
     * Choose, which WikiPage to update.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage updateMany
   */
  export type WikiPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WikiPages.
     */
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyInput>
    /**
     * Filter which WikiPages to update
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to update.
     */
    limit?: number
  }

  /**
   * WikiPage updateManyAndReturn
   */
  export type WikiPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data used to update WikiPages.
     */
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyInput>
    /**
     * Filter which WikiPages to update
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WikiPage upsert
   */
  export type WikiPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * The filter to search for the WikiPage to update in case it exists.
     */
    where: WikiPageWhereUniqueInput
    /**
     * In case the WikiPage found by the `where` argument doesn't exist, create a new WikiPage with this data.
     */
    create: XOR<WikiPageCreateInput, WikiPageUncheckedCreateInput>
    /**
     * In case the WikiPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WikiPageUpdateInput, WikiPageUncheckedUpdateInput>
  }

  /**
   * WikiPage delete
   */
  export type WikiPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter which WikiPage to delete.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage deleteMany
   */
  export type WikiPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WikiPages to delete
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to delete.
     */
    limit?: number
  }

  /**
   * WikiPage without action
   */
  export type WikiPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
  }


  /**
   * Model Whiteboard
   */

  export type AggregateWhiteboard = {
    _count: WhiteboardCountAggregateOutputType | null
    _min: WhiteboardMinAggregateOutputType | null
    _max: WhiteboardMaxAggregateOutputType | null
  }

  export type WhiteboardMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    status: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhiteboardMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    status: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhiteboardCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnail: number
    status: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhiteboardMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhiteboardMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhiteboardCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhiteboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whiteboard to aggregate.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Whiteboards
    **/
    _count?: true | WhiteboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhiteboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhiteboardMaxAggregateInputType
  }

  export type GetWhiteboardAggregateType<T extends WhiteboardAggregateArgs> = {
        [P in keyof T & keyof AggregateWhiteboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhiteboard[P]>
      : GetScalarType<T[P], AggregateWhiteboard[P]>
  }




  export type WhiteboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhiteboardWhereInput
    orderBy?: WhiteboardOrderByWithAggregationInput | WhiteboardOrderByWithAggregationInput[]
    by: WhiteboardScalarFieldEnum[] | WhiteboardScalarFieldEnum
    having?: WhiteboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhiteboardCountAggregateInputType | true
    _min?: WhiteboardMinAggregateInputType
    _max?: WhiteboardMaxAggregateInputType
  }

  export type WhiteboardGroupByOutputType = {
    id: string
    title: string
    description: string | null
    thumbnail: string | null
    status: string
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: WhiteboardCountAggregateOutputType | null
    _min: WhiteboardMinAggregateOutputType | null
    _max: WhiteboardMaxAggregateOutputType | null
  }

  type GetWhiteboardGroupByPayload<T extends WhiteboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhiteboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhiteboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhiteboardGroupByOutputType[P]>
            : GetScalarType<T[P], WhiteboardGroupByOutputType[P]>
        }
      >
    >


  export type WhiteboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    artboards?: boolean | Whiteboard$artboardsArgs<ExtArgs>
    _count?: boolean | WhiteboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhiteboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnail" | "status" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["whiteboard"]>
  export type WhiteboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    artboards?: boolean | Whiteboard$artboardsArgs<ExtArgs>
    _count?: boolean | WhiteboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhiteboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhiteboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhiteboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Whiteboard"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      artboards: Prisma.$ArtboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      thumbnail: string | null
      status: string
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whiteboard"]>
    composites: {}
  }

  type WhiteboardGetPayload<S extends boolean | null | undefined | WhiteboardDefaultArgs> = $Result.GetResult<Prisma.$WhiteboardPayload, S>

  type WhiteboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhiteboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhiteboardCountAggregateInputType | true
    }

  export interface WhiteboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Whiteboard'], meta: { name: 'Whiteboard' } }
    /**
     * Find zero or one Whiteboard that matches the filter.
     * @param {WhiteboardFindUniqueArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhiteboardFindUniqueArgs>(args: SelectSubset<T, WhiteboardFindUniqueArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Whiteboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhiteboardFindUniqueOrThrowArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhiteboardFindUniqueOrThrowArgs>(args: SelectSubset<T, WhiteboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Whiteboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindFirstArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhiteboardFindFirstArgs>(args?: SelectSubset<T, WhiteboardFindFirstArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Whiteboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindFirstOrThrowArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhiteboardFindFirstOrThrowArgs>(args?: SelectSubset<T, WhiteboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Whiteboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whiteboards
     * const whiteboards = await prisma.whiteboard.findMany()
     * 
     * // Get first 10 Whiteboards
     * const whiteboards = await prisma.whiteboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhiteboardFindManyArgs>(args?: SelectSubset<T, WhiteboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Whiteboard.
     * @param {WhiteboardCreateArgs} args - Arguments to create a Whiteboard.
     * @example
     * // Create one Whiteboard
     * const Whiteboard = await prisma.whiteboard.create({
     *   data: {
     *     // ... data to create a Whiteboard
     *   }
     * })
     * 
     */
    create<T extends WhiteboardCreateArgs>(args: SelectSubset<T, WhiteboardCreateArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Whiteboards.
     * @param {WhiteboardCreateManyArgs} args - Arguments to create many Whiteboards.
     * @example
     * // Create many Whiteboards
     * const whiteboard = await prisma.whiteboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhiteboardCreateManyArgs>(args?: SelectSubset<T, WhiteboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whiteboards and returns the data saved in the database.
     * @param {WhiteboardCreateManyAndReturnArgs} args - Arguments to create many Whiteboards.
     * @example
     * // Create many Whiteboards
     * const whiteboard = await prisma.whiteboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whiteboards and only return the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhiteboardCreateManyAndReturnArgs>(args?: SelectSubset<T, WhiteboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Whiteboard.
     * @param {WhiteboardDeleteArgs} args - Arguments to delete one Whiteboard.
     * @example
     * // Delete one Whiteboard
     * const Whiteboard = await prisma.whiteboard.delete({
     *   where: {
     *     // ... filter to delete one Whiteboard
     *   }
     * })
     * 
     */
    delete<T extends WhiteboardDeleteArgs>(args: SelectSubset<T, WhiteboardDeleteArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Whiteboard.
     * @param {WhiteboardUpdateArgs} args - Arguments to update one Whiteboard.
     * @example
     * // Update one Whiteboard
     * const whiteboard = await prisma.whiteboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhiteboardUpdateArgs>(args: SelectSubset<T, WhiteboardUpdateArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Whiteboards.
     * @param {WhiteboardDeleteManyArgs} args - Arguments to filter Whiteboards to delete.
     * @example
     * // Delete a few Whiteboards
     * const { count } = await prisma.whiteboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhiteboardDeleteManyArgs>(args?: SelectSubset<T, WhiteboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whiteboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whiteboards
     * const whiteboard = await prisma.whiteboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhiteboardUpdateManyArgs>(args: SelectSubset<T, WhiteboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whiteboards and returns the data updated in the database.
     * @param {WhiteboardUpdateManyAndReturnArgs} args - Arguments to update many Whiteboards.
     * @example
     * // Update many Whiteboards
     * const whiteboard = await prisma.whiteboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whiteboards and only return the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhiteboardUpdateManyAndReturnArgs>(args: SelectSubset<T, WhiteboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Whiteboard.
     * @param {WhiteboardUpsertArgs} args - Arguments to update or create a Whiteboard.
     * @example
     * // Update or create a Whiteboard
     * const whiteboard = await prisma.whiteboard.upsert({
     *   create: {
     *     // ... data to create a Whiteboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whiteboard we want to update
     *   }
     * })
     */
    upsert<T extends WhiteboardUpsertArgs>(args: SelectSubset<T, WhiteboardUpsertArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Whiteboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardCountArgs} args - Arguments to filter Whiteboards to count.
     * @example
     * // Count the number of Whiteboards
     * const count = await prisma.whiteboard.count({
     *   where: {
     *     // ... the filter for the Whiteboards we want to count
     *   }
     * })
    **/
    count<T extends WhiteboardCountArgs>(
      args?: Subset<T, WhiteboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhiteboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whiteboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhiteboardAggregateArgs>(args: Subset<T, WhiteboardAggregateArgs>): Prisma.PrismaPromise<GetWhiteboardAggregateType<T>>

    /**
     * Group by Whiteboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhiteboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhiteboardGroupByArgs['orderBy'] }
        : { orderBy?: WhiteboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhiteboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhiteboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Whiteboard model
   */
  readonly fields: WhiteboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Whiteboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhiteboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artboards<T extends Whiteboard$artboardsArgs<ExtArgs> = {}>(args?: Subset<T, Whiteboard$artboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Whiteboard model
   */
  interface WhiteboardFieldRefs {
    readonly id: FieldRef<"Whiteboard", 'String'>
    readonly title: FieldRef<"Whiteboard", 'String'>
    readonly description: FieldRef<"Whiteboard", 'String'>
    readonly thumbnail: FieldRef<"Whiteboard", 'String'>
    readonly status: FieldRef<"Whiteboard", 'String'>
    readonly creatorId: FieldRef<"Whiteboard", 'String'>
    readonly createdAt: FieldRef<"Whiteboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Whiteboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Whiteboard findUnique
   */
  export type WhiteboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard findUniqueOrThrow
   */
  export type WhiteboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard findFirst
   */
  export type WhiteboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whiteboards.
     */
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard findFirstOrThrow
   */
  export type WhiteboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whiteboards.
     */
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard findMany
   */
  export type WhiteboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboards to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard create
   */
  export type WhiteboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Whiteboard.
     */
    data: XOR<WhiteboardCreateInput, WhiteboardUncheckedCreateInput>
  }

  /**
   * Whiteboard createMany
   */
  export type WhiteboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Whiteboards.
     */
    data: WhiteboardCreateManyInput | WhiteboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Whiteboard createManyAndReturn
   */
  export type WhiteboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * The data used to create many Whiteboards.
     */
    data: WhiteboardCreateManyInput | WhiteboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Whiteboard update
   */
  export type WhiteboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Whiteboard.
     */
    data: XOR<WhiteboardUpdateInput, WhiteboardUncheckedUpdateInput>
    /**
     * Choose, which Whiteboard to update.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard updateMany
   */
  export type WhiteboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Whiteboards.
     */
    data: XOR<WhiteboardUpdateManyMutationInput, WhiteboardUncheckedUpdateManyInput>
    /**
     * Filter which Whiteboards to update
     */
    where?: WhiteboardWhereInput
    /**
     * Limit how many Whiteboards to update.
     */
    limit?: number
  }

  /**
   * Whiteboard updateManyAndReturn
   */
  export type WhiteboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * The data used to update Whiteboards.
     */
    data: XOR<WhiteboardUpdateManyMutationInput, WhiteboardUncheckedUpdateManyInput>
    /**
     * Filter which Whiteboards to update
     */
    where?: WhiteboardWhereInput
    /**
     * Limit how many Whiteboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Whiteboard upsert
   */
  export type WhiteboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Whiteboard to update in case it exists.
     */
    where: WhiteboardWhereUniqueInput
    /**
     * In case the Whiteboard found by the `where` argument doesn't exist, create a new Whiteboard with this data.
     */
    create: XOR<WhiteboardCreateInput, WhiteboardUncheckedCreateInput>
    /**
     * In case the Whiteboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhiteboardUpdateInput, WhiteboardUncheckedUpdateInput>
  }

  /**
   * Whiteboard delete
   */
  export type WhiteboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter which Whiteboard to delete.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard deleteMany
   */
  export type WhiteboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whiteboards to delete
     */
    where?: WhiteboardWhereInput
    /**
     * Limit how many Whiteboards to delete.
     */
    limit?: number
  }

  /**
   * Whiteboard.artboards
   */
  export type Whiteboard$artboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    where?: ArtboardWhereInput
    orderBy?: ArtboardOrderByWithRelationInput | ArtboardOrderByWithRelationInput[]
    cursor?: ArtboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtboardScalarFieldEnum | ArtboardScalarFieldEnum[]
  }

  /**
   * Whiteboard without action
   */
  export type WhiteboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
  }


  /**
   * Model Artboard
   */

  export type AggregateArtboard = {
    _count: ArtboardCountAggregateOutputType | null
    _avg: ArtboardAvgAggregateOutputType | null
    _sum: ArtboardSumAggregateOutputType | null
    _min: ArtboardMinAggregateOutputType | null
    _max: ArtboardMaxAggregateOutputType | null
  }

  export type ArtboardAvgAggregateOutputType = {
    order: number | null
  }

  export type ArtboardSumAggregateOutputType = {
    order: number | null
  }

  export type ArtboardMinAggregateOutputType = {
    id: string | null
    whiteboardId: string | null
    order: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtboardMaxAggregateOutputType = {
    id: string | null
    whiteboardId: string | null
    order: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtboardCountAggregateOutputType = {
    id: number
    whiteboardId: number
    order: number
    name: number
    elements: number
    appState: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArtboardAvgAggregateInputType = {
    order?: true
  }

  export type ArtboardSumAggregateInputType = {
    order?: true
  }

  export type ArtboardMinAggregateInputType = {
    id?: true
    whiteboardId?: true
    order?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtboardMaxAggregateInputType = {
    id?: true
    whiteboardId?: true
    order?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtboardCountAggregateInputType = {
    id?: true
    whiteboardId?: true
    order?: true
    name?: true
    elements?: true
    appState?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArtboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artboard to aggregate.
     */
    where?: ArtboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artboards to fetch.
     */
    orderBy?: ArtboardOrderByWithRelationInput | ArtboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artboards
    **/
    _count?: true | ArtboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtboardMaxAggregateInputType
  }

  export type GetArtboardAggregateType<T extends ArtboardAggregateArgs> = {
        [P in keyof T & keyof AggregateArtboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtboard[P]>
      : GetScalarType<T[P], AggregateArtboard[P]>
  }




  export type ArtboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtboardWhereInput
    orderBy?: ArtboardOrderByWithAggregationInput | ArtboardOrderByWithAggregationInput[]
    by: ArtboardScalarFieldEnum[] | ArtboardScalarFieldEnum
    having?: ArtboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtboardCountAggregateInputType | true
    _avg?: ArtboardAvgAggregateInputType
    _sum?: ArtboardSumAggregateInputType
    _min?: ArtboardMinAggregateInputType
    _max?: ArtboardMaxAggregateInputType
  }

  export type ArtboardGroupByOutputType = {
    id: string
    whiteboardId: string
    order: number
    name: string | null
    elements: JsonValue | null
    appState: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ArtboardCountAggregateOutputType | null
    _avg: ArtboardAvgAggregateOutputType | null
    _sum: ArtboardSumAggregateOutputType | null
    _min: ArtboardMinAggregateOutputType | null
    _max: ArtboardMaxAggregateOutputType | null
  }

  type GetArtboardGroupByPayload<T extends ArtboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtboardGroupByOutputType[P]>
            : GetScalarType<T[P], ArtboardGroupByOutputType[P]>
        }
      >
    >


  export type ArtboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whiteboardId?: boolean
    order?: boolean
    name?: boolean
    elements?: boolean
    appState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artboard"]>

  export type ArtboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whiteboardId?: boolean
    order?: boolean
    name?: boolean
    elements?: boolean
    appState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artboard"]>

  export type ArtboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whiteboardId?: boolean
    order?: boolean
    name?: boolean
    elements?: boolean
    appState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artboard"]>

  export type ArtboardSelectScalar = {
    id?: boolean
    whiteboardId?: boolean
    order?: boolean
    name?: boolean
    elements?: boolean
    appState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArtboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "whiteboardId" | "order" | "name" | "elements" | "appState" | "createdAt" | "updatedAt", ExtArgs["result"]["artboard"]>
  export type ArtboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }
  export type ArtboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }
  export type ArtboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }

  export type $ArtboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artboard"
    objects: {
      whiteboard: Prisma.$WhiteboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      whiteboardId: string
      order: number
      name: string | null
      elements: Prisma.JsonValue | null
      appState: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["artboard"]>
    composites: {}
  }

  type ArtboardGetPayload<S extends boolean | null | undefined | ArtboardDefaultArgs> = $Result.GetResult<Prisma.$ArtboardPayload, S>

  type ArtboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtboardCountAggregateInputType | true
    }

  export interface ArtboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artboard'], meta: { name: 'Artboard' } }
    /**
     * Find zero or one Artboard that matches the filter.
     * @param {ArtboardFindUniqueArgs} args - Arguments to find a Artboard
     * @example
     * // Get one Artboard
     * const artboard = await prisma.artboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtboardFindUniqueArgs>(args: SelectSubset<T, ArtboardFindUniqueArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtboardFindUniqueOrThrowArgs} args - Arguments to find a Artboard
     * @example
     * // Get one Artboard
     * const artboard = await prisma.artboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtboardFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtboardFindFirstArgs} args - Arguments to find a Artboard
     * @example
     * // Get one Artboard
     * const artboard = await prisma.artboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtboardFindFirstArgs>(args?: SelectSubset<T, ArtboardFindFirstArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtboardFindFirstOrThrowArgs} args - Arguments to find a Artboard
     * @example
     * // Get one Artboard
     * const artboard = await prisma.artboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtboardFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artboards
     * const artboards = await prisma.artboard.findMany()
     * 
     * // Get first 10 Artboards
     * const artboards = await prisma.artboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artboardWithIdOnly = await prisma.artboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtboardFindManyArgs>(args?: SelectSubset<T, ArtboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artboard.
     * @param {ArtboardCreateArgs} args - Arguments to create a Artboard.
     * @example
     * // Create one Artboard
     * const Artboard = await prisma.artboard.create({
     *   data: {
     *     // ... data to create a Artboard
     *   }
     * })
     * 
     */
    create<T extends ArtboardCreateArgs>(args: SelectSubset<T, ArtboardCreateArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artboards.
     * @param {ArtboardCreateManyArgs} args - Arguments to create many Artboards.
     * @example
     * // Create many Artboards
     * const artboard = await prisma.artboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtboardCreateManyArgs>(args?: SelectSubset<T, ArtboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artboards and returns the data saved in the database.
     * @param {ArtboardCreateManyAndReturnArgs} args - Arguments to create many Artboards.
     * @example
     * // Create many Artboards
     * const artboard = await prisma.artboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artboards and only return the `id`
     * const artboardWithIdOnly = await prisma.artboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtboardCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artboard.
     * @param {ArtboardDeleteArgs} args - Arguments to delete one Artboard.
     * @example
     * // Delete one Artboard
     * const Artboard = await prisma.artboard.delete({
     *   where: {
     *     // ... filter to delete one Artboard
     *   }
     * })
     * 
     */
    delete<T extends ArtboardDeleteArgs>(args: SelectSubset<T, ArtboardDeleteArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artboard.
     * @param {ArtboardUpdateArgs} args - Arguments to update one Artboard.
     * @example
     * // Update one Artboard
     * const artboard = await prisma.artboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtboardUpdateArgs>(args: SelectSubset<T, ArtboardUpdateArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artboards.
     * @param {ArtboardDeleteManyArgs} args - Arguments to filter Artboards to delete.
     * @example
     * // Delete a few Artboards
     * const { count } = await prisma.artboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtboardDeleteManyArgs>(args?: SelectSubset<T, ArtboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artboards
     * const artboard = await prisma.artboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtboardUpdateManyArgs>(args: SelectSubset<T, ArtboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artboards and returns the data updated in the database.
     * @param {ArtboardUpdateManyAndReturnArgs} args - Arguments to update many Artboards.
     * @example
     * // Update many Artboards
     * const artboard = await prisma.artboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artboards and only return the `id`
     * const artboardWithIdOnly = await prisma.artboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtboardUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artboard.
     * @param {ArtboardUpsertArgs} args - Arguments to update or create a Artboard.
     * @example
     * // Update or create a Artboard
     * const artboard = await prisma.artboard.upsert({
     *   create: {
     *     // ... data to create a Artboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artboard we want to update
     *   }
     * })
     */
    upsert<T extends ArtboardUpsertArgs>(args: SelectSubset<T, ArtboardUpsertArgs<ExtArgs>>): Prisma__ArtboardClient<$Result.GetResult<Prisma.$ArtboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtboardCountArgs} args - Arguments to filter Artboards to count.
     * @example
     * // Count the number of Artboards
     * const count = await prisma.artboard.count({
     *   where: {
     *     // ... the filter for the Artboards we want to count
     *   }
     * })
    **/
    count<T extends ArtboardCountArgs>(
      args?: Subset<T, ArtboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtboardAggregateArgs>(args: Subset<T, ArtboardAggregateArgs>): Prisma.PrismaPromise<GetArtboardAggregateType<T>>

    /**
     * Group by Artboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtboardGroupByArgs['orderBy'] }
        : { orderBy?: ArtboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artboard model
   */
  readonly fields: ArtboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whiteboard<T extends WhiteboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhiteboardDefaultArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artboard model
   */
  interface ArtboardFieldRefs {
    readonly id: FieldRef<"Artboard", 'String'>
    readonly whiteboardId: FieldRef<"Artboard", 'String'>
    readonly order: FieldRef<"Artboard", 'Int'>
    readonly name: FieldRef<"Artboard", 'String'>
    readonly elements: FieldRef<"Artboard", 'Json'>
    readonly appState: FieldRef<"Artboard", 'Json'>
    readonly createdAt: FieldRef<"Artboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Artboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Artboard findUnique
   */
  export type ArtboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * Filter, which Artboard to fetch.
     */
    where: ArtboardWhereUniqueInput
  }

  /**
   * Artboard findUniqueOrThrow
   */
  export type ArtboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * Filter, which Artboard to fetch.
     */
    where: ArtboardWhereUniqueInput
  }

  /**
   * Artboard findFirst
   */
  export type ArtboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * Filter, which Artboard to fetch.
     */
    where?: ArtboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artboards to fetch.
     */
    orderBy?: ArtboardOrderByWithRelationInput | ArtboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artboards.
     */
    cursor?: ArtboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artboards.
     */
    distinct?: ArtboardScalarFieldEnum | ArtboardScalarFieldEnum[]
  }

  /**
   * Artboard findFirstOrThrow
   */
  export type ArtboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * Filter, which Artboard to fetch.
     */
    where?: ArtboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artboards to fetch.
     */
    orderBy?: ArtboardOrderByWithRelationInput | ArtboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artboards.
     */
    cursor?: ArtboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artboards.
     */
    distinct?: ArtboardScalarFieldEnum | ArtboardScalarFieldEnum[]
  }

  /**
   * Artboard findMany
   */
  export type ArtboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * Filter, which Artboards to fetch.
     */
    where?: ArtboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artboards to fetch.
     */
    orderBy?: ArtboardOrderByWithRelationInput | ArtboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artboards.
     */
    cursor?: ArtboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artboards.
     */
    skip?: number
    distinct?: ArtboardScalarFieldEnum | ArtboardScalarFieldEnum[]
  }

  /**
   * Artboard create
   */
  export type ArtboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Artboard.
     */
    data: XOR<ArtboardCreateInput, ArtboardUncheckedCreateInput>
  }

  /**
   * Artboard createMany
   */
  export type ArtboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artboards.
     */
    data: ArtboardCreateManyInput | ArtboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artboard createManyAndReturn
   */
  export type ArtboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * The data used to create many Artboards.
     */
    data: ArtboardCreateManyInput | ArtboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artboard update
   */
  export type ArtboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Artboard.
     */
    data: XOR<ArtboardUpdateInput, ArtboardUncheckedUpdateInput>
    /**
     * Choose, which Artboard to update.
     */
    where: ArtboardWhereUniqueInput
  }

  /**
   * Artboard updateMany
   */
  export type ArtboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artboards.
     */
    data: XOR<ArtboardUpdateManyMutationInput, ArtboardUncheckedUpdateManyInput>
    /**
     * Filter which Artboards to update
     */
    where?: ArtboardWhereInput
    /**
     * Limit how many Artboards to update.
     */
    limit?: number
  }

  /**
   * Artboard updateManyAndReturn
   */
  export type ArtboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * The data used to update Artboards.
     */
    data: XOR<ArtboardUpdateManyMutationInput, ArtboardUncheckedUpdateManyInput>
    /**
     * Filter which Artboards to update
     */
    where?: ArtboardWhereInput
    /**
     * Limit how many Artboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artboard upsert
   */
  export type ArtboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Artboard to update in case it exists.
     */
    where: ArtboardWhereUniqueInput
    /**
     * In case the Artboard found by the `where` argument doesn't exist, create a new Artboard with this data.
     */
    create: XOR<ArtboardCreateInput, ArtboardUncheckedCreateInput>
    /**
     * In case the Artboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtboardUpdateInput, ArtboardUncheckedUpdateInput>
  }

  /**
   * Artboard delete
   */
  export type ArtboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
    /**
     * Filter which Artboard to delete.
     */
    where: ArtboardWhereUniqueInput
  }

  /**
   * Artboard deleteMany
   */
  export type ArtboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artboards to delete
     */
    where?: ArtboardWhereInput
    /**
     * Limit how many Artboards to delete.
     */
    limit?: number
  }

  /**
   * Artboard without action
   */
  export type ArtboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artboard
     */
    select?: ArtboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artboard
     */
    omit?: ArtboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtboardInclude<ExtArgs> | null
  }


  /**
   * Model Slide
   */

  export type AggregateSlide = {
    _count: SlideCountAggregateOutputType | null
    _min: SlideMinAggregateOutputType | null
    _max: SlideMaxAggregateOutputType | null
  }

  export type SlideMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    theme: string | null
    status: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlideMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    theme: string | null
    status: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlideCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    theme: number
    status: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SlideMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    theme?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlideMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    theme?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlideCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    theme?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Slide to aggregate.
     */
    where?: SlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slides to fetch.
     */
    orderBy?: SlideOrderByWithRelationInput | SlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Slides
    **/
    _count?: true | SlideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlideMaxAggregateInputType
  }

  export type GetSlideAggregateType<T extends SlideAggregateArgs> = {
        [P in keyof T & keyof AggregateSlide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlide[P]>
      : GetScalarType<T[P], AggregateSlide[P]>
  }




  export type SlideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlideWhereInput
    orderBy?: SlideOrderByWithAggregationInput | SlideOrderByWithAggregationInput[]
    by: SlideScalarFieldEnum[] | SlideScalarFieldEnum
    having?: SlideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlideCountAggregateInputType | true
    _min?: SlideMinAggregateInputType
    _max?: SlideMaxAggregateInputType
  }

  export type SlideGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: string | null
    theme: string
    status: string
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: SlideCountAggregateOutputType | null
    _min: SlideMinAggregateOutputType | null
    _max: SlideMaxAggregateOutputType | null
  }

  type GetSlideGroupByPayload<T extends SlideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlideGroupByOutputType[P]>
            : GetScalarType<T[P], SlideGroupByOutputType[P]>
        }
      >
    >


  export type SlideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    theme?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slide"]>

  export type SlideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    theme?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slide"]>

  export type SlideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    theme?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slide"]>

  export type SlideSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    theme?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SlideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "theme" | "status" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["slide"]>
  export type SlideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SlideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SlideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SlidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Slide"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: string | null
      theme: string
      status: string
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["slide"]>
    composites: {}
  }

  type SlideGetPayload<S extends boolean | null | undefined | SlideDefaultArgs> = $Result.GetResult<Prisma.$SlidePayload, S>

  type SlideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SlideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlideCountAggregateInputType | true
    }

  export interface SlideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Slide'], meta: { name: 'Slide' } }
    /**
     * Find zero or one Slide that matches the filter.
     * @param {SlideFindUniqueArgs} args - Arguments to find a Slide
     * @example
     * // Get one Slide
     * const slide = await prisma.slide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlideFindUniqueArgs>(args: SelectSubset<T, SlideFindUniqueArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Slide that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlideFindUniqueOrThrowArgs} args - Arguments to find a Slide
     * @example
     * // Get one Slide
     * const slide = await prisma.slide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlideFindUniqueOrThrowArgs>(args: SelectSubset<T, SlideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlideFindFirstArgs} args - Arguments to find a Slide
     * @example
     * // Get one Slide
     * const slide = await prisma.slide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlideFindFirstArgs>(args?: SelectSubset<T, SlideFindFirstArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlideFindFirstOrThrowArgs} args - Arguments to find a Slide
     * @example
     * // Get one Slide
     * const slide = await prisma.slide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlideFindFirstOrThrowArgs>(args?: SelectSubset<T, SlideFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Slides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slides
     * const slides = await prisma.slide.findMany()
     * 
     * // Get first 10 Slides
     * const slides = await prisma.slide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slideWithIdOnly = await prisma.slide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlideFindManyArgs>(args?: SelectSubset<T, SlideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Slide.
     * @param {SlideCreateArgs} args - Arguments to create a Slide.
     * @example
     * // Create one Slide
     * const Slide = await prisma.slide.create({
     *   data: {
     *     // ... data to create a Slide
     *   }
     * })
     * 
     */
    create<T extends SlideCreateArgs>(args: SelectSubset<T, SlideCreateArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Slides.
     * @param {SlideCreateManyArgs} args - Arguments to create many Slides.
     * @example
     * // Create many Slides
     * const slide = await prisma.slide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlideCreateManyArgs>(args?: SelectSubset<T, SlideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Slides and returns the data saved in the database.
     * @param {SlideCreateManyAndReturnArgs} args - Arguments to create many Slides.
     * @example
     * // Create many Slides
     * const slide = await prisma.slide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Slides and only return the `id`
     * const slideWithIdOnly = await prisma.slide.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SlideCreateManyAndReturnArgs>(args?: SelectSubset<T, SlideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Slide.
     * @param {SlideDeleteArgs} args - Arguments to delete one Slide.
     * @example
     * // Delete one Slide
     * const Slide = await prisma.slide.delete({
     *   where: {
     *     // ... filter to delete one Slide
     *   }
     * })
     * 
     */
    delete<T extends SlideDeleteArgs>(args: SelectSubset<T, SlideDeleteArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Slide.
     * @param {SlideUpdateArgs} args - Arguments to update one Slide.
     * @example
     * // Update one Slide
     * const slide = await prisma.slide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlideUpdateArgs>(args: SelectSubset<T, SlideUpdateArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Slides.
     * @param {SlideDeleteManyArgs} args - Arguments to filter Slides to delete.
     * @example
     * // Delete a few Slides
     * const { count } = await prisma.slide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlideDeleteManyArgs>(args?: SelectSubset<T, SlideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slides
     * const slide = await prisma.slide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlideUpdateManyArgs>(args: SelectSubset<T, SlideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slides and returns the data updated in the database.
     * @param {SlideUpdateManyAndReturnArgs} args - Arguments to update many Slides.
     * @example
     * // Update many Slides
     * const slide = await prisma.slide.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Slides and only return the `id`
     * const slideWithIdOnly = await prisma.slide.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SlideUpdateManyAndReturnArgs>(args: SelectSubset<T, SlideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Slide.
     * @param {SlideUpsertArgs} args - Arguments to update or create a Slide.
     * @example
     * // Update or create a Slide
     * const slide = await prisma.slide.upsert({
     *   create: {
     *     // ... data to create a Slide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slide we want to update
     *   }
     * })
     */
    upsert<T extends SlideUpsertArgs>(args: SelectSubset<T, SlideUpsertArgs<ExtArgs>>): Prisma__SlideClient<$Result.GetResult<Prisma.$SlidePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Slides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlideCountArgs} args - Arguments to filter Slides to count.
     * @example
     * // Count the number of Slides
     * const count = await prisma.slide.count({
     *   where: {
     *     // ... the filter for the Slides we want to count
     *   }
     * })
    **/
    count<T extends SlideCountArgs>(
      args?: Subset<T, SlideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlideAggregateArgs>(args: Subset<T, SlideAggregateArgs>): Prisma.PrismaPromise<GetSlideAggregateType<T>>

    /**
     * Group by Slide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlideGroupByArgs['orderBy'] }
        : { orderBy?: SlideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Slide model
   */
  readonly fields: SlideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Slide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Slide model
   */
  interface SlideFieldRefs {
    readonly id: FieldRef<"Slide", 'String'>
    readonly title: FieldRef<"Slide", 'String'>
    readonly description: FieldRef<"Slide", 'String'>
    readonly content: FieldRef<"Slide", 'String'>
    readonly theme: FieldRef<"Slide", 'String'>
    readonly status: FieldRef<"Slide", 'String'>
    readonly creatorId: FieldRef<"Slide", 'String'>
    readonly createdAt: FieldRef<"Slide", 'DateTime'>
    readonly updatedAt: FieldRef<"Slide", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Slide findUnique
   */
  export type SlideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * Filter, which Slide to fetch.
     */
    where: SlideWhereUniqueInput
  }

  /**
   * Slide findUniqueOrThrow
   */
  export type SlideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * Filter, which Slide to fetch.
     */
    where: SlideWhereUniqueInput
  }

  /**
   * Slide findFirst
   */
  export type SlideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * Filter, which Slide to fetch.
     */
    where?: SlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slides to fetch.
     */
    orderBy?: SlideOrderByWithRelationInput | SlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Slides.
     */
    cursor?: SlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Slides.
     */
    distinct?: SlideScalarFieldEnum | SlideScalarFieldEnum[]
  }

  /**
   * Slide findFirstOrThrow
   */
  export type SlideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * Filter, which Slide to fetch.
     */
    where?: SlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slides to fetch.
     */
    orderBy?: SlideOrderByWithRelationInput | SlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Slides.
     */
    cursor?: SlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Slides.
     */
    distinct?: SlideScalarFieldEnum | SlideScalarFieldEnum[]
  }

  /**
   * Slide findMany
   */
  export type SlideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * Filter, which Slides to fetch.
     */
    where?: SlideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slides to fetch.
     */
    orderBy?: SlideOrderByWithRelationInput | SlideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Slides.
     */
    cursor?: SlideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slides.
     */
    skip?: number
    distinct?: SlideScalarFieldEnum | SlideScalarFieldEnum[]
  }

  /**
   * Slide create
   */
  export type SlideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * The data needed to create a Slide.
     */
    data: XOR<SlideCreateInput, SlideUncheckedCreateInput>
  }

  /**
   * Slide createMany
   */
  export type SlideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Slides.
     */
    data: SlideCreateManyInput | SlideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Slide createManyAndReturn
   */
  export type SlideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * The data used to create many Slides.
     */
    data: SlideCreateManyInput | SlideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Slide update
   */
  export type SlideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * The data needed to update a Slide.
     */
    data: XOR<SlideUpdateInput, SlideUncheckedUpdateInput>
    /**
     * Choose, which Slide to update.
     */
    where: SlideWhereUniqueInput
  }

  /**
   * Slide updateMany
   */
  export type SlideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Slides.
     */
    data: XOR<SlideUpdateManyMutationInput, SlideUncheckedUpdateManyInput>
    /**
     * Filter which Slides to update
     */
    where?: SlideWhereInput
    /**
     * Limit how many Slides to update.
     */
    limit?: number
  }

  /**
   * Slide updateManyAndReturn
   */
  export type SlideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * The data used to update Slides.
     */
    data: XOR<SlideUpdateManyMutationInput, SlideUncheckedUpdateManyInput>
    /**
     * Filter which Slides to update
     */
    where?: SlideWhereInput
    /**
     * Limit how many Slides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Slide upsert
   */
  export type SlideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * The filter to search for the Slide to update in case it exists.
     */
    where: SlideWhereUniqueInput
    /**
     * In case the Slide found by the `where` argument doesn't exist, create a new Slide with this data.
     */
    create: XOR<SlideCreateInput, SlideUncheckedCreateInput>
    /**
     * In case the Slide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlideUpdateInput, SlideUncheckedUpdateInput>
  }

  /**
   * Slide delete
   */
  export type SlideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
    /**
     * Filter which Slide to delete.
     */
    where: SlideWhereUniqueInput
  }

  /**
   * Slide deleteMany
   */
  export type SlideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Slides to delete
     */
    where?: SlideWhereInput
    /**
     * Limit how many Slides to delete.
     */
    limit?: number
  }

  /**
   * Slide without action
   */
  export type SlideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slide
     */
    select?: SlideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slide
     */
    omit?: SlideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlideInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    avatar: 'avatar',
    bio: 'bio',
    passwordHash: 'passwordHash',
    role: 'role',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const MentorProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    company: 'company',
    jobTitle: 'jobTitle',
    expertise: 'expertise',
    experience: 'experience',
    linkedIn: 'linkedIn',
    maxMentees: 'maxMentees',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MentorProfileScalarFieldEnum = (typeof MentorProfileScalarFieldEnum)[keyof typeof MentorProfileScalarFieldEnum]


  export const MenteeProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentId: 'studentId',
    major: 'major',
    year: 'year',
    careerGoals: 'careerGoals',
    skills: 'skills',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    currentChallenges: 'currentChallenges',
    expectations: 'expectations',
    background: 'background',
    experience: 'experience',
    endGoals: 'endGoals',
    startupIdeas: 'startupIdeas',
    personalNotes: 'personalNotes',
    isOnboardingComplete: 'isOnboardingComplete',
    onboardingCompletedAt: 'onboardingCompletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenteeProfileScalarFieldEnum = (typeof MenteeProfileScalarFieldEnum)[keyof typeof MenteeProfileScalarFieldEnum]


  export const ProgramCycleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramCycleScalarFieldEnum = (typeof ProgramCycleScalarFieldEnum)[keyof typeof ProgramCycleScalarFieldEnum]


  export const MentorshipScalarFieldEnum: {
    id: 'id',
    mentorId: 'mentorId',
    type: 'type',
    status: 'status',
    programCycleId: 'programCycleId',
    startDate: 'startDate',
    endDate: 'endDate',
    maxMentees: 'maxMentees',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MentorshipScalarFieldEnum = (typeof MentorshipScalarFieldEnum)[keyof typeof MentorshipScalarFieldEnum]


  export const MentorshipMenteeScalarFieldEnum: {
    id: 'id',
    mentorshipId: 'mentorshipId',
    menteeId: 'menteeId',
    joinedAt: 'joinedAt',
    status: 'status'
  };

  export type MentorshipMenteeScalarFieldEnum = (typeof MentorshipMenteeScalarFieldEnum)[keyof typeof MentorshipMenteeScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    mentorshipId: 'mentorshipId',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    type: 'type',
    meetingType: 'meetingType',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    location: 'location',
    meetingUrl: 'meetingUrl',
    status: 'status',
    qrToken: 'qrToken',
    qrExpiresAt: 'qrExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    meetingId: 'meetingId',
    userId: 'userId',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    checkInLat: 'checkInLat',
    checkInLng: 'checkInLng',
    deviceHash: 'deviceHash',
    status: 'status',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const MeetingMinutesScalarFieldEnum: {
    id: 'id',
    meetingId: 'meetingId',
    authorId: 'authorId',
    agenda: 'agenda',
    keyPoints: 'keyPoints',
    actionItems: 'actionItems',
    outcome: 'outcome',
    attachments: 'attachments',
    status: 'status',
    submittedAt: 'submittedAt',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingMinutesScalarFieldEnum = (typeof MeetingMinutesScalarFieldEnum)[keyof typeof MeetingMinutesScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    mentorshipId: 'mentorshipId',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    category: 'category',
    targetValue: 'targetValue',
    currentValue: 'currentValue',
    unit: 'unit',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    mentorConfirmed: 'mentorConfirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const ProgressNoteScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    note: 'note',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type ProgressNoteScalarFieldEnum = (typeof ProgressNoteScalarFieldEnum)[keyof typeof ProgressNoteScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    mentorshipId: 'mentorshipId',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    type: 'type',
    rating: 'rating',
    communication: 'communication',
    engagement: 'engagement',
    content: 'content',
    strengths: 'strengths',
    improvements: 'improvements',
    isAnonymous: 'isAnonymous',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    fileUrl: 'fileUrl',
    linkUrl: 'linkUrl',
    fileName: 'fileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    category: 'category',
    tags: 'tags',
    visibility: 'visibility',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const PortfolioScalarFieldEnum: {
    id: 'id',
    menteeId: 'menteeId',
    personalityMbti: 'personalityMbti',
    personalityDisc: 'personalityDisc',
    personalityHolland: 'personalityHolland',
    competencies: 'competencies',
    shortTermGoals: 'shortTermGoals',
    longTermGoals: 'longTermGoals',
    initialCompletedAt: 'initialCompletedAt',
    initialStrengths: 'initialStrengths',
    initialWeaknesses: 'initialWeaknesses',
    initialChallenges: 'initialChallenges',
    initialStartupIdeas: 'initialStartupIdeas',
    initialPersonalNotes: 'initialPersonalNotes',
    finalGoalsAchieved: 'finalGoalsAchieved',
    finalSkillsGained: 'finalSkillsGained',
    finalMentorFeedback: 'finalMentorFeedback',
    finalSelfAssessment: 'finalSelfAssessment',
    finalRecommendations: 'finalRecommendations',
    finalStrengths: 'finalStrengths',
    finalWeaknesses: 'finalWeaknesses',
    finalChallenges: 'finalChallenges',
    finalStartupIdeas: 'finalStartupIdeas',
    finalPersonalNotes: 'finalPersonalNotes',
    finalCompletedAt: 'finalCompletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioScalarFieldEnum = (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum]


  export const AvailabilityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    link: 'link',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SessionReflectionScalarFieldEnum: {
    id: 'id',
    meetingId: 'meetingId',
    menteeId: 'menteeId',
    content: 'content',
    mentorConfirmed: 'mentorConfirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionReflectionScalarFieldEnum = (typeof SessionReflectionScalarFieldEnum)[keyof typeof SessionReflectionScalarFieldEnum]


  export const TodoItemScalarFieldEnum: {
    id: 'id',
    reflectionId: 'reflectionId',
    menteeId: 'menteeId',
    title: 'title',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    startDate: 'startDate',
    column: 'column',
    labels: 'labels',
    description: 'description',
    attachments: 'attachments',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodoItemScalarFieldEnum = (typeof TodoItemScalarFieldEnum)[keyof typeof TodoItemScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityId: 'entityId',
    entityType: 'entityType',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    userId: 'userId',
    assignedToId: 'assignedToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const WikiPageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    category: 'category',
    visibility: 'visibility',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WikiPageScalarFieldEnum = (typeof WikiPageScalarFieldEnum)[keyof typeof WikiPageScalarFieldEnum]


  export const WhiteboardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail: 'thumbnail',
    status: 'status',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhiteboardScalarFieldEnum = (typeof WhiteboardScalarFieldEnum)[keyof typeof WhiteboardScalarFieldEnum]


  export const ArtboardScalarFieldEnum: {
    id: 'id',
    whiteboardId: 'whiteboardId',
    order: 'order',
    name: 'name',
    elements: 'elements',
    appState: 'appState',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArtboardScalarFieldEnum = (typeof ArtboardScalarFieldEnum)[keyof typeof ArtboardScalarFieldEnum]


  export const SlideScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    theme: 'theme',
    status: 'status',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SlideScalarFieldEnum = (typeof SlideScalarFieldEnum)[keyof typeof SlideScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    mentorProfile?: XOR<MentorProfileNullableScalarRelationFilter, MentorProfileWhereInput> | null
    menteeProfile?: XOR<MenteeProfileNullableScalarRelationFilter, MenteeProfileWhereInput> | null
    accounts?: AccountListRelationFilter
    mentorships?: MentorshipListRelationFilter
    menteeships?: MentorshipMenteeListRelationFilter
    meetingsCreated?: MeetingListRelationFilter
    attendances?: AttendanceListRelationFilter
    minutesCreated?: MeetingMinutesListRelationFilter
    goalsCreated?: GoalListRelationFilter
    feedbackGiven?: FeedbackListRelationFilter
    feedbackReceived?: FeedbackListRelationFilter
    resourcesUploaded?: ResourceListRelationFilter
    notifications?: NotificationListRelationFilter
    portfolios?: PortfolioListRelationFilter
    availabilities?: AvailabilityListRelationFilter
    sessionReflections?: SessionReflectionListRelationFilter
    todoItems?: TodoItemListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    ticketsCreated?: SupportTicketListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    wikiPages?: WikiPageListRelationFilter
    whiteboards?: WhiteboardListRelationFilter
    slides?: SlideListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mentorProfile?: MentorProfileOrderByWithRelationInput
    menteeProfile?: MenteeProfileOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    mentorships?: MentorshipOrderByRelationAggregateInput
    menteeships?: MentorshipMenteeOrderByRelationAggregateInput
    meetingsCreated?: MeetingOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    minutesCreated?: MeetingMinutesOrderByRelationAggregateInput
    goalsCreated?: GoalOrderByRelationAggregateInput
    feedbackGiven?: FeedbackOrderByRelationAggregateInput
    feedbackReceived?: FeedbackOrderByRelationAggregateInput
    resourcesUploaded?: ResourceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    portfolios?: PortfolioOrderByRelationAggregateInput
    availabilities?: AvailabilityOrderByRelationAggregateInput
    sessionReflections?: SessionReflectionOrderByRelationAggregateInput
    todoItems?: TodoItemOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    ticketsCreated?: SupportTicketOrderByRelationAggregateInput
    assignedTickets?: SupportTicketOrderByRelationAggregateInput
    ticketComments?: TicketCommentOrderByRelationAggregateInput
    wikiPages?: WikiPageOrderByRelationAggregateInput
    whiteboards?: WhiteboardOrderByRelationAggregateInput
    slides?: SlideOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    mentorProfile?: XOR<MentorProfileNullableScalarRelationFilter, MentorProfileWhereInput> | null
    menteeProfile?: XOR<MenteeProfileNullableScalarRelationFilter, MenteeProfileWhereInput> | null
    accounts?: AccountListRelationFilter
    mentorships?: MentorshipListRelationFilter
    menteeships?: MentorshipMenteeListRelationFilter
    meetingsCreated?: MeetingListRelationFilter
    attendances?: AttendanceListRelationFilter
    minutesCreated?: MeetingMinutesListRelationFilter
    goalsCreated?: GoalListRelationFilter
    feedbackGiven?: FeedbackListRelationFilter
    feedbackReceived?: FeedbackListRelationFilter
    resourcesUploaded?: ResourceListRelationFilter
    notifications?: NotificationListRelationFilter
    portfolios?: PortfolioListRelationFilter
    availabilities?: AvailabilityListRelationFilter
    sessionReflections?: SessionReflectionListRelationFilter
    todoItems?: TodoItemListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    ticketsCreated?: SupportTicketListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    wikiPages?: WikiPageListRelationFilter
    whiteboards?: WhiteboardListRelationFilter
    slides?: SlideListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type MentorProfileWhereInput = {
    AND?: MentorProfileWhereInput | MentorProfileWhereInput[]
    OR?: MentorProfileWhereInput[]
    NOT?: MentorProfileWhereInput | MentorProfileWhereInput[]
    id?: StringFilter<"MentorProfile"> | string
    userId?: StringFilter<"MentorProfile"> | string
    company?: StringNullableFilter<"MentorProfile"> | string | null
    jobTitle?: StringNullableFilter<"MentorProfile"> | string | null
    expertise?: StringNullableFilter<"MentorProfile"> | string | null
    experience?: StringNullableFilter<"MentorProfile"> | string | null
    linkedIn?: StringNullableFilter<"MentorProfile"> | string | null
    maxMentees?: IntFilter<"MentorProfile"> | number
    createdAt?: DateTimeFilter<"MentorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"MentorProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MentorProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    linkedIn?: SortOrderInput | SortOrder
    maxMentees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MentorProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: MentorProfileWhereInput | MentorProfileWhereInput[]
    OR?: MentorProfileWhereInput[]
    NOT?: MentorProfileWhereInput | MentorProfileWhereInput[]
    company?: StringNullableFilter<"MentorProfile"> | string | null
    jobTitle?: StringNullableFilter<"MentorProfile"> | string | null
    expertise?: StringNullableFilter<"MentorProfile"> | string | null
    experience?: StringNullableFilter<"MentorProfile"> | string | null
    linkedIn?: StringNullableFilter<"MentorProfile"> | string | null
    maxMentees?: IntFilter<"MentorProfile"> | number
    createdAt?: DateTimeFilter<"MentorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"MentorProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type MentorProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    linkedIn?: SortOrderInput | SortOrder
    maxMentees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MentorProfileCountOrderByAggregateInput
    _avg?: MentorProfileAvgOrderByAggregateInput
    _max?: MentorProfileMaxOrderByAggregateInput
    _min?: MentorProfileMinOrderByAggregateInput
    _sum?: MentorProfileSumOrderByAggregateInput
  }

  export type MentorProfileScalarWhereWithAggregatesInput = {
    AND?: MentorProfileScalarWhereWithAggregatesInput | MentorProfileScalarWhereWithAggregatesInput[]
    OR?: MentorProfileScalarWhereWithAggregatesInput[]
    NOT?: MentorProfileScalarWhereWithAggregatesInput | MentorProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MentorProfile"> | string
    userId?: StringWithAggregatesFilter<"MentorProfile"> | string
    company?: StringNullableWithAggregatesFilter<"MentorProfile"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"MentorProfile"> | string | null
    expertise?: StringNullableWithAggregatesFilter<"MentorProfile"> | string | null
    experience?: StringNullableWithAggregatesFilter<"MentorProfile"> | string | null
    linkedIn?: StringNullableWithAggregatesFilter<"MentorProfile"> | string | null
    maxMentees?: IntWithAggregatesFilter<"MentorProfile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MentorProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MentorProfile"> | Date | string
  }

  export type MenteeProfileWhereInput = {
    AND?: MenteeProfileWhereInput | MenteeProfileWhereInput[]
    OR?: MenteeProfileWhereInput[]
    NOT?: MenteeProfileWhereInput | MenteeProfileWhereInput[]
    id?: StringFilter<"MenteeProfile"> | string
    userId?: StringFilter<"MenteeProfile"> | string
    studentId?: StringNullableFilter<"MenteeProfile"> | string | null
    major?: StringNullableFilter<"MenteeProfile"> | string | null
    year?: IntNullableFilter<"MenteeProfile"> | number | null
    careerGoals?: StringNullableFilter<"MenteeProfile"> | string | null
    skills?: StringNullableFilter<"MenteeProfile"> | string | null
    strengths?: StringNullableFilter<"MenteeProfile"> | string | null
    weaknesses?: StringNullableFilter<"MenteeProfile"> | string | null
    currentChallenges?: StringNullableFilter<"MenteeProfile"> | string | null
    expectations?: StringNullableFilter<"MenteeProfile"> | string | null
    background?: StringNullableFilter<"MenteeProfile"> | string | null
    experience?: StringNullableFilter<"MenteeProfile"> | string | null
    endGoals?: StringNullableFilter<"MenteeProfile"> | string | null
    startupIdeas?: StringNullableFilter<"MenteeProfile"> | string | null
    personalNotes?: StringNullableFilter<"MenteeProfile"> | string | null
    isOnboardingComplete?: BoolFilter<"MenteeProfile"> | boolean
    onboardingCompletedAt?: DateTimeNullableFilter<"MenteeProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"MenteeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"MenteeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MenteeProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrderInput | SortOrder
    major?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    careerGoals?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    weaknesses?: SortOrderInput | SortOrder
    currentChallenges?: SortOrderInput | SortOrder
    expectations?: SortOrderInput | SortOrder
    background?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    endGoals?: SortOrderInput | SortOrder
    startupIdeas?: SortOrderInput | SortOrder
    personalNotes?: SortOrderInput | SortOrder
    isOnboardingComplete?: SortOrder
    onboardingCompletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MenteeProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: MenteeProfileWhereInput | MenteeProfileWhereInput[]
    OR?: MenteeProfileWhereInput[]
    NOT?: MenteeProfileWhereInput | MenteeProfileWhereInput[]
    studentId?: StringNullableFilter<"MenteeProfile"> | string | null
    major?: StringNullableFilter<"MenteeProfile"> | string | null
    year?: IntNullableFilter<"MenteeProfile"> | number | null
    careerGoals?: StringNullableFilter<"MenteeProfile"> | string | null
    skills?: StringNullableFilter<"MenteeProfile"> | string | null
    strengths?: StringNullableFilter<"MenteeProfile"> | string | null
    weaknesses?: StringNullableFilter<"MenteeProfile"> | string | null
    currentChallenges?: StringNullableFilter<"MenteeProfile"> | string | null
    expectations?: StringNullableFilter<"MenteeProfile"> | string | null
    background?: StringNullableFilter<"MenteeProfile"> | string | null
    experience?: StringNullableFilter<"MenteeProfile"> | string | null
    endGoals?: StringNullableFilter<"MenteeProfile"> | string | null
    startupIdeas?: StringNullableFilter<"MenteeProfile"> | string | null
    personalNotes?: StringNullableFilter<"MenteeProfile"> | string | null
    isOnboardingComplete?: BoolFilter<"MenteeProfile"> | boolean
    onboardingCompletedAt?: DateTimeNullableFilter<"MenteeProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"MenteeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"MenteeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type MenteeProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrderInput | SortOrder
    major?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    careerGoals?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    weaknesses?: SortOrderInput | SortOrder
    currentChallenges?: SortOrderInput | SortOrder
    expectations?: SortOrderInput | SortOrder
    background?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    endGoals?: SortOrderInput | SortOrder
    startupIdeas?: SortOrderInput | SortOrder
    personalNotes?: SortOrderInput | SortOrder
    isOnboardingComplete?: SortOrder
    onboardingCompletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenteeProfileCountOrderByAggregateInput
    _avg?: MenteeProfileAvgOrderByAggregateInput
    _max?: MenteeProfileMaxOrderByAggregateInput
    _min?: MenteeProfileMinOrderByAggregateInput
    _sum?: MenteeProfileSumOrderByAggregateInput
  }

  export type MenteeProfileScalarWhereWithAggregatesInput = {
    AND?: MenteeProfileScalarWhereWithAggregatesInput | MenteeProfileScalarWhereWithAggregatesInput[]
    OR?: MenteeProfileScalarWhereWithAggregatesInput[]
    NOT?: MenteeProfileScalarWhereWithAggregatesInput | MenteeProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MenteeProfile"> | string
    userId?: StringWithAggregatesFilter<"MenteeProfile"> | string
    studentId?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    major?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    year?: IntNullableWithAggregatesFilter<"MenteeProfile"> | number | null
    careerGoals?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    skills?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    strengths?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    weaknesses?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    currentChallenges?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    expectations?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    background?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    experience?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    endGoals?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    startupIdeas?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    personalNotes?: StringNullableWithAggregatesFilter<"MenteeProfile"> | string | null
    isOnboardingComplete?: BoolWithAggregatesFilter<"MenteeProfile"> | boolean
    onboardingCompletedAt?: DateTimeNullableWithAggregatesFilter<"MenteeProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MenteeProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenteeProfile"> | Date | string
  }

  export type ProgramCycleWhereInput = {
    AND?: ProgramCycleWhereInput | ProgramCycleWhereInput[]
    OR?: ProgramCycleWhereInput[]
    NOT?: ProgramCycleWhereInput | ProgramCycleWhereInput[]
    id?: StringFilter<"ProgramCycle"> | string
    name?: StringFilter<"ProgramCycle"> | string
    description?: StringNullableFilter<"ProgramCycle"> | string | null
    startDate?: DateTimeFilter<"ProgramCycle"> | Date | string
    endDate?: DateTimeFilter<"ProgramCycle"> | Date | string
    status?: StringFilter<"ProgramCycle"> | string
    createdAt?: DateTimeFilter<"ProgramCycle"> | Date | string
    updatedAt?: DateTimeFilter<"ProgramCycle"> | Date | string
    mentorships?: MentorshipListRelationFilter
  }

  export type ProgramCycleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mentorships?: MentorshipOrderByRelationAggregateInput
  }

  export type ProgramCycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramCycleWhereInput | ProgramCycleWhereInput[]
    OR?: ProgramCycleWhereInput[]
    NOT?: ProgramCycleWhereInput | ProgramCycleWhereInput[]
    name?: StringFilter<"ProgramCycle"> | string
    description?: StringNullableFilter<"ProgramCycle"> | string | null
    startDate?: DateTimeFilter<"ProgramCycle"> | Date | string
    endDate?: DateTimeFilter<"ProgramCycle"> | Date | string
    status?: StringFilter<"ProgramCycle"> | string
    createdAt?: DateTimeFilter<"ProgramCycle"> | Date | string
    updatedAt?: DateTimeFilter<"ProgramCycle"> | Date | string
    mentorships?: MentorshipListRelationFilter
  }, "id">

  export type ProgramCycleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramCycleCountOrderByAggregateInput
    _max?: ProgramCycleMaxOrderByAggregateInput
    _min?: ProgramCycleMinOrderByAggregateInput
  }

  export type ProgramCycleScalarWhereWithAggregatesInput = {
    AND?: ProgramCycleScalarWhereWithAggregatesInput | ProgramCycleScalarWhereWithAggregatesInput[]
    OR?: ProgramCycleScalarWhereWithAggregatesInput[]
    NOT?: ProgramCycleScalarWhereWithAggregatesInput | ProgramCycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramCycle"> | string
    name?: StringWithAggregatesFilter<"ProgramCycle"> | string
    description?: StringNullableWithAggregatesFilter<"ProgramCycle"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"ProgramCycle"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ProgramCycle"> | Date | string
    status?: StringWithAggregatesFilter<"ProgramCycle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProgramCycle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProgramCycle"> | Date | string
  }

  export type MentorshipWhereInput = {
    AND?: MentorshipWhereInput | MentorshipWhereInput[]
    OR?: MentorshipWhereInput[]
    NOT?: MentorshipWhereInput | MentorshipWhereInput[]
    id?: StringFilter<"Mentorship"> | string
    mentorId?: StringFilter<"Mentorship"> | string
    type?: StringFilter<"Mentorship"> | string
    status?: StringFilter<"Mentorship"> | string
    programCycleId?: StringFilter<"Mentorship"> | string
    startDate?: DateTimeFilter<"Mentorship"> | Date | string
    endDate?: DateTimeFilter<"Mentorship"> | Date | string
    maxMentees?: IntFilter<"Mentorship"> | number
    notes?: StringNullableFilter<"Mentorship"> | string | null
    createdAt?: DateTimeFilter<"Mentorship"> | Date | string
    updatedAt?: DateTimeFilter<"Mentorship"> | Date | string
    mentor?: XOR<UserScalarRelationFilter, UserWhereInput>
    programCycle?: XOR<ProgramCycleScalarRelationFilter, ProgramCycleWhereInput>
    mentees?: MentorshipMenteeListRelationFilter
    meetings?: MeetingListRelationFilter
    goals?: GoalListRelationFilter
    feedbacks?: FeedbackListRelationFilter
  }

  export type MentorshipOrderByWithRelationInput = {
    id?: SortOrder
    mentorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    programCycleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mentor?: UserOrderByWithRelationInput
    programCycle?: ProgramCycleOrderByWithRelationInput
    mentees?: MentorshipMenteeOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    goals?: GoalOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
  }

  export type MentorshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MentorshipWhereInput | MentorshipWhereInput[]
    OR?: MentorshipWhereInput[]
    NOT?: MentorshipWhereInput | MentorshipWhereInput[]
    mentorId?: StringFilter<"Mentorship"> | string
    type?: StringFilter<"Mentorship"> | string
    status?: StringFilter<"Mentorship"> | string
    programCycleId?: StringFilter<"Mentorship"> | string
    startDate?: DateTimeFilter<"Mentorship"> | Date | string
    endDate?: DateTimeFilter<"Mentorship"> | Date | string
    maxMentees?: IntFilter<"Mentorship"> | number
    notes?: StringNullableFilter<"Mentorship"> | string | null
    createdAt?: DateTimeFilter<"Mentorship"> | Date | string
    updatedAt?: DateTimeFilter<"Mentorship"> | Date | string
    mentor?: XOR<UserScalarRelationFilter, UserWhereInput>
    programCycle?: XOR<ProgramCycleScalarRelationFilter, ProgramCycleWhereInput>
    mentees?: MentorshipMenteeListRelationFilter
    meetings?: MeetingListRelationFilter
    goals?: GoalListRelationFilter
    feedbacks?: FeedbackListRelationFilter
  }, "id">

  export type MentorshipOrderByWithAggregationInput = {
    id?: SortOrder
    mentorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    programCycleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MentorshipCountOrderByAggregateInput
    _avg?: MentorshipAvgOrderByAggregateInput
    _max?: MentorshipMaxOrderByAggregateInput
    _min?: MentorshipMinOrderByAggregateInput
    _sum?: MentorshipSumOrderByAggregateInput
  }

  export type MentorshipScalarWhereWithAggregatesInput = {
    AND?: MentorshipScalarWhereWithAggregatesInput | MentorshipScalarWhereWithAggregatesInput[]
    OR?: MentorshipScalarWhereWithAggregatesInput[]
    NOT?: MentorshipScalarWhereWithAggregatesInput | MentorshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mentorship"> | string
    mentorId?: StringWithAggregatesFilter<"Mentorship"> | string
    type?: StringWithAggregatesFilter<"Mentorship"> | string
    status?: StringWithAggregatesFilter<"Mentorship"> | string
    programCycleId?: StringWithAggregatesFilter<"Mentorship"> | string
    startDate?: DateTimeWithAggregatesFilter<"Mentorship"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Mentorship"> | Date | string
    maxMentees?: IntWithAggregatesFilter<"Mentorship"> | number
    notes?: StringNullableWithAggregatesFilter<"Mentorship"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Mentorship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mentorship"> | Date | string
  }

  export type MentorshipMenteeWhereInput = {
    AND?: MentorshipMenteeWhereInput | MentorshipMenteeWhereInput[]
    OR?: MentorshipMenteeWhereInput[]
    NOT?: MentorshipMenteeWhereInput | MentorshipMenteeWhereInput[]
    id?: StringFilter<"MentorshipMentee"> | string
    mentorshipId?: StringFilter<"MentorshipMentee"> | string
    menteeId?: StringFilter<"MentorshipMentee"> | string
    joinedAt?: DateTimeFilter<"MentorshipMentee"> | Date | string
    status?: StringFilter<"MentorshipMentee"> | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MentorshipMenteeOrderByWithRelationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    menteeId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    mentorship?: MentorshipOrderByWithRelationInput
    mentee?: UserOrderByWithRelationInput
  }

  export type MentorshipMenteeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mentorshipId_menteeId?: MentorshipMenteeMentorshipIdMenteeIdCompoundUniqueInput
    AND?: MentorshipMenteeWhereInput | MentorshipMenteeWhereInput[]
    OR?: MentorshipMenteeWhereInput[]
    NOT?: MentorshipMenteeWhereInput | MentorshipMenteeWhereInput[]
    mentorshipId?: StringFilter<"MentorshipMentee"> | string
    menteeId?: StringFilter<"MentorshipMentee"> | string
    joinedAt?: DateTimeFilter<"MentorshipMentee"> | Date | string
    status?: StringFilter<"MentorshipMentee"> | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "mentorshipId_menteeId">

  export type MentorshipMenteeOrderByWithAggregationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    menteeId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    _count?: MentorshipMenteeCountOrderByAggregateInput
    _max?: MentorshipMenteeMaxOrderByAggregateInput
    _min?: MentorshipMenteeMinOrderByAggregateInput
  }

  export type MentorshipMenteeScalarWhereWithAggregatesInput = {
    AND?: MentorshipMenteeScalarWhereWithAggregatesInput | MentorshipMenteeScalarWhereWithAggregatesInput[]
    OR?: MentorshipMenteeScalarWhereWithAggregatesInput[]
    NOT?: MentorshipMenteeScalarWhereWithAggregatesInput | MentorshipMenteeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MentorshipMentee"> | string
    mentorshipId?: StringWithAggregatesFilter<"MentorshipMentee"> | string
    menteeId?: StringWithAggregatesFilter<"MentorshipMentee"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"MentorshipMentee"> | Date | string
    status?: StringWithAggregatesFilter<"MentorshipMentee"> | string
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: StringFilter<"Meeting"> | string
    mentorshipId?: StringFilter<"Meeting"> | string
    creatorId?: StringFilter<"Meeting"> | string
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    type?: StringFilter<"Meeting"> | string
    meetingType?: StringFilter<"Meeting"> | string
    scheduledAt?: DateTimeFilter<"Meeting"> | Date | string
    duration?: IntFilter<"Meeting"> | number
    location?: StringNullableFilter<"Meeting"> | string | null
    meetingUrl?: StringNullableFilter<"Meeting"> | string | null
    status?: StringFilter<"Meeting"> | string
    qrToken?: StringNullableFilter<"Meeting"> | string | null
    qrExpiresAt?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    attendances?: AttendanceListRelationFilter
    minutes?: MeetingMinutesListRelationFilter
    sessionReflections?: SessionReflectionListRelationFilter
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    meetingType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    qrToken?: SortOrderInput | SortOrder
    qrExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mentorship?: MentorshipOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    attendances?: AttendanceOrderByRelationAggregateInput
    minutes?: MeetingMinutesOrderByRelationAggregateInput
    sessionReflections?: SessionReflectionOrderByRelationAggregateInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrToken?: string
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    mentorshipId?: StringFilter<"Meeting"> | string
    creatorId?: StringFilter<"Meeting"> | string
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    type?: StringFilter<"Meeting"> | string
    meetingType?: StringFilter<"Meeting"> | string
    scheduledAt?: DateTimeFilter<"Meeting"> | Date | string
    duration?: IntFilter<"Meeting"> | number
    location?: StringNullableFilter<"Meeting"> | string | null
    meetingUrl?: StringNullableFilter<"Meeting"> | string | null
    status?: StringFilter<"Meeting"> | string
    qrExpiresAt?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    attendances?: AttendanceListRelationFilter
    minutes?: MeetingMinutesListRelationFilter
    sessionReflections?: SessionReflectionListRelationFilter
  }, "id" | "qrToken">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    meetingType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    qrToken?: SortOrderInput | SortOrder
    qrExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meeting"> | string
    mentorshipId?: StringWithAggregatesFilter<"Meeting"> | string
    creatorId?: StringWithAggregatesFilter<"Meeting"> | string
    title?: StringWithAggregatesFilter<"Meeting"> | string
    description?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    type?: StringWithAggregatesFilter<"Meeting"> | string
    meetingType?: StringWithAggregatesFilter<"Meeting"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    duration?: IntWithAggregatesFilter<"Meeting"> | number
    location?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    meetingUrl?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    status?: StringWithAggregatesFilter<"Meeting"> | string
    qrToken?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    qrExpiresAt?: DateTimeNullableWithAggregatesFilter<"Meeting"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    meetingId?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    checkInTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkInLat?: FloatNullableFilter<"Attendance"> | number | null
    checkInLng?: FloatNullableFilter<"Attendance"> | number | null
    deviceHash?: StringNullableFilter<"Attendance"> | string | null
    status?: StringFilter<"Attendance"> | string
    verifiedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    checkInLat?: SortOrderInput | SortOrder
    checkInLng?: SortOrderInput | SortOrder
    deviceHash?: SortOrderInput | SortOrder
    status?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    meeting?: MeetingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    meetingId_userId?: AttendanceMeetingIdUserIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    meetingId?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    checkInTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkInLat?: FloatNullableFilter<"Attendance"> | number | null
    checkInLng?: FloatNullableFilter<"Attendance"> | number | null
    deviceHash?: StringNullableFilter<"Attendance"> | string | null
    status?: StringFilter<"Attendance"> | string
    verifiedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "meetingId_userId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    checkInLat?: SortOrderInput | SortOrder
    checkInLng?: SortOrderInput | SortOrder
    deviceHash?: SortOrderInput | SortOrder
    status?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    meetingId?: StringWithAggregatesFilter<"Attendance"> | string
    userId?: StringWithAggregatesFilter<"Attendance"> | string
    checkInTime?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    checkInLat?: FloatNullableWithAggregatesFilter<"Attendance"> | number | null
    checkInLng?: FloatNullableWithAggregatesFilter<"Attendance"> | number | null
    deviceHash?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    status?: StringWithAggregatesFilter<"Attendance"> | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type MeetingMinutesWhereInput = {
    AND?: MeetingMinutesWhereInput | MeetingMinutesWhereInput[]
    OR?: MeetingMinutesWhereInput[]
    NOT?: MeetingMinutesWhereInput | MeetingMinutesWhereInput[]
    id?: StringFilter<"MeetingMinutes"> | string
    meetingId?: StringFilter<"MeetingMinutes"> | string
    authorId?: StringFilter<"MeetingMinutes"> | string
    agenda?: StringNullableFilter<"MeetingMinutes"> | string | null
    keyPoints?: StringNullableFilter<"MeetingMinutes"> | string | null
    actionItems?: StringNullableFilter<"MeetingMinutes"> | string | null
    outcome?: StringNullableFilter<"MeetingMinutes"> | string | null
    attachments?: StringNullableFilter<"MeetingMinutes"> | string | null
    status?: StringFilter<"MeetingMinutes"> | string
    submittedAt?: DateTimeNullableFilter<"MeetingMinutes"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"MeetingMinutes"> | Date | string | null
    createdAt?: DateTimeFilter<"MeetingMinutes"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingMinutes"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MeetingMinutesOrderByWithRelationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    authorId?: SortOrder
    agenda?: SortOrderInput | SortOrder
    keyPoints?: SortOrderInput | SortOrder
    actionItems?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meeting?: MeetingOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type MeetingMinutesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeetingMinutesWhereInput | MeetingMinutesWhereInput[]
    OR?: MeetingMinutesWhereInput[]
    NOT?: MeetingMinutesWhereInput | MeetingMinutesWhereInput[]
    meetingId?: StringFilter<"MeetingMinutes"> | string
    authorId?: StringFilter<"MeetingMinutes"> | string
    agenda?: StringNullableFilter<"MeetingMinutes"> | string | null
    keyPoints?: StringNullableFilter<"MeetingMinutes"> | string | null
    actionItems?: StringNullableFilter<"MeetingMinutes"> | string | null
    outcome?: StringNullableFilter<"MeetingMinutes"> | string | null
    attachments?: StringNullableFilter<"MeetingMinutes"> | string | null
    status?: StringFilter<"MeetingMinutes"> | string
    submittedAt?: DateTimeNullableFilter<"MeetingMinutes"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"MeetingMinutes"> | Date | string | null
    createdAt?: DateTimeFilter<"MeetingMinutes"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingMinutes"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MeetingMinutesOrderByWithAggregationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    authorId?: SortOrder
    agenda?: SortOrderInput | SortOrder
    keyPoints?: SortOrderInput | SortOrder
    actionItems?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingMinutesCountOrderByAggregateInput
    _max?: MeetingMinutesMaxOrderByAggregateInput
    _min?: MeetingMinutesMinOrderByAggregateInput
  }

  export type MeetingMinutesScalarWhereWithAggregatesInput = {
    AND?: MeetingMinutesScalarWhereWithAggregatesInput | MeetingMinutesScalarWhereWithAggregatesInput[]
    OR?: MeetingMinutesScalarWhereWithAggregatesInput[]
    NOT?: MeetingMinutesScalarWhereWithAggregatesInput | MeetingMinutesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeetingMinutes"> | string
    meetingId?: StringWithAggregatesFilter<"MeetingMinutes"> | string
    authorId?: StringWithAggregatesFilter<"MeetingMinutes"> | string
    agenda?: StringNullableWithAggregatesFilter<"MeetingMinutes"> | string | null
    keyPoints?: StringNullableWithAggregatesFilter<"MeetingMinutes"> | string | null
    actionItems?: StringNullableWithAggregatesFilter<"MeetingMinutes"> | string | null
    outcome?: StringNullableWithAggregatesFilter<"MeetingMinutes"> | string | null
    attachments?: StringNullableWithAggregatesFilter<"MeetingMinutes"> | string | null
    status?: StringWithAggregatesFilter<"MeetingMinutes"> | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"MeetingMinutes"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"MeetingMinutes"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MeetingMinutes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MeetingMinutes"> | Date | string
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: StringFilter<"Goal"> | string
    mentorshipId?: StringFilter<"Goal"> | string
    creatorId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringFilter<"Goal"> | string
    targetValue?: IntNullableFilter<"Goal"> | number | null
    currentValue?: IntFilter<"Goal"> | number
    unit?: StringNullableFilter<"Goal"> | string | null
    status?: StringFilter<"Goal"> | string
    priority?: StringFilter<"Goal"> | string
    dueDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    mentorConfirmed?: BoolFilter<"Goal"> | boolean
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    progressNotes?: ProgressNoteListRelationFilter
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mentorship?: MentorshipOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    progressNotes?: ProgressNoteOrderByRelationAggregateInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    mentorshipId?: StringFilter<"Goal"> | string
    creatorId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringFilter<"Goal"> | string
    targetValue?: IntNullableFilter<"Goal"> | number | null
    currentValue?: IntFilter<"Goal"> | number
    unit?: StringNullableFilter<"Goal"> | string | null
    status?: StringFilter<"Goal"> | string
    priority?: StringFilter<"Goal"> | string
    dueDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    mentorConfirmed?: BoolFilter<"Goal"> | boolean
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    progressNotes?: ProgressNoteListRelationFilter
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoalCountOrderByAggregateInput
    _avg?: GoalAvgOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
    _sum?: GoalSumOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Goal"> | string
    mentorshipId?: StringWithAggregatesFilter<"Goal"> | string
    creatorId?: StringWithAggregatesFilter<"Goal"> | string
    title?: StringWithAggregatesFilter<"Goal"> | string
    description?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    category?: StringWithAggregatesFilter<"Goal"> | string
    targetValue?: IntNullableWithAggregatesFilter<"Goal"> | number | null
    currentValue?: IntWithAggregatesFilter<"Goal"> | number
    unit?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    status?: StringWithAggregatesFilter<"Goal"> | string
    priority?: StringWithAggregatesFilter<"Goal"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    mentorConfirmed?: BoolWithAggregatesFilter<"Goal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
  }

  export type ProgressNoteWhereInput = {
    AND?: ProgressNoteWhereInput | ProgressNoteWhereInput[]
    OR?: ProgressNoteWhereInput[]
    NOT?: ProgressNoteWhereInput | ProgressNoteWhereInput[]
    id?: StringFilter<"ProgressNote"> | string
    goalId?: StringFilter<"ProgressNote"> | string
    note?: StringFilter<"ProgressNote"> | string
    value?: IntNullableFilter<"ProgressNote"> | number | null
    createdAt?: DateTimeFilter<"ProgressNote"> | Date | string
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
  }

  export type ProgressNoteOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    note?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    goal?: GoalOrderByWithRelationInput
  }

  export type ProgressNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgressNoteWhereInput | ProgressNoteWhereInput[]
    OR?: ProgressNoteWhereInput[]
    NOT?: ProgressNoteWhereInput | ProgressNoteWhereInput[]
    goalId?: StringFilter<"ProgressNote"> | string
    note?: StringFilter<"ProgressNote"> | string
    value?: IntNullableFilter<"ProgressNote"> | number | null
    createdAt?: DateTimeFilter<"ProgressNote"> | Date | string
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
  }, "id">

  export type ProgressNoteOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    note?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProgressNoteCountOrderByAggregateInput
    _avg?: ProgressNoteAvgOrderByAggregateInput
    _max?: ProgressNoteMaxOrderByAggregateInput
    _min?: ProgressNoteMinOrderByAggregateInput
    _sum?: ProgressNoteSumOrderByAggregateInput
  }

  export type ProgressNoteScalarWhereWithAggregatesInput = {
    AND?: ProgressNoteScalarWhereWithAggregatesInput | ProgressNoteScalarWhereWithAggregatesInput[]
    OR?: ProgressNoteScalarWhereWithAggregatesInput[]
    NOT?: ProgressNoteScalarWhereWithAggregatesInput | ProgressNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgressNote"> | string
    goalId?: StringWithAggregatesFilter<"ProgressNote"> | string
    note?: StringWithAggregatesFilter<"ProgressNote"> | string
    value?: IntNullableWithAggregatesFilter<"ProgressNote"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ProgressNote"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    mentorshipId?: StringFilter<"Feedback"> | string
    fromUserId?: StringFilter<"Feedback"> | string
    toUserId?: StringFilter<"Feedback"> | string
    type?: StringFilter<"Feedback"> | string
    rating?: IntNullableFilter<"Feedback"> | number | null
    communication?: IntNullableFilter<"Feedback"> | number | null
    engagement?: IntNullableFilter<"Feedback"> | number | null
    content?: StringNullableFilter<"Feedback"> | string | null
    strengths?: StringNullableFilter<"Feedback"> | string | null
    improvements?: StringNullableFilter<"Feedback"> | string | null
    isAnonymous?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    fromUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    toUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    type?: SortOrder
    rating?: SortOrderInput | SortOrder
    communication?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    improvements?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mentorship?: MentorshipOrderByWithRelationInput
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    mentorshipId?: StringFilter<"Feedback"> | string
    fromUserId?: StringFilter<"Feedback"> | string
    toUserId?: StringFilter<"Feedback"> | string
    type?: StringFilter<"Feedback"> | string
    rating?: IntNullableFilter<"Feedback"> | number | null
    communication?: IntNullableFilter<"Feedback"> | number | null
    engagement?: IntNullableFilter<"Feedback"> | number | null
    content?: StringNullableFilter<"Feedback"> | string | null
    strengths?: StringNullableFilter<"Feedback"> | string | null
    improvements?: StringNullableFilter<"Feedback"> | string | null
    isAnonymous?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    mentorship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
    fromUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    toUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    type?: SortOrder
    rating?: SortOrderInput | SortOrder
    communication?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    improvements?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    mentorshipId?: StringWithAggregatesFilter<"Feedback"> | string
    fromUserId?: StringWithAggregatesFilter<"Feedback"> | string
    toUserId?: StringWithAggregatesFilter<"Feedback"> | string
    type?: StringWithAggregatesFilter<"Feedback"> | string
    rating?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    communication?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    engagement?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    content?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    strengths?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    improvements?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    isAnonymous?: BoolWithAggregatesFilter<"Feedback"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    type?: StringFilter<"Resource"> | string
    fileUrl?: StringNullableFilter<"Resource"> | string | null
    linkUrl?: StringNullableFilter<"Resource"> | string | null
    fileName?: StringNullableFilter<"Resource"> | string | null
    fileSize?: IntNullableFilter<"Resource"> | number | null
    mimeType?: StringNullableFilter<"Resource"> | string | null
    category?: StringNullableFilter<"Resource"> | string | null
    tags?: StringNullableFilter<"Resource"> | string | null
    visibility?: StringFilter<"Resource"> | string
    uploadedById?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    visibility?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    type?: StringFilter<"Resource"> | string
    fileUrl?: StringNullableFilter<"Resource"> | string | null
    linkUrl?: StringNullableFilter<"Resource"> | string | null
    fileName?: StringNullableFilter<"Resource"> | string | null
    fileSize?: IntNullableFilter<"Resource"> | number | null
    mimeType?: StringNullableFilter<"Resource"> | string | null
    category?: StringNullableFilter<"Resource"> | string | null
    tags?: StringNullableFilter<"Resource"> | string | null
    visibility?: StringFilter<"Resource"> | string
    uploadedById?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    visibility?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    type?: StringWithAggregatesFilter<"Resource"> | string
    fileUrl?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    linkUrl?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"Resource"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    category?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    visibility?: StringWithAggregatesFilter<"Resource"> | string
    uploadedById?: StringWithAggregatesFilter<"Resource"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type PortfolioWhereInput = {
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    id?: StringFilter<"Portfolio"> | string
    menteeId?: StringFilter<"Portfolio"> | string
    personalityMbti?: StringNullableFilter<"Portfolio"> | string | null
    personalityDisc?: StringNullableFilter<"Portfolio"> | string | null
    personalityHolland?: StringNullableFilter<"Portfolio"> | string | null
    competencies?: StringNullableFilter<"Portfolio"> | string | null
    shortTermGoals?: StringNullableFilter<"Portfolio"> | string | null
    longTermGoals?: StringNullableFilter<"Portfolio"> | string | null
    initialCompletedAt?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    initialStrengths?: StringNullableFilter<"Portfolio"> | string | null
    initialWeaknesses?: StringNullableFilter<"Portfolio"> | string | null
    initialChallenges?: StringNullableFilter<"Portfolio"> | string | null
    initialStartupIdeas?: StringNullableFilter<"Portfolio"> | string | null
    initialPersonalNotes?: StringNullableFilter<"Portfolio"> | string | null
    finalGoalsAchieved?: IntNullableFilter<"Portfolio"> | number | null
    finalSkillsGained?: StringNullableFilter<"Portfolio"> | string | null
    finalMentorFeedback?: StringNullableFilter<"Portfolio"> | string | null
    finalSelfAssessment?: StringNullableFilter<"Portfolio"> | string | null
    finalRecommendations?: StringNullableFilter<"Portfolio"> | string | null
    finalStrengths?: StringNullableFilter<"Portfolio"> | string | null
    finalWeaknesses?: StringNullableFilter<"Portfolio"> | string | null
    finalChallenges?: StringNullableFilter<"Portfolio"> | string | null
    finalStartupIdeas?: StringNullableFilter<"Portfolio"> | string | null
    finalPersonalNotes?: StringNullableFilter<"Portfolio"> | string | null
    finalCompletedAt?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PortfolioOrderByWithRelationInput = {
    id?: SortOrder
    menteeId?: SortOrder
    personalityMbti?: SortOrderInput | SortOrder
    personalityDisc?: SortOrderInput | SortOrder
    personalityHolland?: SortOrderInput | SortOrder
    competencies?: SortOrderInput | SortOrder
    shortTermGoals?: SortOrderInput | SortOrder
    longTermGoals?: SortOrderInput | SortOrder
    initialCompletedAt?: SortOrderInput | SortOrder
    initialStrengths?: SortOrderInput | SortOrder
    initialWeaknesses?: SortOrderInput | SortOrder
    initialChallenges?: SortOrderInput | SortOrder
    initialStartupIdeas?: SortOrderInput | SortOrder
    initialPersonalNotes?: SortOrderInput | SortOrder
    finalGoalsAchieved?: SortOrderInput | SortOrder
    finalSkillsGained?: SortOrderInput | SortOrder
    finalMentorFeedback?: SortOrderInput | SortOrder
    finalSelfAssessment?: SortOrderInput | SortOrder
    finalRecommendations?: SortOrderInput | SortOrder
    finalStrengths?: SortOrderInput | SortOrder
    finalWeaknesses?: SortOrderInput | SortOrder
    finalChallenges?: SortOrderInput | SortOrder
    finalStartupIdeas?: SortOrderInput | SortOrder
    finalPersonalNotes?: SortOrderInput | SortOrder
    finalCompletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mentee?: UserOrderByWithRelationInput
  }

  export type PortfolioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    menteeId?: StringFilter<"Portfolio"> | string
    personalityMbti?: StringNullableFilter<"Portfolio"> | string | null
    personalityDisc?: StringNullableFilter<"Portfolio"> | string | null
    personalityHolland?: StringNullableFilter<"Portfolio"> | string | null
    competencies?: StringNullableFilter<"Portfolio"> | string | null
    shortTermGoals?: StringNullableFilter<"Portfolio"> | string | null
    longTermGoals?: StringNullableFilter<"Portfolio"> | string | null
    initialCompletedAt?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    initialStrengths?: StringNullableFilter<"Portfolio"> | string | null
    initialWeaknesses?: StringNullableFilter<"Portfolio"> | string | null
    initialChallenges?: StringNullableFilter<"Portfolio"> | string | null
    initialStartupIdeas?: StringNullableFilter<"Portfolio"> | string | null
    initialPersonalNotes?: StringNullableFilter<"Portfolio"> | string | null
    finalGoalsAchieved?: IntNullableFilter<"Portfolio"> | number | null
    finalSkillsGained?: StringNullableFilter<"Portfolio"> | string | null
    finalMentorFeedback?: StringNullableFilter<"Portfolio"> | string | null
    finalSelfAssessment?: StringNullableFilter<"Portfolio"> | string | null
    finalRecommendations?: StringNullableFilter<"Portfolio"> | string | null
    finalStrengths?: StringNullableFilter<"Portfolio"> | string | null
    finalWeaknesses?: StringNullableFilter<"Portfolio"> | string | null
    finalChallenges?: StringNullableFilter<"Portfolio"> | string | null
    finalStartupIdeas?: StringNullableFilter<"Portfolio"> | string | null
    finalPersonalNotes?: StringNullableFilter<"Portfolio"> | string | null
    finalCompletedAt?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PortfolioOrderByWithAggregationInput = {
    id?: SortOrder
    menteeId?: SortOrder
    personalityMbti?: SortOrderInput | SortOrder
    personalityDisc?: SortOrderInput | SortOrder
    personalityHolland?: SortOrderInput | SortOrder
    competencies?: SortOrderInput | SortOrder
    shortTermGoals?: SortOrderInput | SortOrder
    longTermGoals?: SortOrderInput | SortOrder
    initialCompletedAt?: SortOrderInput | SortOrder
    initialStrengths?: SortOrderInput | SortOrder
    initialWeaknesses?: SortOrderInput | SortOrder
    initialChallenges?: SortOrderInput | SortOrder
    initialStartupIdeas?: SortOrderInput | SortOrder
    initialPersonalNotes?: SortOrderInput | SortOrder
    finalGoalsAchieved?: SortOrderInput | SortOrder
    finalSkillsGained?: SortOrderInput | SortOrder
    finalMentorFeedback?: SortOrderInput | SortOrder
    finalSelfAssessment?: SortOrderInput | SortOrder
    finalRecommendations?: SortOrderInput | SortOrder
    finalStrengths?: SortOrderInput | SortOrder
    finalWeaknesses?: SortOrderInput | SortOrder
    finalChallenges?: SortOrderInput | SortOrder
    finalStartupIdeas?: SortOrderInput | SortOrder
    finalPersonalNotes?: SortOrderInput | SortOrder
    finalCompletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioCountOrderByAggregateInput
    _avg?: PortfolioAvgOrderByAggregateInput
    _max?: PortfolioMaxOrderByAggregateInput
    _min?: PortfolioMinOrderByAggregateInput
    _sum?: PortfolioSumOrderByAggregateInput
  }

  export type PortfolioScalarWhereWithAggregatesInput = {
    AND?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    OR?: PortfolioScalarWhereWithAggregatesInput[]
    NOT?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Portfolio"> | string
    menteeId?: StringWithAggregatesFilter<"Portfolio"> | string
    personalityMbti?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    personalityDisc?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    personalityHolland?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    competencies?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    shortTermGoals?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    longTermGoals?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    initialCompletedAt?: DateTimeNullableWithAggregatesFilter<"Portfolio"> | Date | string | null
    initialStrengths?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    initialWeaknesses?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    initialChallenges?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    initialStartupIdeas?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    initialPersonalNotes?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalGoalsAchieved?: IntNullableWithAggregatesFilter<"Portfolio"> | number | null
    finalSkillsGained?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalMentorFeedback?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalSelfAssessment?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalRecommendations?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalStrengths?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalWeaknesses?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalChallenges?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalStartupIdeas?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalPersonalNotes?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    finalCompletedAt?: DateTimeNullableWithAggregatesFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
  }

  export type AvailabilityWhereInput = {
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    id?: StringFilter<"Availability"> | string
    userId?: StringFilter<"Availability"> | string
    dayOfWeek?: IntFilter<"Availability"> | number
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    duration?: IntFilter<"Availability"> | number
    isActive?: BoolFilter<"Availability"> | boolean
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    userId?: StringFilter<"Availability"> | string
    dayOfWeek?: IntFilter<"Availability"> | number
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    duration?: IntFilter<"Availability"> | number
    isActive?: BoolFilter<"Availability"> | boolean
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvailabilityCountOrderByAggregateInput
    _avg?: AvailabilityAvgOrderByAggregateInput
    _max?: AvailabilityMaxOrderByAggregateInput
    _min?: AvailabilityMinOrderByAggregateInput
    _sum?: AvailabilitySumOrderByAggregateInput
  }

  export type AvailabilityScalarWhereWithAggregatesInput = {
    AND?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    OR?: AvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Availability"> | string
    userId?: StringWithAggregatesFilter<"Availability"> | string
    dayOfWeek?: IntWithAggregatesFilter<"Availability"> | number
    startTime?: StringWithAggregatesFilter<"Availability"> | string
    endTime?: StringWithAggregatesFilter<"Availability"> | string
    duration?: IntWithAggregatesFilter<"Availability"> | number
    isActive?: BoolWithAggregatesFilter<"Availability"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SessionReflectionWhereInput = {
    AND?: SessionReflectionWhereInput | SessionReflectionWhereInput[]
    OR?: SessionReflectionWhereInput[]
    NOT?: SessionReflectionWhereInput | SessionReflectionWhereInput[]
    id?: StringFilter<"SessionReflection"> | string
    meetingId?: StringFilter<"SessionReflection"> | string
    menteeId?: StringFilter<"SessionReflection"> | string
    content?: StringNullableFilter<"SessionReflection"> | string | null
    mentorConfirmed?: BoolFilter<"SessionReflection"> | boolean
    createdAt?: DateTimeFilter<"SessionReflection"> | Date | string
    updatedAt?: DateTimeFilter<"SessionReflection"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
    todoItems?: TodoItemListRelationFilter
  }

  export type SessionReflectionOrderByWithRelationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    menteeId?: SortOrder
    content?: SortOrderInput | SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meeting?: MeetingOrderByWithRelationInput
    mentee?: UserOrderByWithRelationInput
    todoItems?: TodoItemOrderByRelationAggregateInput
  }

  export type SessionReflectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    meetingId_menteeId?: SessionReflectionMeetingIdMenteeIdCompoundUniqueInput
    AND?: SessionReflectionWhereInput | SessionReflectionWhereInput[]
    OR?: SessionReflectionWhereInput[]
    NOT?: SessionReflectionWhereInput | SessionReflectionWhereInput[]
    meetingId?: StringFilter<"SessionReflection"> | string
    menteeId?: StringFilter<"SessionReflection"> | string
    content?: StringNullableFilter<"SessionReflection"> | string | null
    mentorConfirmed?: BoolFilter<"SessionReflection"> | boolean
    createdAt?: DateTimeFilter<"SessionReflection"> | Date | string
    updatedAt?: DateTimeFilter<"SessionReflection"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
    todoItems?: TodoItemListRelationFilter
  }, "id" | "meetingId_menteeId">

  export type SessionReflectionOrderByWithAggregationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    menteeId?: SortOrder
    content?: SortOrderInput | SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionReflectionCountOrderByAggregateInput
    _max?: SessionReflectionMaxOrderByAggregateInput
    _min?: SessionReflectionMinOrderByAggregateInput
  }

  export type SessionReflectionScalarWhereWithAggregatesInput = {
    AND?: SessionReflectionScalarWhereWithAggregatesInput | SessionReflectionScalarWhereWithAggregatesInput[]
    OR?: SessionReflectionScalarWhereWithAggregatesInput[]
    NOT?: SessionReflectionScalarWhereWithAggregatesInput | SessionReflectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionReflection"> | string
    meetingId?: StringWithAggregatesFilter<"SessionReflection"> | string
    menteeId?: StringWithAggregatesFilter<"SessionReflection"> | string
    content?: StringNullableWithAggregatesFilter<"SessionReflection"> | string | null
    mentorConfirmed?: BoolWithAggregatesFilter<"SessionReflection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SessionReflection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SessionReflection"> | Date | string
  }

  export type TodoItemWhereInput = {
    AND?: TodoItemWhereInput | TodoItemWhereInput[]
    OR?: TodoItemWhereInput[]
    NOT?: TodoItemWhereInput | TodoItemWhereInput[]
    id?: StringFilter<"TodoItem"> | string
    reflectionId?: StringNullableFilter<"TodoItem"> | string | null
    menteeId?: StringFilter<"TodoItem"> | string
    title?: StringFilter<"TodoItem"> | string
    status?: StringFilter<"TodoItem"> | string
    priority?: StringFilter<"TodoItem"> | string
    dueDate?: DateTimeNullableFilter<"TodoItem"> | Date | string | null
    startDate?: DateTimeNullableFilter<"TodoItem"> | Date | string | null
    column?: StringFilter<"TodoItem"> | string
    labels?: StringNullableFilter<"TodoItem"> | string | null
    description?: StringNullableFilter<"TodoItem"> | string | null
    attachments?: StringNullableFilter<"TodoItem"> | string | null
    comments?: StringNullableFilter<"TodoItem"> | string | null
    createdAt?: DateTimeFilter<"TodoItem"> | Date | string
    updatedAt?: DateTimeFilter<"TodoItem"> | Date | string
    reflection?: XOR<SessionReflectionNullableScalarRelationFilter, SessionReflectionWhereInput> | null
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TodoItemOrderByWithRelationInput = {
    id?: SortOrder
    reflectionId?: SortOrderInput | SortOrder
    menteeId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    column?: SortOrder
    labels?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reflection?: SessionReflectionOrderByWithRelationInput
    mentee?: UserOrderByWithRelationInput
  }

  export type TodoItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TodoItemWhereInput | TodoItemWhereInput[]
    OR?: TodoItemWhereInput[]
    NOT?: TodoItemWhereInput | TodoItemWhereInput[]
    reflectionId?: StringNullableFilter<"TodoItem"> | string | null
    menteeId?: StringFilter<"TodoItem"> | string
    title?: StringFilter<"TodoItem"> | string
    status?: StringFilter<"TodoItem"> | string
    priority?: StringFilter<"TodoItem"> | string
    dueDate?: DateTimeNullableFilter<"TodoItem"> | Date | string | null
    startDate?: DateTimeNullableFilter<"TodoItem"> | Date | string | null
    column?: StringFilter<"TodoItem"> | string
    labels?: StringNullableFilter<"TodoItem"> | string | null
    description?: StringNullableFilter<"TodoItem"> | string | null
    attachments?: StringNullableFilter<"TodoItem"> | string | null
    comments?: StringNullableFilter<"TodoItem"> | string | null
    createdAt?: DateTimeFilter<"TodoItem"> | Date | string
    updatedAt?: DateTimeFilter<"TodoItem"> | Date | string
    reflection?: XOR<SessionReflectionNullableScalarRelationFilter, SessionReflectionWhereInput> | null
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TodoItemOrderByWithAggregationInput = {
    id?: SortOrder
    reflectionId?: SortOrderInput | SortOrder
    menteeId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    column?: SortOrder
    labels?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodoItemCountOrderByAggregateInput
    _max?: TodoItemMaxOrderByAggregateInput
    _min?: TodoItemMinOrderByAggregateInput
  }

  export type TodoItemScalarWhereWithAggregatesInput = {
    AND?: TodoItemScalarWhereWithAggregatesInput | TodoItemScalarWhereWithAggregatesInput[]
    OR?: TodoItemScalarWhereWithAggregatesInput[]
    NOT?: TodoItemScalarWhereWithAggregatesInput | TodoItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TodoItem"> | string
    reflectionId?: StringNullableWithAggregatesFilter<"TodoItem"> | string | null
    menteeId?: StringWithAggregatesFilter<"TodoItem"> | string
    title?: StringWithAggregatesFilter<"TodoItem"> | string
    status?: StringWithAggregatesFilter<"TodoItem"> | string
    priority?: StringWithAggregatesFilter<"TodoItem"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"TodoItem"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"TodoItem"> | Date | string | null
    column?: StringWithAggregatesFilter<"TodoItem"> | string
    labels?: StringNullableWithAggregatesFilter<"TodoItem"> | string | null
    description?: StringNullableWithAggregatesFilter<"TodoItem"> | string | null
    attachments?: StringNullableWithAggregatesFilter<"TodoItem"> | string | null
    comments?: StringNullableWithAggregatesFilter<"TodoItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TodoItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TodoItem"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    entityType?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    entityType?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: TicketCommentListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    comments?: TicketCommentOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: TicketCommentListRelationFilter
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    title?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: StringWithAggregatesFilter<"SupportTicket"> | string
    userId?: StringWithAggregatesFilter<"SupportTicket"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    userId?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    ticket?: SupportTicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    ticketId?: StringFilter<"TicketComment"> | string
    userId?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketComment"> | string
    ticketId?: StringWithAggregatesFilter<"TicketComment"> | string
    userId?: StringWithAggregatesFilter<"TicketComment"> | string
    content?: StringWithAggregatesFilter<"TicketComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
  }

  export type WikiPageWhereInput = {
    AND?: WikiPageWhereInput | WikiPageWhereInput[]
    OR?: WikiPageWhereInput[]
    NOT?: WikiPageWhereInput | WikiPageWhereInput[]
    id?: StringFilter<"WikiPage"> | string
    title?: StringFilter<"WikiPage"> | string
    slug?: StringFilter<"WikiPage"> | string
    content?: StringNullableFilter<"WikiPage"> | string | null
    category?: StringNullableFilter<"WikiPage"> | string | null
    visibility?: StringFilter<"WikiPage"> | string
    authorId?: StringFilter<"WikiPage"> | string
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WikiPageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type WikiPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: WikiPageWhereInput | WikiPageWhereInput[]
    OR?: WikiPageWhereInput[]
    NOT?: WikiPageWhereInput | WikiPageWhereInput[]
    title?: StringFilter<"WikiPage"> | string
    content?: StringNullableFilter<"WikiPage"> | string | null
    category?: StringNullableFilter<"WikiPage"> | string | null
    visibility?: StringFilter<"WikiPage"> | string
    authorId?: StringFilter<"WikiPage"> | string
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type WikiPageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WikiPageCountOrderByAggregateInput
    _max?: WikiPageMaxOrderByAggregateInput
    _min?: WikiPageMinOrderByAggregateInput
  }

  export type WikiPageScalarWhereWithAggregatesInput = {
    AND?: WikiPageScalarWhereWithAggregatesInput | WikiPageScalarWhereWithAggregatesInput[]
    OR?: WikiPageScalarWhereWithAggregatesInput[]
    NOT?: WikiPageScalarWhereWithAggregatesInput | WikiPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WikiPage"> | string
    title?: StringWithAggregatesFilter<"WikiPage"> | string
    slug?: StringWithAggregatesFilter<"WikiPage"> | string
    content?: StringNullableWithAggregatesFilter<"WikiPage"> | string | null
    category?: StringNullableWithAggregatesFilter<"WikiPage"> | string | null
    visibility?: StringWithAggregatesFilter<"WikiPage"> | string
    authorId?: StringWithAggregatesFilter<"WikiPage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WikiPage"> | Date | string
  }

  export type WhiteboardWhereInput = {
    AND?: WhiteboardWhereInput | WhiteboardWhereInput[]
    OR?: WhiteboardWhereInput[]
    NOT?: WhiteboardWhereInput | WhiteboardWhereInput[]
    id?: StringFilter<"Whiteboard"> | string
    title?: StringFilter<"Whiteboard"> | string
    description?: StringNullableFilter<"Whiteboard"> | string | null
    thumbnail?: StringNullableFilter<"Whiteboard"> | string | null
    status?: StringFilter<"Whiteboard"> | string
    creatorId?: StringFilter<"Whiteboard"> | string
    createdAt?: DateTimeFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeFilter<"Whiteboard"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    artboards?: ArtboardListRelationFilter
  }

  export type WhiteboardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    artboards?: ArtboardOrderByRelationAggregateInput
  }

  export type WhiteboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhiteboardWhereInput | WhiteboardWhereInput[]
    OR?: WhiteboardWhereInput[]
    NOT?: WhiteboardWhereInput | WhiteboardWhereInput[]
    title?: StringFilter<"Whiteboard"> | string
    description?: StringNullableFilter<"Whiteboard"> | string | null
    thumbnail?: StringNullableFilter<"Whiteboard"> | string | null
    status?: StringFilter<"Whiteboard"> | string
    creatorId?: StringFilter<"Whiteboard"> | string
    createdAt?: DateTimeFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeFilter<"Whiteboard"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    artboards?: ArtboardListRelationFilter
  }, "id">

  export type WhiteboardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhiteboardCountOrderByAggregateInput
    _max?: WhiteboardMaxOrderByAggregateInput
    _min?: WhiteboardMinOrderByAggregateInput
  }

  export type WhiteboardScalarWhereWithAggregatesInput = {
    AND?: WhiteboardScalarWhereWithAggregatesInput | WhiteboardScalarWhereWithAggregatesInput[]
    OR?: WhiteboardScalarWhereWithAggregatesInput[]
    NOT?: WhiteboardScalarWhereWithAggregatesInput | WhiteboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Whiteboard"> | string
    title?: StringWithAggregatesFilter<"Whiteboard"> | string
    description?: StringNullableWithAggregatesFilter<"Whiteboard"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"Whiteboard"> | string | null
    status?: StringWithAggregatesFilter<"Whiteboard"> | string
    creatorId?: StringWithAggregatesFilter<"Whiteboard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Whiteboard"> | Date | string
  }

  export type ArtboardWhereInput = {
    AND?: ArtboardWhereInput | ArtboardWhereInput[]
    OR?: ArtboardWhereInput[]
    NOT?: ArtboardWhereInput | ArtboardWhereInput[]
    id?: StringFilter<"Artboard"> | string
    whiteboardId?: StringFilter<"Artboard"> | string
    order?: IntFilter<"Artboard"> | number
    name?: StringNullableFilter<"Artboard"> | string | null
    elements?: JsonNullableFilter<"Artboard">
    appState?: JsonNullableFilter<"Artboard">
    createdAt?: DateTimeFilter<"Artboard"> | Date | string
    updatedAt?: DateTimeFilter<"Artboard"> | Date | string
    whiteboard?: XOR<WhiteboardScalarRelationFilter, WhiteboardWhereInput>
  }

  export type ArtboardOrderByWithRelationInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    order?: SortOrder
    name?: SortOrderInput | SortOrder
    elements?: SortOrderInput | SortOrder
    appState?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whiteboard?: WhiteboardOrderByWithRelationInput
  }

  export type ArtboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArtboardWhereInput | ArtboardWhereInput[]
    OR?: ArtboardWhereInput[]
    NOT?: ArtboardWhereInput | ArtboardWhereInput[]
    whiteboardId?: StringFilter<"Artboard"> | string
    order?: IntFilter<"Artboard"> | number
    name?: StringNullableFilter<"Artboard"> | string | null
    elements?: JsonNullableFilter<"Artboard">
    appState?: JsonNullableFilter<"Artboard">
    createdAt?: DateTimeFilter<"Artboard"> | Date | string
    updatedAt?: DateTimeFilter<"Artboard"> | Date | string
    whiteboard?: XOR<WhiteboardScalarRelationFilter, WhiteboardWhereInput>
  }, "id">

  export type ArtboardOrderByWithAggregationInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    order?: SortOrder
    name?: SortOrderInput | SortOrder
    elements?: SortOrderInput | SortOrder
    appState?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArtboardCountOrderByAggregateInput
    _avg?: ArtboardAvgOrderByAggregateInput
    _max?: ArtboardMaxOrderByAggregateInput
    _min?: ArtboardMinOrderByAggregateInput
    _sum?: ArtboardSumOrderByAggregateInput
  }

  export type ArtboardScalarWhereWithAggregatesInput = {
    AND?: ArtboardScalarWhereWithAggregatesInput | ArtboardScalarWhereWithAggregatesInput[]
    OR?: ArtboardScalarWhereWithAggregatesInput[]
    NOT?: ArtboardScalarWhereWithAggregatesInput | ArtboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Artboard"> | string
    whiteboardId?: StringWithAggregatesFilter<"Artboard"> | string
    order?: IntWithAggregatesFilter<"Artboard"> | number
    name?: StringNullableWithAggregatesFilter<"Artboard"> | string | null
    elements?: JsonNullableWithAggregatesFilter<"Artboard">
    appState?: JsonNullableWithAggregatesFilter<"Artboard">
    createdAt?: DateTimeWithAggregatesFilter<"Artboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Artboard"> | Date | string
  }

  export type SlideWhereInput = {
    AND?: SlideWhereInput | SlideWhereInput[]
    OR?: SlideWhereInput[]
    NOT?: SlideWhereInput | SlideWhereInput[]
    id?: StringFilter<"Slide"> | string
    title?: StringFilter<"Slide"> | string
    description?: StringNullableFilter<"Slide"> | string | null
    content?: StringNullableFilter<"Slide"> | string | null
    theme?: StringFilter<"Slide"> | string
    status?: StringFilter<"Slide"> | string
    creatorId?: StringFilter<"Slide"> | string
    createdAt?: DateTimeFilter<"Slide"> | Date | string
    updatedAt?: DateTimeFilter<"Slide"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SlideOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    theme?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type SlideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SlideWhereInput | SlideWhereInput[]
    OR?: SlideWhereInput[]
    NOT?: SlideWhereInput | SlideWhereInput[]
    title?: StringFilter<"Slide"> | string
    description?: StringNullableFilter<"Slide"> | string | null
    content?: StringNullableFilter<"Slide"> | string | null
    theme?: StringFilter<"Slide"> | string
    status?: StringFilter<"Slide"> | string
    creatorId?: StringFilter<"Slide"> | string
    createdAt?: DateTimeFilter<"Slide"> | Date | string
    updatedAt?: DateTimeFilter<"Slide"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SlideOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    theme?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SlideCountOrderByAggregateInput
    _max?: SlideMaxOrderByAggregateInput
    _min?: SlideMinOrderByAggregateInput
  }

  export type SlideScalarWhereWithAggregatesInput = {
    AND?: SlideScalarWhereWithAggregatesInput | SlideScalarWhereWithAggregatesInput[]
    OR?: SlideScalarWhereWithAggregatesInput[]
    NOT?: SlideScalarWhereWithAggregatesInput | SlideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Slide"> | string
    title?: StringWithAggregatesFilter<"Slide"> | string
    description?: StringNullableWithAggregatesFilter<"Slide"> | string | null
    content?: StringNullableWithAggregatesFilter<"Slide"> | string | null
    theme?: StringWithAggregatesFilter<"Slide"> | string
    status?: StringWithAggregatesFilter<"Slide"> | string
    creatorId?: StringWithAggregatesFilter<"Slide"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Slide"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Slide"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorProfileCreateInput = {
    id?: string
    company?: string | null
    jobTitle?: string | null
    expertise?: string | null
    experience?: string | null
    linkedIn?: string | null
    maxMentees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMentorProfileInput
  }

  export type MentorProfileUncheckedCreateInput = {
    id?: string
    userId: string
    company?: string | null
    jobTitle?: string | null
    expertise?: string | null
    experience?: string | null
    linkedIn?: string | null
    maxMentees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    linkedIn?: NullableStringFieldUpdateOperationsInput | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentorProfileNestedInput
  }

  export type MentorProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    linkedIn?: NullableStringFieldUpdateOperationsInput | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorProfileCreateManyInput = {
    id?: string
    userId: string
    company?: string | null
    jobTitle?: string | null
    expertise?: string | null
    experience?: string | null
    linkedIn?: string | null
    maxMentees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    linkedIn?: NullableStringFieldUpdateOperationsInput | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    linkedIn?: NullableStringFieldUpdateOperationsInput | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeProfileCreateInput = {
    id?: string
    studentId?: string | null
    major?: string | null
    year?: number | null
    careerGoals?: string | null
    skills?: string | null
    strengths?: string | null
    weaknesses?: string | null
    currentChallenges?: string | null
    expectations?: string | null
    background?: string | null
    experience?: string | null
    endGoals?: string | null
    startupIdeas?: string | null
    personalNotes?: string | null
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMenteeProfileInput
  }

  export type MenteeProfileUncheckedCreateInput = {
    id?: string
    userId: string
    studentId?: string | null
    major?: string | null
    year?: number | null
    careerGoals?: string | null
    skills?: string | null
    strengths?: string | null
    weaknesses?: string | null
    currentChallenges?: string | null
    expectations?: string | null
    background?: string | null
    experience?: string | null
    endGoals?: string | null
    startupIdeas?: string | null
    personalNotes?: string | null
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenteeProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    careerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    endGoals?: NullableStringFieldUpdateOperationsInput | string | null
    startupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    personalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMenteeProfileNestedInput
  }

  export type MenteeProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    careerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    endGoals?: NullableStringFieldUpdateOperationsInput | string | null
    startupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    personalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeProfileCreateManyInput = {
    id?: string
    userId: string
    studentId?: string | null
    major?: string | null
    year?: number | null
    careerGoals?: string | null
    skills?: string | null
    strengths?: string | null
    weaknesses?: string | null
    currentChallenges?: string | null
    expectations?: string | null
    background?: string | null
    experience?: string | null
    endGoals?: string | null
    startupIdeas?: string | null
    personalNotes?: string | null
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenteeProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    careerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    endGoals?: NullableStringFieldUpdateOperationsInput | string | null
    startupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    personalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    careerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    endGoals?: NullableStringFieldUpdateOperationsInput | string | null
    startupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    personalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCycleCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorships?: MentorshipCreateNestedManyWithoutProgramCycleInput
  }

  export type ProgramCycleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutProgramCycleInput
  }

  export type ProgramCycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorships?: MentorshipUpdateManyWithoutProgramCycleNestedInput
  }

  export type ProgramCycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorships?: MentorshipUncheckedUpdateManyWithoutProgramCycleNestedInput
  }

  export type ProgramCycleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipCreateInput = {
    id?: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentor: UserCreateNestedOneWithoutMentorshipsInput
    programCycle: ProgramCycleCreateNestedOneWithoutMentorshipsInput
    mentees?: MentorshipMenteeCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingCreateNestedManyWithoutMentorshipInput
    goals?: GoalCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUncheckedCreateInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentees?: MentorshipMenteeUncheckedCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutMentorshipInput
    goals?: GoalUncheckedCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor?: UserUpdateOneRequiredWithoutMentorshipsNestedInput
    programCycle?: ProgramCycleUpdateOneRequiredWithoutMentorshipsNestedInput
    mentees?: MentorshipMenteeUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentees?: MentorshipMenteeUncheckedUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUncheckedUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipCreateManyInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipMenteeCreateInput = {
    id?: string
    joinedAt?: Date | string
    status?: string
    mentorship: MentorshipCreateNestedOneWithoutMenteesInput
    mentee: UserCreateNestedOneWithoutMenteeshipsInput
  }

  export type MentorshipMenteeUncheckedCreateInput = {
    id?: string
    mentorshipId: string
    menteeId: string
    joinedAt?: Date | string
    status?: string
  }

  export type MentorshipMenteeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    mentorship?: MentorshipUpdateOneRequiredWithoutMenteesNestedInput
    mentee?: UserUpdateOneRequiredWithoutMenteeshipsNestedInput
  }

  export type MentorshipMenteeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MentorshipMenteeCreateManyInput = {
    id?: string
    mentorshipId: string
    menteeId: string
    joinedAt?: Date | string
    status?: string
  }

  export type MentorshipMenteeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MentorshipMenteeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutMeetingsInput
    creator: UserCreateNestedOneWithoutMeetingsCreatedInput
    attendances?: AttendanceCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesUncheckedCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutMeetingsNestedInput
    creator?: UserUpdateOneRequiredWithoutMeetingsCreatedNestedInput
    attendances?: AttendanceUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUncheckedUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingCreateManyInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutAttendancesInput
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    meetingId: string
    userId: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutAttendancesNestedInput
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    meetingId: string
    userId: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingMinutesCreateInput = {
    id?: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutMinutesInput
    author: UserCreateNestedOneWithoutMinutesCreatedInput
  }

  export type MeetingMinutesUncheckedCreateInput = {
    id?: string
    meetingId: string
    authorId: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingMinutesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutMinutesNestedInput
    author?: UserUpdateOneRequiredWithoutMinutesCreatedNestedInput
  }

  export type MeetingMinutesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingMinutesCreateManyInput = {
    id?: string
    meetingId: string
    authorId: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingMinutesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingMinutesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutGoalsInput
    creator: UserCreateNestedOneWithoutGoalsCreatedInput
    progressNotes?: ProgressNoteCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    progressNotes?: ProgressNoteUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutGoalsNestedInput
    creator?: UserUpdateOneRequiredWithoutGoalsCreatedNestedInput
    progressNotes?: ProgressNoteUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressNotes?: ProgressNoteUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalCreateManyInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressNoteCreateInput = {
    id?: string
    note: string
    value?: number | null
    createdAt?: Date | string
    goal: GoalCreateNestedOneWithoutProgressNotesInput
  }

  export type ProgressNoteUncheckedCreateInput = {
    id?: string
    goalId: string
    note: string
    value?: number | null
    createdAt?: Date | string
  }

  export type ProgressNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutProgressNotesNestedInput
  }

  export type ProgressNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressNoteCreateManyInput = {
    id?: string
    goalId: string
    note: string
    value?: number | null
    createdAt?: Date | string
  }

  export type ProgressNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    id?: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutFeedbacksInput
    fromUser: UserCreateNestedOneWithoutFeedbackGivenInput
    toUser: UserCreateNestedOneWithoutFeedbackReceivedInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    mentorshipId: string
    fromUserId: string
    toUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutFeedbacksNestedInput
    fromUser?: UserUpdateOneRequiredWithoutFeedbackGivenNestedInput
    toUser?: UserUpdateOneRequiredWithoutFeedbackReceivedNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    mentorshipId: string
    fromUserId: string
    toUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    fileUrl?: string | null
    linkUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    category?: string | null
    tags?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutResourcesUploadedInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    fileUrl?: string | null
    linkUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    category?: string | null
    tags?: string | null
    visibility?: string
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutResourcesUploadedNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    fileUrl?: string | null
    linkUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    category?: string | null
    tags?: string | null
    visibility?: string
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCreateInput = {
    id?: string
    personalityMbti?: string | null
    personalityDisc?: string | null
    personalityHolland?: string | null
    competencies?: string | null
    shortTermGoals?: string | null
    longTermGoals?: string | null
    initialCompletedAt?: Date | string | null
    initialStrengths?: string | null
    initialWeaknesses?: string | null
    initialChallenges?: string | null
    initialStartupIdeas?: string | null
    initialPersonalNotes?: string | null
    finalGoalsAchieved?: number | null
    finalSkillsGained?: string | null
    finalMentorFeedback?: string | null
    finalSelfAssessment?: string | null
    finalRecommendations?: string | null
    finalStrengths?: string | null
    finalWeaknesses?: string | null
    finalChallenges?: string | null
    finalStartupIdeas?: string | null
    finalPersonalNotes?: string | null
    finalCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentee: UserCreateNestedOneWithoutPortfoliosInput
  }

  export type PortfolioUncheckedCreateInput = {
    id?: string
    menteeId: string
    personalityMbti?: string | null
    personalityDisc?: string | null
    personalityHolland?: string | null
    competencies?: string | null
    shortTermGoals?: string | null
    longTermGoals?: string | null
    initialCompletedAt?: Date | string | null
    initialStrengths?: string | null
    initialWeaknesses?: string | null
    initialChallenges?: string | null
    initialStartupIdeas?: string | null
    initialPersonalNotes?: string | null
    finalGoalsAchieved?: number | null
    finalSkillsGained?: string | null
    finalMentorFeedback?: string | null
    finalSelfAssessment?: string | null
    finalRecommendations?: string | null
    finalStrengths?: string | null
    finalWeaknesses?: string | null
    finalChallenges?: string | null
    finalStartupIdeas?: string | null
    finalPersonalNotes?: string | null
    finalCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personalityMbti?: NullableStringFieldUpdateOperationsInput | string | null
    personalityDisc?: NullableStringFieldUpdateOperationsInput | string | null
    personalityHolland?: NullableStringFieldUpdateOperationsInput | string | null
    competencies?: NullableStringFieldUpdateOperationsInput | string | null
    shortTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    longTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    initialCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    initialWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    initialChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    initialStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    initialPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalGoalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    finalSkillsGained?: NullableStringFieldUpdateOperationsInput | string | null
    finalMentorFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    finalSelfAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    finalRecommendations?: NullableStringFieldUpdateOperationsInput | string | null
    finalStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    finalWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    finalChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    finalStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    finalPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
  }

  export type PortfolioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    personalityMbti?: NullableStringFieldUpdateOperationsInput | string | null
    personalityDisc?: NullableStringFieldUpdateOperationsInput | string | null
    personalityHolland?: NullableStringFieldUpdateOperationsInput | string | null
    competencies?: NullableStringFieldUpdateOperationsInput | string | null
    shortTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    longTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    initialCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    initialWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    initialChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    initialStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    initialPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalGoalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    finalSkillsGained?: NullableStringFieldUpdateOperationsInput | string | null
    finalMentorFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    finalSelfAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    finalRecommendations?: NullableStringFieldUpdateOperationsInput | string | null
    finalStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    finalWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    finalChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    finalStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    finalPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCreateManyInput = {
    id?: string
    menteeId: string
    personalityMbti?: string | null
    personalityDisc?: string | null
    personalityHolland?: string | null
    competencies?: string | null
    shortTermGoals?: string | null
    longTermGoals?: string | null
    initialCompletedAt?: Date | string | null
    initialStrengths?: string | null
    initialWeaknesses?: string | null
    initialChallenges?: string | null
    initialStartupIdeas?: string | null
    initialPersonalNotes?: string | null
    finalGoalsAchieved?: number | null
    finalSkillsGained?: string | null
    finalMentorFeedback?: string | null
    finalSelfAssessment?: string | null
    finalRecommendations?: string | null
    finalStrengths?: string | null
    finalWeaknesses?: string | null
    finalChallenges?: string | null
    finalStartupIdeas?: string | null
    finalPersonalNotes?: string | null
    finalCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    personalityMbti?: NullableStringFieldUpdateOperationsInput | string | null
    personalityDisc?: NullableStringFieldUpdateOperationsInput | string | null
    personalityHolland?: NullableStringFieldUpdateOperationsInput | string | null
    competencies?: NullableStringFieldUpdateOperationsInput | string | null
    shortTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    longTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    initialCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    initialWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    initialChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    initialStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    initialPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalGoalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    finalSkillsGained?: NullableStringFieldUpdateOperationsInput | string | null
    finalMentorFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    finalSelfAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    finalRecommendations?: NullableStringFieldUpdateOperationsInput | string | null
    finalStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    finalWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    finalChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    finalStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    finalPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    personalityMbti?: NullableStringFieldUpdateOperationsInput | string | null
    personalityDisc?: NullableStringFieldUpdateOperationsInput | string | null
    personalityHolland?: NullableStringFieldUpdateOperationsInput | string | null
    competencies?: NullableStringFieldUpdateOperationsInput | string | null
    shortTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    longTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    initialCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    initialWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    initialChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    initialStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    initialPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalGoalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    finalSkillsGained?: NullableStringFieldUpdateOperationsInput | string | null
    finalMentorFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    finalSelfAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    finalRecommendations?: NullableStringFieldUpdateOperationsInput | string | null
    finalStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    finalWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    finalChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    finalStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    finalPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAvailabilitiesInput
  }

  export type AvailabilityUncheckedCreateInput = {
    id?: string
    userId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAvailabilitiesNestedInput
  }

  export type AvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateManyInput = {
    id?: string
    userId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: string
    link?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: string
    link?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: string
    link?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionReflectionCreateInput = {
    id?: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutSessionReflectionsInput
    mentee: UserCreateNestedOneWithoutSessionReflectionsInput
    todoItems?: TodoItemCreateNestedManyWithoutReflectionInput
  }

  export type SessionReflectionUncheckedCreateInput = {
    id?: string
    meetingId: string
    menteeId: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutReflectionInput
  }

  export type SessionReflectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutSessionReflectionsNestedInput
    mentee?: UserUpdateOneRequiredWithoutSessionReflectionsNestedInput
    todoItems?: TodoItemUpdateManyWithoutReflectionNestedInput
  }

  export type SessionReflectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    todoItems?: TodoItemUncheckedUpdateManyWithoutReflectionNestedInput
  }

  export type SessionReflectionCreateManyInput = {
    id?: string
    meetingId: string
    menteeId: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionReflectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionReflectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemCreateInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reflection?: SessionReflectionCreateNestedOneWithoutTodoItemsInput
    mentee: UserCreateNestedOneWithoutTodoItemsInput
  }

  export type TodoItemUncheckedCreateInput = {
    id?: string
    reflectionId?: string | null
    menteeId: string
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reflection?: SessionReflectionUpdateOneWithoutTodoItemsNestedInput
    mentee?: UserUpdateOneRequiredWithoutTodoItemsNestedInput
  }

  export type TodoItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reflectionId?: NullableStringFieldUpdateOperationsInput | string | null
    menteeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemCreateManyInput = {
    id?: string
    reflectionId?: string | null
    menteeId: string
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reflectionId?: NullableStringFieldUpdateOperationsInput | string | null
    menteeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: string
    entityId?: string | null
    entityType?: string | null
    metadata?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityId?: string | null
    entityType?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityId?: string | null
    entityType?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsCreatedInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    userId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsCreatedNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    userId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: string
    ticketId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TicketCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateManyInput = {
    id?: string
    ticketId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TicketCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageCreateInput = {
    id?: string
    title: string
    slug: string
    content?: string | null
    category?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWikiPagesInput
  }

  export type WikiPageUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content?: string | null
    category?: string | null
    visibility?: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWikiPagesNestedInput
  }

  export type WikiPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageCreateManyInput = {
    id?: string
    title: string
    slug: string
    content?: string | null
    category?: string | null
    visibility?: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardCreateInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutWhiteboardsInput
    artboards?: ArtboardCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    artboards?: ArtboardUncheckedCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutWhiteboardsNestedInput
    artboards?: ArtboardUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artboards?: ArtboardUncheckedUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhiteboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtboardCreateInput = {
    id?: string
    order?: number
    name?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    whiteboard: WhiteboardCreateNestedOneWithoutArtboardsInput
  }

  export type ArtboardUncheckedCreateInput = {
    id?: string
    whiteboardId: string
    order?: number
    name?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whiteboard?: WhiteboardUpdateOneRequiredWithoutArtboardsNestedInput
  }

  export type ArtboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whiteboardId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtboardCreateManyInput = {
    id?: string
    whiteboardId: string
    order?: number
    name?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    whiteboardId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlideCreateInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    theme?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSlidesInput
  }

  export type SlideUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    theme?: string
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSlidesNestedInput
  }

  export type SlideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlideCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    theme?: string
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MentorProfileNullableScalarRelationFilter = {
    is?: MentorProfileWhereInput | null
    isNot?: MentorProfileWhereInput | null
  }

  export type MenteeProfileNullableScalarRelationFilter = {
    is?: MenteeProfileWhereInput | null
    isNot?: MenteeProfileWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type MentorshipListRelationFilter = {
    every?: MentorshipWhereInput
    some?: MentorshipWhereInput
    none?: MentorshipWhereInput
  }

  export type MentorshipMenteeListRelationFilter = {
    every?: MentorshipMenteeWhereInput
    some?: MentorshipMenteeWhereInput
    none?: MentorshipMenteeWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type MeetingMinutesListRelationFilter = {
    every?: MeetingMinutesWhereInput
    some?: MeetingMinutesWhereInput
    none?: MeetingMinutesWhereInput
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PortfolioListRelationFilter = {
    every?: PortfolioWhereInput
    some?: PortfolioWhereInput
    none?: PortfolioWhereInput
  }

  export type AvailabilityListRelationFilter = {
    every?: AvailabilityWhereInput
    some?: AvailabilityWhereInput
    none?: AvailabilityWhereInput
  }

  export type SessionReflectionListRelationFilter = {
    every?: SessionReflectionWhereInput
    some?: SessionReflectionWhereInput
    none?: SessionReflectionWhereInput
  }

  export type TodoItemListRelationFilter = {
    every?: TodoItemWhereInput
    some?: TodoItemWhereInput
    none?: TodoItemWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type WikiPageListRelationFilter = {
    every?: WikiPageWhereInput
    some?: WikiPageWhereInput
    none?: WikiPageWhereInput
  }

  export type WhiteboardListRelationFilter = {
    every?: WhiteboardWhereInput
    some?: WhiteboardWhereInput
    none?: WhiteboardWhereInput
  }

  export type SlideListRelationFilter = {
    every?: SlideWhereInput
    some?: SlideWhereInput
    none?: SlideWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorshipMenteeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingMinutesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionReflectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TodoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WikiPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhiteboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SlideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type MentorProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    expertise?: SortOrder
    experience?: SortOrder
    linkedIn?: SortOrder
    maxMentees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MentorProfileAvgOrderByAggregateInput = {
    maxMentees?: SortOrder
  }

  export type MentorProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    expertise?: SortOrder
    experience?: SortOrder
    linkedIn?: SortOrder
    maxMentees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MentorProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    expertise?: SortOrder
    experience?: SortOrder
    linkedIn?: SortOrder
    maxMentees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MentorProfileSumOrderByAggregateInput = {
    maxMentees?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type MenteeProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    major?: SortOrder
    year?: SortOrder
    careerGoals?: SortOrder
    skills?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    currentChallenges?: SortOrder
    expectations?: SortOrder
    background?: SortOrder
    experience?: SortOrder
    endGoals?: SortOrder
    startupIdeas?: SortOrder
    personalNotes?: SortOrder
    isOnboardingComplete?: SortOrder
    onboardingCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenteeProfileAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type MenteeProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    major?: SortOrder
    year?: SortOrder
    careerGoals?: SortOrder
    skills?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    currentChallenges?: SortOrder
    expectations?: SortOrder
    background?: SortOrder
    experience?: SortOrder
    endGoals?: SortOrder
    startupIdeas?: SortOrder
    personalNotes?: SortOrder
    isOnboardingComplete?: SortOrder
    onboardingCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenteeProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    major?: SortOrder
    year?: SortOrder
    careerGoals?: SortOrder
    skills?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    currentChallenges?: SortOrder
    expectations?: SortOrder
    background?: SortOrder
    experience?: SortOrder
    endGoals?: SortOrder
    startupIdeas?: SortOrder
    personalNotes?: SortOrder
    isOnboardingComplete?: SortOrder
    onboardingCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenteeProfileSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ProgramCycleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramCycleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramCycleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramCycleScalarRelationFilter = {
    is?: ProgramCycleWhereInput
    isNot?: ProgramCycleWhereInput
  }

  export type MentorshipCountOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    programCycleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MentorshipAvgOrderByAggregateInput = {
    maxMentees?: SortOrder
  }

  export type MentorshipMaxOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    programCycleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MentorshipMinOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    programCycleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MentorshipSumOrderByAggregateInput = {
    maxMentees?: SortOrder
  }

  export type MentorshipScalarRelationFilter = {
    is?: MentorshipWhereInput
    isNot?: MentorshipWhereInput
  }

  export type MentorshipMenteeMentorshipIdMenteeIdCompoundUniqueInput = {
    mentorshipId: string
    menteeId: string
  }

  export type MentorshipMenteeCountOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    menteeId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type MentorshipMenteeMaxOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    menteeId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type MentorshipMenteeMinOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    menteeId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    meetingType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    qrToken?: SortOrder
    qrExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    meetingType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    qrToken?: SortOrder
    qrExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    meetingType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    qrToken?: SortOrder
    qrExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MeetingScalarRelationFilter = {
    is?: MeetingWhereInput
    isNot?: MeetingWhereInput
  }

  export type AttendanceMeetingIdUserIdCompoundUniqueInput = {
    meetingId: string
    userId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    checkInLat?: SortOrder
    checkInLng?: SortOrder
    deviceHash?: SortOrder
    status?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    checkInLat?: SortOrder
    checkInLng?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    checkInLat?: SortOrder
    checkInLng?: SortOrder
    deviceHash?: SortOrder
    status?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    checkInLat?: SortOrder
    checkInLng?: SortOrder
    deviceHash?: SortOrder
    status?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    checkInLat?: SortOrder
    checkInLng?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MeetingMinutesCountOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    authorId?: SortOrder
    agenda?: SortOrder
    keyPoints?: SortOrder
    actionItems?: SortOrder
    outcome?: SortOrder
    attachments?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMinutesMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    authorId?: SortOrder
    agenda?: SortOrder
    keyPoints?: SortOrder
    actionItems?: SortOrder
    outcome?: SortOrder
    attachments?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMinutesMinOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    authorId?: SortOrder
    agenda?: SortOrder
    keyPoints?: SortOrder
    actionItems?: SortOrder
    outcome?: SortOrder
    attachments?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgressNoteListRelationFilter = {
    every?: ProgressNoteWhereInput
    some?: ProgressNoteWhereInput
    none?: ProgressNoteWhereInput
  }

  export type ProgressNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalSumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type GoalScalarRelationFilter = {
    is?: GoalWhereInput
    isNot?: GoalWhereInput
  }

  export type ProgressNoteCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    note?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressNoteAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ProgressNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    note?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressNoteMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    note?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressNoteSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    type?: SortOrder
    rating?: SortOrder
    communication?: SortOrder
    engagement?: SortOrder
    content?: SortOrder
    strengths?: SortOrder
    improvements?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
    communication?: SortOrder
    engagement?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    type?: SortOrder
    rating?: SortOrder
    communication?: SortOrder
    engagement?: SortOrder
    content?: SortOrder
    strengths?: SortOrder
    improvements?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    mentorshipId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    type?: SortOrder
    rating?: SortOrder
    communication?: SortOrder
    engagement?: SortOrder
    content?: SortOrder
    strengths?: SortOrder
    improvements?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
    communication?: SortOrder
    engagement?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    linkUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    linkUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    linkUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type PortfolioCountOrderByAggregateInput = {
    id?: SortOrder
    menteeId?: SortOrder
    personalityMbti?: SortOrder
    personalityDisc?: SortOrder
    personalityHolland?: SortOrder
    competencies?: SortOrder
    shortTermGoals?: SortOrder
    longTermGoals?: SortOrder
    initialCompletedAt?: SortOrder
    initialStrengths?: SortOrder
    initialWeaknesses?: SortOrder
    initialChallenges?: SortOrder
    initialStartupIdeas?: SortOrder
    initialPersonalNotes?: SortOrder
    finalGoalsAchieved?: SortOrder
    finalSkillsGained?: SortOrder
    finalMentorFeedback?: SortOrder
    finalSelfAssessment?: SortOrder
    finalRecommendations?: SortOrder
    finalStrengths?: SortOrder
    finalWeaknesses?: SortOrder
    finalChallenges?: SortOrder
    finalStartupIdeas?: SortOrder
    finalPersonalNotes?: SortOrder
    finalCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioAvgOrderByAggregateInput = {
    finalGoalsAchieved?: SortOrder
  }

  export type PortfolioMaxOrderByAggregateInput = {
    id?: SortOrder
    menteeId?: SortOrder
    personalityMbti?: SortOrder
    personalityDisc?: SortOrder
    personalityHolland?: SortOrder
    competencies?: SortOrder
    shortTermGoals?: SortOrder
    longTermGoals?: SortOrder
    initialCompletedAt?: SortOrder
    initialStrengths?: SortOrder
    initialWeaknesses?: SortOrder
    initialChallenges?: SortOrder
    initialStartupIdeas?: SortOrder
    initialPersonalNotes?: SortOrder
    finalGoalsAchieved?: SortOrder
    finalSkillsGained?: SortOrder
    finalMentorFeedback?: SortOrder
    finalSelfAssessment?: SortOrder
    finalRecommendations?: SortOrder
    finalStrengths?: SortOrder
    finalWeaknesses?: SortOrder
    finalChallenges?: SortOrder
    finalStartupIdeas?: SortOrder
    finalPersonalNotes?: SortOrder
    finalCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioMinOrderByAggregateInput = {
    id?: SortOrder
    menteeId?: SortOrder
    personalityMbti?: SortOrder
    personalityDisc?: SortOrder
    personalityHolland?: SortOrder
    competencies?: SortOrder
    shortTermGoals?: SortOrder
    longTermGoals?: SortOrder
    initialCompletedAt?: SortOrder
    initialStrengths?: SortOrder
    initialWeaknesses?: SortOrder
    initialChallenges?: SortOrder
    initialStartupIdeas?: SortOrder
    initialPersonalNotes?: SortOrder
    finalGoalsAchieved?: SortOrder
    finalSkillsGained?: SortOrder
    finalMentorFeedback?: SortOrder
    finalSelfAssessment?: SortOrder
    finalRecommendations?: SortOrder
    finalStrengths?: SortOrder
    finalWeaknesses?: SortOrder
    finalChallenges?: SortOrder
    finalStartupIdeas?: SortOrder
    finalPersonalNotes?: SortOrder
    finalCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioSumOrderByAggregateInput = {
    finalGoalsAchieved?: SortOrder
  }

  export type AvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    duration?: SortOrder
  }

  export type AvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilitySumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    duration?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionReflectionMeetingIdMenteeIdCompoundUniqueInput = {
    meetingId: string
    menteeId: string
  }

  export type SessionReflectionCountOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    menteeId?: SortOrder
    content?: SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionReflectionMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    menteeId?: SortOrder
    content?: SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionReflectionMinOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    menteeId?: SortOrder
    content?: SortOrder
    mentorConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionReflectionNullableScalarRelationFilter = {
    is?: SessionReflectionWhereInput | null
    isNot?: SessionReflectionWhereInput | null
  }

  export type TodoItemCountOrderByAggregateInput = {
    id?: SortOrder
    reflectionId?: SortOrder
    menteeId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    startDate?: SortOrder
    column?: SortOrder
    labels?: SortOrder
    description?: SortOrder
    attachments?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoItemMaxOrderByAggregateInput = {
    id?: SortOrder
    reflectionId?: SortOrder
    menteeId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    startDate?: SortOrder
    column?: SortOrder
    labels?: SortOrder
    description?: SortOrder
    attachments?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoItemMinOrderByAggregateInput = {
    id?: SortOrder
    reflectionId?: SortOrder
    menteeId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    startDate?: SortOrder
    column?: SortOrder
    labels?: SortOrder
    description?: SortOrder
    attachments?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketScalarRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type WikiPageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WikiPageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WikiPageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtboardListRelationFilter = {
    every?: ArtboardWhereInput
    some?: ArtboardWhereInput
    none?: ArtboardWhereInput
  }

  export type ArtboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhiteboardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhiteboardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhiteboardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WhiteboardScalarRelationFilter = {
    is?: WhiteboardWhereInput
    isNot?: WhiteboardWhereInput
  }

  export type ArtboardCountOrderByAggregateInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    elements?: SortOrder
    appState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtboardAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ArtboardMaxOrderByAggregateInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtboardMinOrderByAggregateInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtboardSumOrderByAggregateInput = {
    order?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SlideCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    theme?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlideMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    theme?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlideMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    theme?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MentorProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<MentorProfileCreateWithoutUserInput, MentorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorProfileCreateOrConnectWithoutUserInput
    connect?: MentorProfileWhereUniqueInput
  }

  export type MenteeProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<MenteeProfileCreateWithoutUserInput, MenteeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeProfileCreateOrConnectWithoutUserInput
    connect?: MenteeProfileWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MentorshipCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipMenteeCreateNestedManyWithoutMenteeInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMenteeInput, MentorshipMenteeUncheckedCreateWithoutMenteeInput> | MentorshipMenteeCreateWithoutMenteeInput[] | MentorshipMenteeUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMenteeInput | MentorshipMenteeCreateOrConnectWithoutMenteeInput[]
    createMany?: MentorshipMenteeCreateManyMenteeInputEnvelope
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type MeetingMinutesCreateNestedManyWithoutAuthorInput = {
    create?: XOR<MeetingMinutesCreateWithoutAuthorInput, MeetingMinutesUncheckedCreateWithoutAuthorInput> | MeetingMinutesCreateWithoutAuthorInput[] | MeetingMinutesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutAuthorInput | MeetingMinutesCreateOrConnectWithoutAuthorInput[]
    createMany?: MeetingMinutesCreateManyAuthorInputEnvelope
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GoalCreateWithoutCreatorInput, GoalUncheckedCreateWithoutCreatorInput> | GoalCreateWithoutCreatorInput[] | GoalUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutCreatorInput | GoalCreateOrConnectWithoutCreatorInput[]
    createMany?: GoalCreateManyCreatorInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutFromUserInput = {
    create?: XOR<FeedbackCreateWithoutFromUserInput, FeedbackUncheckedCreateWithoutFromUserInput> | FeedbackCreateWithoutFromUserInput[] | FeedbackUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutFromUserInput | FeedbackCreateOrConnectWithoutFromUserInput[]
    createMany?: FeedbackCreateManyFromUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutToUserInput = {
    create?: XOR<FeedbackCreateWithoutToUserInput, FeedbackUncheckedCreateWithoutToUserInput> | FeedbackCreateWithoutToUserInput[] | FeedbackUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutToUserInput | FeedbackCreateOrConnectWithoutToUserInput[]
    createMany?: FeedbackCreateManyToUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PortfolioCreateNestedManyWithoutMenteeInput = {
    create?: XOR<PortfolioCreateWithoutMenteeInput, PortfolioUncheckedCreateWithoutMenteeInput> | PortfolioCreateWithoutMenteeInput[] | PortfolioUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutMenteeInput | PortfolioCreateOrConnectWithoutMenteeInput[]
    createMany?: PortfolioCreateManyMenteeInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type AvailabilityCreateNestedManyWithoutUserInput = {
    create?: XOR<AvailabilityCreateWithoutUserInput, AvailabilityUncheckedCreateWithoutUserInput> | AvailabilityCreateWithoutUserInput[] | AvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutUserInput | AvailabilityCreateOrConnectWithoutUserInput[]
    createMany?: AvailabilityCreateManyUserInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type SessionReflectionCreateNestedManyWithoutMenteeInput = {
    create?: XOR<SessionReflectionCreateWithoutMenteeInput, SessionReflectionUncheckedCreateWithoutMenteeInput> | SessionReflectionCreateWithoutMenteeInput[] | SessionReflectionUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMenteeInput | SessionReflectionCreateOrConnectWithoutMenteeInput[]
    createMany?: SessionReflectionCreateManyMenteeInputEnvelope
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
  }

  export type TodoItemCreateNestedManyWithoutMenteeInput = {
    create?: XOR<TodoItemCreateWithoutMenteeInput, TodoItemUncheckedCreateWithoutMenteeInput> | TodoItemCreateWithoutMenteeInput[] | TodoItemUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutMenteeInput | TodoItemCreateOrConnectWithoutMenteeInput[]
    createMany?: TodoItemCreateManyMenteeInputEnvelope
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type WikiPageCreateNestedManyWithoutAuthorInput = {
    create?: XOR<WikiPageCreateWithoutAuthorInput, WikiPageUncheckedCreateWithoutAuthorInput> | WikiPageCreateWithoutAuthorInput[] | WikiPageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutAuthorInput | WikiPageCreateOrConnectWithoutAuthorInput[]
    createMany?: WikiPageCreateManyAuthorInputEnvelope
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
  }

  export type WhiteboardCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WhiteboardCreateWithoutCreatorInput, WhiteboardUncheckedCreateWithoutCreatorInput> | WhiteboardCreateWithoutCreatorInput[] | WhiteboardUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutCreatorInput | WhiteboardCreateOrConnectWithoutCreatorInput[]
    createMany?: WhiteboardCreateManyCreatorInputEnvelope
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
  }

  export type SlideCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SlideCreateWithoutCreatorInput, SlideUncheckedCreateWithoutCreatorInput> | SlideCreateWithoutCreatorInput[] | SlideUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SlideCreateOrConnectWithoutCreatorInput | SlideCreateOrConnectWithoutCreatorInput[]
    createMany?: SlideCreateManyCreatorInputEnvelope
    connect?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
  }

  export type MentorProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MentorProfileCreateWithoutUserInput, MentorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorProfileCreateOrConnectWithoutUserInput
    connect?: MentorProfileWhereUniqueInput
  }

  export type MenteeProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MenteeProfileCreateWithoutUserInput, MenteeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeProfileCreateOrConnectWithoutUserInput
    connect?: MenteeProfileWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MentorshipUncheckedCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMenteeInput, MentorshipMenteeUncheckedCreateWithoutMenteeInput> | MentorshipMenteeCreateWithoutMenteeInput[] | MentorshipMenteeUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMenteeInput | MentorshipMenteeCreateOrConnectWithoutMenteeInput[]
    createMany?: MentorshipMenteeCreateManyMenteeInputEnvelope
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<MeetingMinutesCreateWithoutAuthorInput, MeetingMinutesUncheckedCreateWithoutAuthorInput> | MeetingMinutesCreateWithoutAuthorInput[] | MeetingMinutesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutAuthorInput | MeetingMinutesCreateOrConnectWithoutAuthorInput[]
    createMany?: MeetingMinutesCreateManyAuthorInputEnvelope
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GoalCreateWithoutCreatorInput, GoalUncheckedCreateWithoutCreatorInput> | GoalCreateWithoutCreatorInput[] | GoalUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutCreatorInput | GoalCreateOrConnectWithoutCreatorInput[]
    createMany?: GoalCreateManyCreatorInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<FeedbackCreateWithoutFromUserInput, FeedbackUncheckedCreateWithoutFromUserInput> | FeedbackCreateWithoutFromUserInput[] | FeedbackUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutFromUserInput | FeedbackCreateOrConnectWithoutFromUserInput[]
    createMany?: FeedbackCreateManyFromUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<FeedbackCreateWithoutToUserInput, FeedbackUncheckedCreateWithoutToUserInput> | FeedbackCreateWithoutToUserInput[] | FeedbackUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutToUserInput | FeedbackCreateOrConnectWithoutToUserInput[]
    createMany?: FeedbackCreateManyToUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PortfolioUncheckedCreateNestedManyWithoutMenteeInput = {
    create?: XOR<PortfolioCreateWithoutMenteeInput, PortfolioUncheckedCreateWithoutMenteeInput> | PortfolioCreateWithoutMenteeInput[] | PortfolioUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutMenteeInput | PortfolioCreateOrConnectWithoutMenteeInput[]
    createMany?: PortfolioCreateManyMenteeInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AvailabilityCreateWithoutUserInput, AvailabilityUncheckedCreateWithoutUserInput> | AvailabilityCreateWithoutUserInput[] | AvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutUserInput | AvailabilityCreateOrConnectWithoutUserInput[]
    createMany?: AvailabilityCreateManyUserInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput = {
    create?: XOR<SessionReflectionCreateWithoutMenteeInput, SessionReflectionUncheckedCreateWithoutMenteeInput> | SessionReflectionCreateWithoutMenteeInput[] | SessionReflectionUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMenteeInput | SessionReflectionCreateOrConnectWithoutMenteeInput[]
    createMany?: SessionReflectionCreateManyMenteeInputEnvelope
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
  }

  export type TodoItemUncheckedCreateNestedManyWithoutMenteeInput = {
    create?: XOR<TodoItemCreateWithoutMenteeInput, TodoItemUncheckedCreateWithoutMenteeInput> | TodoItemCreateWithoutMenteeInput[] | TodoItemUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutMenteeInput | TodoItemCreateOrConnectWithoutMenteeInput[]
    createMany?: TodoItemCreateManyMenteeInputEnvelope
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type WikiPageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<WikiPageCreateWithoutAuthorInput, WikiPageUncheckedCreateWithoutAuthorInput> | WikiPageCreateWithoutAuthorInput[] | WikiPageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutAuthorInput | WikiPageCreateOrConnectWithoutAuthorInput[]
    createMany?: WikiPageCreateManyAuthorInputEnvelope
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
  }

  export type WhiteboardUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WhiteboardCreateWithoutCreatorInput, WhiteboardUncheckedCreateWithoutCreatorInput> | WhiteboardCreateWithoutCreatorInput[] | WhiteboardUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutCreatorInput | WhiteboardCreateOrConnectWithoutCreatorInput[]
    createMany?: WhiteboardCreateManyCreatorInputEnvelope
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
  }

  export type SlideUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SlideCreateWithoutCreatorInput, SlideUncheckedCreateWithoutCreatorInput> | SlideCreateWithoutCreatorInput[] | SlideUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SlideCreateOrConnectWithoutCreatorInput | SlideCreateOrConnectWithoutCreatorInput[]
    createMany?: SlideCreateManyCreatorInputEnvelope
    connect?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MentorProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<MentorProfileCreateWithoutUserInput, MentorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorProfileCreateOrConnectWithoutUserInput
    upsert?: MentorProfileUpsertWithoutUserInput
    disconnect?: MentorProfileWhereInput | boolean
    delete?: MentorProfileWhereInput | boolean
    connect?: MentorProfileWhereUniqueInput
    update?: XOR<XOR<MentorProfileUpdateToOneWithWhereWithoutUserInput, MentorProfileUpdateWithoutUserInput>, MentorProfileUncheckedUpdateWithoutUserInput>
  }

  export type MenteeProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<MenteeProfileCreateWithoutUserInput, MenteeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeProfileCreateOrConnectWithoutUserInput
    upsert?: MenteeProfileUpsertWithoutUserInput
    disconnect?: MenteeProfileWhereInput | boolean
    delete?: MenteeProfileWhereInput | boolean
    connect?: MenteeProfileWhereUniqueInput
    update?: XOR<XOR<MenteeProfileUpdateToOneWithWhereWithoutUserInput, MenteeProfileUpdateWithoutUserInput>, MenteeProfileUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MentorshipUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutMentorInput | MentorshipUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutMentorInput | MentorshipUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutMentorInput | MentorshipUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type MentorshipMenteeUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMenteeInput, MentorshipMenteeUncheckedCreateWithoutMenteeInput> | MentorshipMenteeCreateWithoutMenteeInput[] | MentorshipMenteeUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMenteeInput | MentorshipMenteeCreateOrConnectWithoutMenteeInput[]
    upsert?: MentorshipMenteeUpsertWithWhereUniqueWithoutMenteeInput | MentorshipMenteeUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: MentorshipMenteeCreateManyMenteeInputEnvelope
    set?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    disconnect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    delete?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    update?: MentorshipMenteeUpdateWithWhereUniqueWithoutMenteeInput | MentorshipMenteeUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: MentorshipMenteeUpdateManyWithWhereWithoutMenteeInput | MentorshipMenteeUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: MentorshipMenteeScalarWhereInput | MentorshipMenteeScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatorInput | MeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatorInput | MeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatorInput | MeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type MeetingMinutesUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<MeetingMinutesCreateWithoutAuthorInput, MeetingMinutesUncheckedCreateWithoutAuthorInput> | MeetingMinutesCreateWithoutAuthorInput[] | MeetingMinutesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutAuthorInput | MeetingMinutesCreateOrConnectWithoutAuthorInput[]
    upsert?: MeetingMinutesUpsertWithWhereUniqueWithoutAuthorInput | MeetingMinutesUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: MeetingMinutesCreateManyAuthorInputEnvelope
    set?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    disconnect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    delete?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    update?: MeetingMinutesUpdateWithWhereUniqueWithoutAuthorInput | MeetingMinutesUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: MeetingMinutesUpdateManyWithWhereWithoutAuthorInput | MeetingMinutesUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: MeetingMinutesScalarWhereInput | MeetingMinutesScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GoalCreateWithoutCreatorInput, GoalUncheckedCreateWithoutCreatorInput> | GoalCreateWithoutCreatorInput[] | GoalUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutCreatorInput | GoalCreateOrConnectWithoutCreatorInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutCreatorInput | GoalUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GoalCreateManyCreatorInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutCreatorInput | GoalUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutCreatorInput | GoalUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutFromUserInput, FeedbackUncheckedCreateWithoutFromUserInput> | FeedbackCreateWithoutFromUserInput[] | FeedbackUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutFromUserInput | FeedbackCreateOrConnectWithoutFromUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutFromUserInput | FeedbackUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: FeedbackCreateManyFromUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutFromUserInput | FeedbackUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutFromUserInput | FeedbackUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutToUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutToUserInput, FeedbackUncheckedCreateWithoutToUserInput> | FeedbackCreateWithoutToUserInput[] | FeedbackUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutToUserInput | FeedbackCreateOrConnectWithoutToUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutToUserInput | FeedbackUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: FeedbackCreateManyToUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutToUserInput | FeedbackUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutToUserInput | FeedbackUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUploadedByInput | ResourceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUploadedByInput | ResourceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUploadedByInput | ResourceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PortfolioUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<PortfolioCreateWithoutMenteeInput, PortfolioUncheckedCreateWithoutMenteeInput> | PortfolioCreateWithoutMenteeInput[] | PortfolioUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutMenteeInput | PortfolioCreateOrConnectWithoutMenteeInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutMenteeInput | PortfolioUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: PortfolioCreateManyMenteeInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutMenteeInput | PortfolioUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutMenteeInput | PortfolioUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type AvailabilityUpdateManyWithoutUserNestedInput = {
    create?: XOR<AvailabilityCreateWithoutUserInput, AvailabilityUncheckedCreateWithoutUserInput> | AvailabilityCreateWithoutUserInput[] | AvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutUserInput | AvailabilityCreateOrConnectWithoutUserInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutUserInput | AvailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AvailabilityCreateManyUserInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutUserInput | AvailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutUserInput | AvailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type SessionReflectionUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<SessionReflectionCreateWithoutMenteeInput, SessionReflectionUncheckedCreateWithoutMenteeInput> | SessionReflectionCreateWithoutMenteeInput[] | SessionReflectionUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMenteeInput | SessionReflectionCreateOrConnectWithoutMenteeInput[]
    upsert?: SessionReflectionUpsertWithWhereUniqueWithoutMenteeInput | SessionReflectionUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: SessionReflectionCreateManyMenteeInputEnvelope
    set?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    disconnect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    delete?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    update?: SessionReflectionUpdateWithWhereUniqueWithoutMenteeInput | SessionReflectionUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: SessionReflectionUpdateManyWithWhereWithoutMenteeInput | SessionReflectionUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: SessionReflectionScalarWhereInput | SessionReflectionScalarWhereInput[]
  }

  export type TodoItemUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<TodoItemCreateWithoutMenteeInput, TodoItemUncheckedCreateWithoutMenteeInput> | TodoItemCreateWithoutMenteeInput[] | TodoItemUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutMenteeInput | TodoItemCreateOrConnectWithoutMenteeInput[]
    upsert?: TodoItemUpsertWithWhereUniqueWithoutMenteeInput | TodoItemUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: TodoItemCreateManyMenteeInputEnvelope
    set?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    disconnect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    delete?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    update?: TodoItemUpdateWithWhereUniqueWithoutMenteeInput | TodoItemUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: TodoItemUpdateManyWithWhereWithoutMenteeInput | TodoItemUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type WikiPageUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<WikiPageCreateWithoutAuthorInput, WikiPageUncheckedCreateWithoutAuthorInput> | WikiPageCreateWithoutAuthorInput[] | WikiPageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutAuthorInput | WikiPageCreateOrConnectWithoutAuthorInput[]
    upsert?: WikiPageUpsertWithWhereUniqueWithoutAuthorInput | WikiPageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: WikiPageCreateManyAuthorInputEnvelope
    set?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    disconnect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    delete?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    update?: WikiPageUpdateWithWhereUniqueWithoutAuthorInput | WikiPageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: WikiPageUpdateManyWithWhereWithoutAuthorInput | WikiPageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
  }

  export type WhiteboardUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WhiteboardCreateWithoutCreatorInput, WhiteboardUncheckedCreateWithoutCreatorInput> | WhiteboardCreateWithoutCreatorInput[] | WhiteboardUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutCreatorInput | WhiteboardCreateOrConnectWithoutCreatorInput[]
    upsert?: WhiteboardUpsertWithWhereUniqueWithoutCreatorInput | WhiteboardUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WhiteboardCreateManyCreatorInputEnvelope
    set?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    disconnect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    delete?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    update?: WhiteboardUpdateWithWhereUniqueWithoutCreatorInput | WhiteboardUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WhiteboardUpdateManyWithWhereWithoutCreatorInput | WhiteboardUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
  }

  export type SlideUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SlideCreateWithoutCreatorInput, SlideUncheckedCreateWithoutCreatorInput> | SlideCreateWithoutCreatorInput[] | SlideUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SlideCreateOrConnectWithoutCreatorInput | SlideCreateOrConnectWithoutCreatorInput[]
    upsert?: SlideUpsertWithWhereUniqueWithoutCreatorInput | SlideUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SlideCreateManyCreatorInputEnvelope
    set?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    disconnect?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    delete?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    connect?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    update?: SlideUpdateWithWhereUniqueWithoutCreatorInput | SlideUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SlideUpdateManyWithWhereWithoutCreatorInput | SlideUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SlideScalarWhereInput | SlideScalarWhereInput[]
  }

  export type MentorProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MentorProfileCreateWithoutUserInput, MentorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorProfileCreateOrConnectWithoutUserInput
    upsert?: MentorProfileUpsertWithoutUserInput
    disconnect?: MentorProfileWhereInput | boolean
    delete?: MentorProfileWhereInput | boolean
    connect?: MentorProfileWhereUniqueInput
    update?: XOR<XOR<MentorProfileUpdateToOneWithWhereWithoutUserInput, MentorProfileUpdateWithoutUserInput>, MentorProfileUncheckedUpdateWithoutUserInput>
  }

  export type MenteeProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MenteeProfileCreateWithoutUserInput, MenteeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeProfileCreateOrConnectWithoutUserInput
    upsert?: MenteeProfileUpsertWithoutUserInput
    disconnect?: MenteeProfileWhereInput | boolean
    delete?: MenteeProfileWhereInput | boolean
    connect?: MenteeProfileWhereUniqueInput
    update?: XOR<XOR<MenteeProfileUpdateToOneWithWhereWithoutUserInput, MenteeProfileUpdateWithoutUserInput>, MenteeProfileUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MentorshipUncheckedUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutMentorInput | MentorshipUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutMentorInput | MentorshipUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutMentorInput | MentorshipUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMenteeInput, MentorshipMenteeUncheckedCreateWithoutMenteeInput> | MentorshipMenteeCreateWithoutMenteeInput[] | MentorshipMenteeUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMenteeInput | MentorshipMenteeCreateOrConnectWithoutMenteeInput[]
    upsert?: MentorshipMenteeUpsertWithWhereUniqueWithoutMenteeInput | MentorshipMenteeUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: MentorshipMenteeCreateManyMenteeInputEnvelope
    set?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    disconnect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    delete?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    update?: MentorshipMenteeUpdateWithWhereUniqueWithoutMenteeInput | MentorshipMenteeUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: MentorshipMenteeUpdateManyWithWhereWithoutMenteeInput | MentorshipMenteeUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: MentorshipMenteeScalarWhereInput | MentorshipMenteeScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatorInput | MeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatorInput | MeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatorInput | MeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<MeetingMinutesCreateWithoutAuthorInput, MeetingMinutesUncheckedCreateWithoutAuthorInput> | MeetingMinutesCreateWithoutAuthorInput[] | MeetingMinutesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutAuthorInput | MeetingMinutesCreateOrConnectWithoutAuthorInput[]
    upsert?: MeetingMinutesUpsertWithWhereUniqueWithoutAuthorInput | MeetingMinutesUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: MeetingMinutesCreateManyAuthorInputEnvelope
    set?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    disconnect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    delete?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    update?: MeetingMinutesUpdateWithWhereUniqueWithoutAuthorInput | MeetingMinutesUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: MeetingMinutesUpdateManyWithWhereWithoutAuthorInput | MeetingMinutesUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: MeetingMinutesScalarWhereInput | MeetingMinutesScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GoalCreateWithoutCreatorInput, GoalUncheckedCreateWithoutCreatorInput> | GoalCreateWithoutCreatorInput[] | GoalUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutCreatorInput | GoalCreateOrConnectWithoutCreatorInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutCreatorInput | GoalUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GoalCreateManyCreatorInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutCreatorInput | GoalUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutCreatorInput | GoalUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutFromUserInput, FeedbackUncheckedCreateWithoutFromUserInput> | FeedbackCreateWithoutFromUserInput[] | FeedbackUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutFromUserInput | FeedbackCreateOrConnectWithoutFromUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutFromUserInput | FeedbackUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: FeedbackCreateManyFromUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutFromUserInput | FeedbackUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutFromUserInput | FeedbackUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutToUserInput, FeedbackUncheckedCreateWithoutToUserInput> | FeedbackCreateWithoutToUserInput[] | FeedbackUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutToUserInput | FeedbackCreateOrConnectWithoutToUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutToUserInput | FeedbackUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: FeedbackCreateManyToUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutToUserInput | FeedbackUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutToUserInput | FeedbackUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUploadedByInput | ResourceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUploadedByInput | ResourceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUploadedByInput | ResourceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PortfolioUncheckedUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<PortfolioCreateWithoutMenteeInput, PortfolioUncheckedCreateWithoutMenteeInput> | PortfolioCreateWithoutMenteeInput[] | PortfolioUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutMenteeInput | PortfolioCreateOrConnectWithoutMenteeInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutMenteeInput | PortfolioUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: PortfolioCreateManyMenteeInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutMenteeInput | PortfolioUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutMenteeInput | PortfolioUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AvailabilityCreateWithoutUserInput, AvailabilityUncheckedCreateWithoutUserInput> | AvailabilityCreateWithoutUserInput[] | AvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutUserInput | AvailabilityCreateOrConnectWithoutUserInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutUserInput | AvailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AvailabilityCreateManyUserInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutUserInput | AvailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutUserInput | AvailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<SessionReflectionCreateWithoutMenteeInput, SessionReflectionUncheckedCreateWithoutMenteeInput> | SessionReflectionCreateWithoutMenteeInput[] | SessionReflectionUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMenteeInput | SessionReflectionCreateOrConnectWithoutMenteeInput[]
    upsert?: SessionReflectionUpsertWithWhereUniqueWithoutMenteeInput | SessionReflectionUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: SessionReflectionCreateManyMenteeInputEnvelope
    set?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    disconnect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    delete?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    update?: SessionReflectionUpdateWithWhereUniqueWithoutMenteeInput | SessionReflectionUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: SessionReflectionUpdateManyWithWhereWithoutMenteeInput | SessionReflectionUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: SessionReflectionScalarWhereInput | SessionReflectionScalarWhereInput[]
  }

  export type TodoItemUncheckedUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<TodoItemCreateWithoutMenteeInput, TodoItemUncheckedCreateWithoutMenteeInput> | TodoItemCreateWithoutMenteeInput[] | TodoItemUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutMenteeInput | TodoItemCreateOrConnectWithoutMenteeInput[]
    upsert?: TodoItemUpsertWithWhereUniqueWithoutMenteeInput | TodoItemUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: TodoItemCreateManyMenteeInputEnvelope
    set?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    disconnect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    delete?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    update?: TodoItemUpdateWithWhereUniqueWithoutMenteeInput | TodoItemUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: TodoItemUpdateManyWithWhereWithoutMenteeInput | TodoItemUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type WikiPageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<WikiPageCreateWithoutAuthorInput, WikiPageUncheckedCreateWithoutAuthorInput> | WikiPageCreateWithoutAuthorInput[] | WikiPageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutAuthorInput | WikiPageCreateOrConnectWithoutAuthorInput[]
    upsert?: WikiPageUpsertWithWhereUniqueWithoutAuthorInput | WikiPageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: WikiPageCreateManyAuthorInputEnvelope
    set?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    disconnect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    delete?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    update?: WikiPageUpdateWithWhereUniqueWithoutAuthorInput | WikiPageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: WikiPageUpdateManyWithWhereWithoutAuthorInput | WikiPageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
  }

  export type WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WhiteboardCreateWithoutCreatorInput, WhiteboardUncheckedCreateWithoutCreatorInput> | WhiteboardCreateWithoutCreatorInput[] | WhiteboardUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutCreatorInput | WhiteboardCreateOrConnectWithoutCreatorInput[]
    upsert?: WhiteboardUpsertWithWhereUniqueWithoutCreatorInput | WhiteboardUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WhiteboardCreateManyCreatorInputEnvelope
    set?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    disconnect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    delete?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    update?: WhiteboardUpdateWithWhereUniqueWithoutCreatorInput | WhiteboardUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WhiteboardUpdateManyWithWhereWithoutCreatorInput | WhiteboardUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
  }

  export type SlideUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SlideCreateWithoutCreatorInput, SlideUncheckedCreateWithoutCreatorInput> | SlideCreateWithoutCreatorInput[] | SlideUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SlideCreateOrConnectWithoutCreatorInput | SlideCreateOrConnectWithoutCreatorInput[]
    upsert?: SlideUpsertWithWhereUniqueWithoutCreatorInput | SlideUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SlideCreateManyCreatorInputEnvelope
    set?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    disconnect?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    delete?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    connect?: SlideWhereUniqueInput | SlideWhereUniqueInput[]
    update?: SlideUpdateWithWhereUniqueWithoutCreatorInput | SlideUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SlideUpdateManyWithWhereWithoutCreatorInput | SlideUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SlideScalarWhereInput | SlideScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutMentorProfileInput = {
    create?: XOR<UserCreateWithoutMentorProfileInput, UserUncheckedCreateWithoutMentorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutMentorProfileNestedInput = {
    create?: XOR<UserCreateWithoutMentorProfileInput, UserUncheckedCreateWithoutMentorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorProfileInput
    upsert?: UserUpsertWithoutMentorProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentorProfileInput, UserUpdateWithoutMentorProfileInput>, UserUncheckedUpdateWithoutMentorProfileInput>
  }

  export type UserCreateNestedOneWithoutMenteeProfileInput = {
    create?: XOR<UserCreateWithoutMenteeProfileInput, UserUncheckedCreateWithoutMenteeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenteeProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMenteeProfileNestedInput = {
    create?: XOR<UserCreateWithoutMenteeProfileInput, UserUncheckedCreateWithoutMenteeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenteeProfileInput
    upsert?: UserUpsertWithoutMenteeProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMenteeProfileInput, UserUpdateWithoutMenteeProfileInput>, UserUncheckedUpdateWithoutMenteeProfileInput>
  }

  export type MentorshipCreateNestedManyWithoutProgramCycleInput = {
    create?: XOR<MentorshipCreateWithoutProgramCycleInput, MentorshipUncheckedCreateWithoutProgramCycleInput> | MentorshipCreateWithoutProgramCycleInput[] | MentorshipUncheckedCreateWithoutProgramCycleInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramCycleInput | MentorshipCreateOrConnectWithoutProgramCycleInput[]
    createMany?: MentorshipCreateManyProgramCycleInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipUncheckedCreateNestedManyWithoutProgramCycleInput = {
    create?: XOR<MentorshipCreateWithoutProgramCycleInput, MentorshipUncheckedCreateWithoutProgramCycleInput> | MentorshipCreateWithoutProgramCycleInput[] | MentorshipUncheckedCreateWithoutProgramCycleInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramCycleInput | MentorshipCreateOrConnectWithoutProgramCycleInput[]
    createMany?: MentorshipCreateManyProgramCycleInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipUpdateManyWithoutProgramCycleNestedInput = {
    create?: XOR<MentorshipCreateWithoutProgramCycleInput, MentorshipUncheckedCreateWithoutProgramCycleInput> | MentorshipCreateWithoutProgramCycleInput[] | MentorshipUncheckedCreateWithoutProgramCycleInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramCycleInput | MentorshipCreateOrConnectWithoutProgramCycleInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutProgramCycleInput | MentorshipUpsertWithWhereUniqueWithoutProgramCycleInput[]
    createMany?: MentorshipCreateManyProgramCycleInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutProgramCycleInput | MentorshipUpdateWithWhereUniqueWithoutProgramCycleInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutProgramCycleInput | MentorshipUpdateManyWithWhereWithoutProgramCycleInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type MentorshipUncheckedUpdateManyWithoutProgramCycleNestedInput = {
    create?: XOR<MentorshipCreateWithoutProgramCycleInput, MentorshipUncheckedCreateWithoutProgramCycleInput> | MentorshipCreateWithoutProgramCycleInput[] | MentorshipUncheckedCreateWithoutProgramCycleInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramCycleInput | MentorshipCreateOrConnectWithoutProgramCycleInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutProgramCycleInput | MentorshipUpsertWithWhereUniqueWithoutProgramCycleInput[]
    createMany?: MentorshipCreateManyProgramCycleInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutProgramCycleInput | MentorshipUpdateWithWhereUniqueWithoutProgramCycleInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutProgramCycleInput | MentorshipUpdateManyWithWhereWithoutProgramCycleInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMentorshipsInput = {
    create?: XOR<UserCreateWithoutMentorshipsInput, UserUncheckedCreateWithoutMentorshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorshipsInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramCycleCreateNestedOneWithoutMentorshipsInput = {
    create?: XOR<ProgramCycleCreateWithoutMentorshipsInput, ProgramCycleUncheckedCreateWithoutMentorshipsInput>
    connectOrCreate?: ProgramCycleCreateOrConnectWithoutMentorshipsInput
    connect?: ProgramCycleWhereUniqueInput
  }

  export type MentorshipMenteeCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMentorshipInput, MentorshipMenteeUncheckedCreateWithoutMentorshipInput> | MentorshipMenteeCreateWithoutMentorshipInput[] | MentorshipMenteeUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMentorshipInput | MentorshipMenteeCreateOrConnectWithoutMentorshipInput[]
    createMany?: MentorshipMenteeCreateManyMentorshipInputEnvelope
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<MeetingCreateWithoutMentorshipInput, MeetingUncheckedCreateWithoutMentorshipInput> | MeetingCreateWithoutMentorshipInput[] | MeetingUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutMentorshipInput | MeetingCreateOrConnectWithoutMentorshipInput[]
    createMany?: MeetingCreateManyMentorshipInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<GoalCreateWithoutMentorshipInput, GoalUncheckedCreateWithoutMentorshipInput> | GoalCreateWithoutMentorshipInput[] | GoalUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutMentorshipInput | GoalCreateOrConnectWithoutMentorshipInput[]
    createMany?: GoalCreateManyMentorshipInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<FeedbackCreateWithoutMentorshipInput, FeedbackUncheckedCreateWithoutMentorshipInput> | FeedbackCreateWithoutMentorshipInput[] | FeedbackUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutMentorshipInput | FeedbackCreateOrConnectWithoutMentorshipInput[]
    createMany?: FeedbackCreateManyMentorshipInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type MentorshipMenteeUncheckedCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMentorshipInput, MentorshipMenteeUncheckedCreateWithoutMentorshipInput> | MentorshipMenteeCreateWithoutMentorshipInput[] | MentorshipMenteeUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMentorshipInput | MentorshipMenteeCreateOrConnectWithoutMentorshipInput[]
    createMany?: MentorshipMenteeCreateManyMentorshipInputEnvelope
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<MeetingCreateWithoutMentorshipInput, MeetingUncheckedCreateWithoutMentorshipInput> | MeetingCreateWithoutMentorshipInput[] | MeetingUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutMentorshipInput | MeetingCreateOrConnectWithoutMentorshipInput[]
    createMany?: MeetingCreateManyMentorshipInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<GoalCreateWithoutMentorshipInput, GoalUncheckedCreateWithoutMentorshipInput> | GoalCreateWithoutMentorshipInput[] | GoalUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutMentorshipInput | GoalCreateOrConnectWithoutMentorshipInput[]
    createMany?: GoalCreateManyMentorshipInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutMentorshipInput = {
    create?: XOR<FeedbackCreateWithoutMentorshipInput, FeedbackUncheckedCreateWithoutMentorshipInput> | FeedbackCreateWithoutMentorshipInput[] | FeedbackUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutMentorshipInput | FeedbackCreateOrConnectWithoutMentorshipInput[]
    createMany?: FeedbackCreateManyMentorshipInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMentorshipsNestedInput = {
    create?: XOR<UserCreateWithoutMentorshipsInput, UserUncheckedCreateWithoutMentorshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorshipsInput
    upsert?: UserUpsertWithoutMentorshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentorshipsInput, UserUpdateWithoutMentorshipsInput>, UserUncheckedUpdateWithoutMentorshipsInput>
  }

  export type ProgramCycleUpdateOneRequiredWithoutMentorshipsNestedInput = {
    create?: XOR<ProgramCycleCreateWithoutMentorshipsInput, ProgramCycleUncheckedCreateWithoutMentorshipsInput>
    connectOrCreate?: ProgramCycleCreateOrConnectWithoutMentorshipsInput
    upsert?: ProgramCycleUpsertWithoutMentorshipsInput
    connect?: ProgramCycleWhereUniqueInput
    update?: XOR<XOR<ProgramCycleUpdateToOneWithWhereWithoutMentorshipsInput, ProgramCycleUpdateWithoutMentorshipsInput>, ProgramCycleUncheckedUpdateWithoutMentorshipsInput>
  }

  export type MentorshipMenteeUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMentorshipInput, MentorshipMenteeUncheckedCreateWithoutMentorshipInput> | MentorshipMenteeCreateWithoutMentorshipInput[] | MentorshipMenteeUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMentorshipInput | MentorshipMenteeCreateOrConnectWithoutMentorshipInput[]
    upsert?: MentorshipMenteeUpsertWithWhereUniqueWithoutMentorshipInput | MentorshipMenteeUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: MentorshipMenteeCreateManyMentorshipInputEnvelope
    set?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    disconnect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    delete?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    update?: MentorshipMenteeUpdateWithWhereUniqueWithoutMentorshipInput | MentorshipMenteeUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: MentorshipMenteeUpdateManyWithWhereWithoutMentorshipInput | MentorshipMenteeUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: MentorshipMenteeScalarWhereInput | MentorshipMenteeScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<MeetingCreateWithoutMentorshipInput, MeetingUncheckedCreateWithoutMentorshipInput> | MeetingCreateWithoutMentorshipInput[] | MeetingUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutMentorshipInput | MeetingCreateOrConnectWithoutMentorshipInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutMentorshipInput | MeetingUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: MeetingCreateManyMentorshipInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutMentorshipInput | MeetingUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutMentorshipInput | MeetingUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<GoalCreateWithoutMentorshipInput, GoalUncheckedCreateWithoutMentorshipInput> | GoalCreateWithoutMentorshipInput[] | GoalUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutMentorshipInput | GoalCreateOrConnectWithoutMentorshipInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutMentorshipInput | GoalUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: GoalCreateManyMentorshipInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutMentorshipInput | GoalUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutMentorshipInput | GoalUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<FeedbackCreateWithoutMentorshipInput, FeedbackUncheckedCreateWithoutMentorshipInput> | FeedbackCreateWithoutMentorshipInput[] | FeedbackUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutMentorshipInput | FeedbackCreateOrConnectWithoutMentorshipInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutMentorshipInput | FeedbackUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: FeedbackCreateManyMentorshipInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutMentorshipInput | FeedbackUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutMentorshipInput | FeedbackUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type MentorshipMenteeUncheckedUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<MentorshipMenteeCreateWithoutMentorshipInput, MentorshipMenteeUncheckedCreateWithoutMentorshipInput> | MentorshipMenteeCreateWithoutMentorshipInput[] | MentorshipMenteeUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MentorshipMenteeCreateOrConnectWithoutMentorshipInput | MentorshipMenteeCreateOrConnectWithoutMentorshipInput[]
    upsert?: MentorshipMenteeUpsertWithWhereUniqueWithoutMentorshipInput | MentorshipMenteeUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: MentorshipMenteeCreateManyMentorshipInputEnvelope
    set?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    disconnect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    delete?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    connect?: MentorshipMenteeWhereUniqueInput | MentorshipMenteeWhereUniqueInput[]
    update?: MentorshipMenteeUpdateWithWhereUniqueWithoutMentorshipInput | MentorshipMenteeUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: MentorshipMenteeUpdateManyWithWhereWithoutMentorshipInput | MentorshipMenteeUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: MentorshipMenteeScalarWhereInput | MentorshipMenteeScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<MeetingCreateWithoutMentorshipInput, MeetingUncheckedCreateWithoutMentorshipInput> | MeetingCreateWithoutMentorshipInput[] | MeetingUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutMentorshipInput | MeetingCreateOrConnectWithoutMentorshipInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutMentorshipInput | MeetingUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: MeetingCreateManyMentorshipInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutMentorshipInput | MeetingUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutMentorshipInput | MeetingUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<GoalCreateWithoutMentorshipInput, GoalUncheckedCreateWithoutMentorshipInput> | GoalCreateWithoutMentorshipInput[] | GoalUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutMentorshipInput | GoalCreateOrConnectWithoutMentorshipInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutMentorshipInput | GoalUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: GoalCreateManyMentorshipInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutMentorshipInput | GoalUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutMentorshipInput | GoalUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutMentorshipNestedInput = {
    create?: XOR<FeedbackCreateWithoutMentorshipInput, FeedbackUncheckedCreateWithoutMentorshipInput> | FeedbackCreateWithoutMentorshipInput[] | FeedbackUncheckedCreateWithoutMentorshipInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutMentorshipInput | FeedbackCreateOrConnectWithoutMentorshipInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutMentorshipInput | FeedbackUpsertWithWhereUniqueWithoutMentorshipInput[]
    createMany?: FeedbackCreateManyMentorshipInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutMentorshipInput | FeedbackUpdateWithWhereUniqueWithoutMentorshipInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutMentorshipInput | FeedbackUpdateManyWithWhereWithoutMentorshipInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type MentorshipCreateNestedOneWithoutMenteesInput = {
    create?: XOR<MentorshipCreateWithoutMenteesInput, MentorshipUncheckedCreateWithoutMenteesInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutMenteesInput
    connect?: MentorshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMenteeshipsInput = {
    create?: XOR<UserCreateWithoutMenteeshipsInput, UserUncheckedCreateWithoutMenteeshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenteeshipsInput
    connect?: UserWhereUniqueInput
  }

  export type MentorshipUpdateOneRequiredWithoutMenteesNestedInput = {
    create?: XOR<MentorshipCreateWithoutMenteesInput, MentorshipUncheckedCreateWithoutMenteesInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutMenteesInput
    upsert?: MentorshipUpsertWithoutMenteesInput
    connect?: MentorshipWhereUniqueInput
    update?: XOR<XOR<MentorshipUpdateToOneWithWhereWithoutMenteesInput, MentorshipUpdateWithoutMenteesInput>, MentorshipUncheckedUpdateWithoutMenteesInput>
  }

  export type UserUpdateOneRequiredWithoutMenteeshipsNestedInput = {
    create?: XOR<UserCreateWithoutMenteeshipsInput, UserUncheckedCreateWithoutMenteeshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenteeshipsInput
    upsert?: UserUpsertWithoutMenteeshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMenteeshipsInput, UserUpdateWithoutMenteeshipsInput>, UserUncheckedUpdateWithoutMenteeshipsInput>
  }

  export type MentorshipCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<MentorshipCreateWithoutMeetingsInput, MentorshipUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutMeetingsInput
    connect?: MentorshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMeetingsCreatedInput = {
    create?: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutMeetingInput = {
    create?: XOR<AttendanceCreateWithoutMeetingInput, AttendanceUncheckedCreateWithoutMeetingInput> | AttendanceCreateWithoutMeetingInput[] | AttendanceUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMeetingInput | AttendanceCreateOrConnectWithoutMeetingInput[]
    createMany?: AttendanceCreateManyMeetingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type MeetingMinutesCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MeetingMinutesCreateWithoutMeetingInput, MeetingMinutesUncheckedCreateWithoutMeetingInput> | MeetingMinutesCreateWithoutMeetingInput[] | MeetingMinutesUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutMeetingInput | MeetingMinutesCreateOrConnectWithoutMeetingInput[]
    createMany?: MeetingMinutesCreateManyMeetingInputEnvelope
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
  }

  export type SessionReflectionCreateNestedManyWithoutMeetingInput = {
    create?: XOR<SessionReflectionCreateWithoutMeetingInput, SessionReflectionUncheckedCreateWithoutMeetingInput> | SessionReflectionCreateWithoutMeetingInput[] | SessionReflectionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMeetingInput | SessionReflectionCreateOrConnectWithoutMeetingInput[]
    createMany?: SessionReflectionCreateManyMeetingInputEnvelope
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<AttendanceCreateWithoutMeetingInput, AttendanceUncheckedCreateWithoutMeetingInput> | AttendanceCreateWithoutMeetingInput[] | AttendanceUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMeetingInput | AttendanceCreateOrConnectWithoutMeetingInput[]
    createMany?: AttendanceCreateManyMeetingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type MeetingMinutesUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MeetingMinutesCreateWithoutMeetingInput, MeetingMinutesUncheckedCreateWithoutMeetingInput> | MeetingMinutesCreateWithoutMeetingInput[] | MeetingMinutesUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutMeetingInput | MeetingMinutesCreateOrConnectWithoutMeetingInput[]
    createMany?: MeetingMinutesCreateManyMeetingInputEnvelope
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
  }

  export type SessionReflectionUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<SessionReflectionCreateWithoutMeetingInput, SessionReflectionUncheckedCreateWithoutMeetingInput> | SessionReflectionCreateWithoutMeetingInput[] | SessionReflectionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMeetingInput | SessionReflectionCreateOrConnectWithoutMeetingInput[]
    createMany?: SessionReflectionCreateManyMeetingInputEnvelope
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
  }

  export type MentorshipUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<MentorshipCreateWithoutMeetingsInput, MentorshipUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutMeetingsInput
    upsert?: MentorshipUpsertWithoutMeetingsInput
    connect?: MentorshipWhereUniqueInput
    update?: XOR<XOR<MentorshipUpdateToOneWithWhereWithoutMeetingsInput, MentorshipUpdateWithoutMeetingsInput>, MentorshipUncheckedUpdateWithoutMeetingsInput>
  }

  export type UserUpdateOneRequiredWithoutMeetingsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsCreatedInput
    upsert?: UserUpsertWithoutMeetingsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeetingsCreatedInput, UserUpdateWithoutMeetingsCreatedInput>, UserUncheckedUpdateWithoutMeetingsCreatedInput>
  }

  export type AttendanceUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<AttendanceCreateWithoutMeetingInput, AttendanceUncheckedCreateWithoutMeetingInput> | AttendanceCreateWithoutMeetingInput[] | AttendanceUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMeetingInput | AttendanceCreateOrConnectWithoutMeetingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutMeetingInput | AttendanceUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: AttendanceCreateManyMeetingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutMeetingInput | AttendanceUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutMeetingInput | AttendanceUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type MeetingMinutesUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MeetingMinutesCreateWithoutMeetingInput, MeetingMinutesUncheckedCreateWithoutMeetingInput> | MeetingMinutesCreateWithoutMeetingInput[] | MeetingMinutesUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutMeetingInput | MeetingMinutesCreateOrConnectWithoutMeetingInput[]
    upsert?: MeetingMinutesUpsertWithWhereUniqueWithoutMeetingInput | MeetingMinutesUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MeetingMinutesCreateManyMeetingInputEnvelope
    set?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    disconnect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    delete?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    update?: MeetingMinutesUpdateWithWhereUniqueWithoutMeetingInput | MeetingMinutesUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MeetingMinutesUpdateManyWithWhereWithoutMeetingInput | MeetingMinutesUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MeetingMinutesScalarWhereInput | MeetingMinutesScalarWhereInput[]
  }

  export type SessionReflectionUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<SessionReflectionCreateWithoutMeetingInput, SessionReflectionUncheckedCreateWithoutMeetingInput> | SessionReflectionCreateWithoutMeetingInput[] | SessionReflectionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMeetingInput | SessionReflectionCreateOrConnectWithoutMeetingInput[]
    upsert?: SessionReflectionUpsertWithWhereUniqueWithoutMeetingInput | SessionReflectionUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: SessionReflectionCreateManyMeetingInputEnvelope
    set?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    disconnect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    delete?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    update?: SessionReflectionUpdateWithWhereUniqueWithoutMeetingInput | SessionReflectionUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: SessionReflectionUpdateManyWithWhereWithoutMeetingInput | SessionReflectionUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: SessionReflectionScalarWhereInput | SessionReflectionScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<AttendanceCreateWithoutMeetingInput, AttendanceUncheckedCreateWithoutMeetingInput> | AttendanceCreateWithoutMeetingInput[] | AttendanceUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMeetingInput | AttendanceCreateOrConnectWithoutMeetingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutMeetingInput | AttendanceUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: AttendanceCreateManyMeetingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutMeetingInput | AttendanceUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutMeetingInput | AttendanceUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type MeetingMinutesUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MeetingMinutesCreateWithoutMeetingInput, MeetingMinutesUncheckedCreateWithoutMeetingInput> | MeetingMinutesCreateWithoutMeetingInput[] | MeetingMinutesUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingMinutesCreateOrConnectWithoutMeetingInput | MeetingMinutesCreateOrConnectWithoutMeetingInput[]
    upsert?: MeetingMinutesUpsertWithWhereUniqueWithoutMeetingInput | MeetingMinutesUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MeetingMinutesCreateManyMeetingInputEnvelope
    set?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    disconnect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    delete?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    connect?: MeetingMinutesWhereUniqueInput | MeetingMinutesWhereUniqueInput[]
    update?: MeetingMinutesUpdateWithWhereUniqueWithoutMeetingInput | MeetingMinutesUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MeetingMinutesUpdateManyWithWhereWithoutMeetingInput | MeetingMinutesUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MeetingMinutesScalarWhereInput | MeetingMinutesScalarWhereInput[]
  }

  export type SessionReflectionUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<SessionReflectionCreateWithoutMeetingInput, SessionReflectionUncheckedCreateWithoutMeetingInput> | SessionReflectionCreateWithoutMeetingInput[] | SessionReflectionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutMeetingInput | SessionReflectionCreateOrConnectWithoutMeetingInput[]
    upsert?: SessionReflectionUpsertWithWhereUniqueWithoutMeetingInput | SessionReflectionUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: SessionReflectionCreateManyMeetingInputEnvelope
    set?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    disconnect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    delete?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    connect?: SessionReflectionWhereUniqueInput | SessionReflectionWhereUniqueInput[]
    update?: SessionReflectionUpdateWithWhereUniqueWithoutMeetingInput | SessionReflectionUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: SessionReflectionUpdateManyWithWhereWithoutMeetingInput | SessionReflectionUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: SessionReflectionScalarWhereInput | SessionReflectionScalarWhereInput[]
  }

  export type MeetingCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<MeetingCreateWithoutAttendancesInput, MeetingUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutAttendancesInput
    connect?: MeetingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MeetingUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<MeetingCreateWithoutAttendancesInput, MeetingUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutAttendancesInput
    upsert?: MeetingUpsertWithoutAttendancesInput
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutAttendancesInput, MeetingUpdateWithoutAttendancesInput>, MeetingUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type MeetingCreateNestedOneWithoutMinutesInput = {
    create?: XOR<MeetingCreateWithoutMinutesInput, MeetingUncheckedCreateWithoutMinutesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutMinutesInput
    connect?: MeetingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMinutesCreatedInput = {
    create?: XOR<UserCreateWithoutMinutesCreatedInput, UserUncheckedCreateWithoutMinutesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMinutesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type MeetingUpdateOneRequiredWithoutMinutesNestedInput = {
    create?: XOR<MeetingCreateWithoutMinutesInput, MeetingUncheckedCreateWithoutMinutesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutMinutesInput
    upsert?: MeetingUpsertWithoutMinutesInput
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutMinutesInput, MeetingUpdateWithoutMinutesInput>, MeetingUncheckedUpdateWithoutMinutesInput>
  }

  export type UserUpdateOneRequiredWithoutMinutesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutMinutesCreatedInput, UserUncheckedCreateWithoutMinutesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMinutesCreatedInput
    upsert?: UserUpsertWithoutMinutesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMinutesCreatedInput, UserUpdateWithoutMinutesCreatedInput>, UserUncheckedUpdateWithoutMinutesCreatedInput>
  }

  export type MentorshipCreateNestedOneWithoutGoalsInput = {
    create?: XOR<MentorshipCreateWithoutGoalsInput, MentorshipUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutGoalsInput
    connect?: MentorshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGoalsCreatedInput = {
    create?: XOR<UserCreateWithoutGoalsCreatedInput, UserUncheckedCreateWithoutGoalsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ProgressNoteCreateNestedManyWithoutGoalInput = {
    create?: XOR<ProgressNoteCreateWithoutGoalInput, ProgressNoteUncheckedCreateWithoutGoalInput> | ProgressNoteCreateWithoutGoalInput[] | ProgressNoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressNoteCreateOrConnectWithoutGoalInput | ProgressNoteCreateOrConnectWithoutGoalInput[]
    createMany?: ProgressNoteCreateManyGoalInputEnvelope
    connect?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
  }

  export type ProgressNoteUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<ProgressNoteCreateWithoutGoalInput, ProgressNoteUncheckedCreateWithoutGoalInput> | ProgressNoteCreateWithoutGoalInput[] | ProgressNoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressNoteCreateOrConnectWithoutGoalInput | ProgressNoteCreateOrConnectWithoutGoalInput[]
    createMany?: ProgressNoteCreateManyGoalInputEnvelope
    connect?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
  }

  export type MentorshipUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<MentorshipCreateWithoutGoalsInput, MentorshipUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutGoalsInput
    upsert?: MentorshipUpsertWithoutGoalsInput
    connect?: MentorshipWhereUniqueInput
    update?: XOR<XOR<MentorshipUpdateToOneWithWhereWithoutGoalsInput, MentorshipUpdateWithoutGoalsInput>, MentorshipUncheckedUpdateWithoutGoalsInput>
  }

  export type UserUpdateOneRequiredWithoutGoalsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutGoalsCreatedInput, UserUncheckedCreateWithoutGoalsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalsCreatedInput
    upsert?: UserUpsertWithoutGoalsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGoalsCreatedInput, UserUpdateWithoutGoalsCreatedInput>, UserUncheckedUpdateWithoutGoalsCreatedInput>
  }

  export type ProgressNoteUpdateManyWithoutGoalNestedInput = {
    create?: XOR<ProgressNoteCreateWithoutGoalInput, ProgressNoteUncheckedCreateWithoutGoalInput> | ProgressNoteCreateWithoutGoalInput[] | ProgressNoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressNoteCreateOrConnectWithoutGoalInput | ProgressNoteCreateOrConnectWithoutGoalInput[]
    upsert?: ProgressNoteUpsertWithWhereUniqueWithoutGoalInput | ProgressNoteUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: ProgressNoteCreateManyGoalInputEnvelope
    set?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    disconnect?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    delete?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    connect?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    update?: ProgressNoteUpdateWithWhereUniqueWithoutGoalInput | ProgressNoteUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: ProgressNoteUpdateManyWithWhereWithoutGoalInput | ProgressNoteUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: ProgressNoteScalarWhereInput | ProgressNoteScalarWhereInput[]
  }

  export type ProgressNoteUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<ProgressNoteCreateWithoutGoalInput, ProgressNoteUncheckedCreateWithoutGoalInput> | ProgressNoteCreateWithoutGoalInput[] | ProgressNoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressNoteCreateOrConnectWithoutGoalInput | ProgressNoteCreateOrConnectWithoutGoalInput[]
    upsert?: ProgressNoteUpsertWithWhereUniqueWithoutGoalInput | ProgressNoteUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: ProgressNoteCreateManyGoalInputEnvelope
    set?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    disconnect?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    delete?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    connect?: ProgressNoteWhereUniqueInput | ProgressNoteWhereUniqueInput[]
    update?: ProgressNoteUpdateWithWhereUniqueWithoutGoalInput | ProgressNoteUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: ProgressNoteUpdateManyWithWhereWithoutGoalInput | ProgressNoteUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: ProgressNoteScalarWhereInput | ProgressNoteScalarWhereInput[]
  }

  export type GoalCreateNestedOneWithoutProgressNotesInput = {
    create?: XOR<GoalCreateWithoutProgressNotesInput, GoalUncheckedCreateWithoutProgressNotesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutProgressNotesInput
    connect?: GoalWhereUniqueInput
  }

  export type GoalUpdateOneRequiredWithoutProgressNotesNestedInput = {
    create?: XOR<GoalCreateWithoutProgressNotesInput, GoalUncheckedCreateWithoutProgressNotesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutProgressNotesInput
    upsert?: GoalUpsertWithoutProgressNotesInput
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutProgressNotesInput, GoalUpdateWithoutProgressNotesInput>, GoalUncheckedUpdateWithoutProgressNotesInput>
  }

  export type MentorshipCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<MentorshipCreateWithoutFeedbacksInput, MentorshipUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutFeedbacksInput
    connect?: MentorshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbackGivenInput = {
    create?: XOR<UserCreateWithoutFeedbackGivenInput, UserUncheckedCreateWithoutFeedbackGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbackReceivedInput = {
    create?: XOR<UserCreateWithoutFeedbackReceivedInput, UserUncheckedCreateWithoutFeedbackReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type MentorshipUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<MentorshipCreateWithoutFeedbacksInput, MentorshipUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutFeedbacksInput
    upsert?: MentorshipUpsertWithoutFeedbacksInput
    connect?: MentorshipWhereUniqueInput
    update?: XOR<XOR<MentorshipUpdateToOneWithWhereWithoutFeedbacksInput, MentorshipUpdateWithoutFeedbacksInput>, MentorshipUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateOneRequiredWithoutFeedbackGivenNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackGivenInput, UserUncheckedCreateWithoutFeedbackGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackGivenInput
    upsert?: UserUpsertWithoutFeedbackGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackGivenInput, UserUpdateWithoutFeedbackGivenInput>, UserUncheckedUpdateWithoutFeedbackGivenInput>
  }

  export type UserUpdateOneRequiredWithoutFeedbackReceivedNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackReceivedInput, UserUncheckedCreateWithoutFeedbackReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackReceivedInput
    upsert?: UserUpsertWithoutFeedbackReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackReceivedInput, UserUpdateWithoutFeedbackReceivedInput>, UserUncheckedUpdateWithoutFeedbackReceivedInput>
  }

  export type UserCreateNestedOneWithoutResourcesUploadedInput = {
    create?: XOR<UserCreateWithoutResourcesUploadedInput, UserUncheckedCreateWithoutResourcesUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesUploadedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResourcesUploadedNestedInput = {
    create?: XOR<UserCreateWithoutResourcesUploadedInput, UserUncheckedCreateWithoutResourcesUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesUploadedInput
    upsert?: UserUpsertWithoutResourcesUploadedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourcesUploadedInput, UserUpdateWithoutResourcesUploadedInput>, UserUncheckedUpdateWithoutResourcesUploadedInput>
  }

  export type UserCreateNestedOneWithoutPortfoliosInput = {
    create?: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfoliosInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPortfoliosNestedInput = {
    create?: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfoliosInput
    upsert?: UserUpsertWithoutPortfoliosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPortfoliosInput, UserUpdateWithoutPortfoliosInput>, UserUncheckedUpdateWithoutPortfoliosInput>
  }

  export type UserCreateNestedOneWithoutAvailabilitiesInput = {
    create?: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAvailabilitiesNestedInput = {
    create?: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilitiesInput
    upsert?: UserUpsertWithoutAvailabilitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAvailabilitiesInput, UserUpdateWithoutAvailabilitiesInput>, UserUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type MeetingCreateNestedOneWithoutSessionReflectionsInput = {
    create?: XOR<MeetingCreateWithoutSessionReflectionsInput, MeetingUncheckedCreateWithoutSessionReflectionsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutSessionReflectionsInput
    connect?: MeetingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionReflectionsInput = {
    create?: XOR<UserCreateWithoutSessionReflectionsInput, UserUncheckedCreateWithoutSessionReflectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionReflectionsInput
    connect?: UserWhereUniqueInput
  }

  export type TodoItemCreateNestedManyWithoutReflectionInput = {
    create?: XOR<TodoItemCreateWithoutReflectionInput, TodoItemUncheckedCreateWithoutReflectionInput> | TodoItemCreateWithoutReflectionInput[] | TodoItemUncheckedCreateWithoutReflectionInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutReflectionInput | TodoItemCreateOrConnectWithoutReflectionInput[]
    createMany?: TodoItemCreateManyReflectionInputEnvelope
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
  }

  export type TodoItemUncheckedCreateNestedManyWithoutReflectionInput = {
    create?: XOR<TodoItemCreateWithoutReflectionInput, TodoItemUncheckedCreateWithoutReflectionInput> | TodoItemCreateWithoutReflectionInput[] | TodoItemUncheckedCreateWithoutReflectionInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutReflectionInput | TodoItemCreateOrConnectWithoutReflectionInput[]
    createMany?: TodoItemCreateManyReflectionInputEnvelope
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
  }

  export type MeetingUpdateOneRequiredWithoutSessionReflectionsNestedInput = {
    create?: XOR<MeetingCreateWithoutSessionReflectionsInput, MeetingUncheckedCreateWithoutSessionReflectionsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutSessionReflectionsInput
    upsert?: MeetingUpsertWithoutSessionReflectionsInput
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutSessionReflectionsInput, MeetingUpdateWithoutSessionReflectionsInput>, MeetingUncheckedUpdateWithoutSessionReflectionsInput>
  }

  export type UserUpdateOneRequiredWithoutSessionReflectionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionReflectionsInput, UserUncheckedCreateWithoutSessionReflectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionReflectionsInput
    upsert?: UserUpsertWithoutSessionReflectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionReflectionsInput, UserUpdateWithoutSessionReflectionsInput>, UserUncheckedUpdateWithoutSessionReflectionsInput>
  }

  export type TodoItemUpdateManyWithoutReflectionNestedInput = {
    create?: XOR<TodoItemCreateWithoutReflectionInput, TodoItemUncheckedCreateWithoutReflectionInput> | TodoItemCreateWithoutReflectionInput[] | TodoItemUncheckedCreateWithoutReflectionInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutReflectionInput | TodoItemCreateOrConnectWithoutReflectionInput[]
    upsert?: TodoItemUpsertWithWhereUniqueWithoutReflectionInput | TodoItemUpsertWithWhereUniqueWithoutReflectionInput[]
    createMany?: TodoItemCreateManyReflectionInputEnvelope
    set?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    disconnect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    delete?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    update?: TodoItemUpdateWithWhereUniqueWithoutReflectionInput | TodoItemUpdateWithWhereUniqueWithoutReflectionInput[]
    updateMany?: TodoItemUpdateManyWithWhereWithoutReflectionInput | TodoItemUpdateManyWithWhereWithoutReflectionInput[]
    deleteMany?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
  }

  export type TodoItemUncheckedUpdateManyWithoutReflectionNestedInput = {
    create?: XOR<TodoItemCreateWithoutReflectionInput, TodoItemUncheckedCreateWithoutReflectionInput> | TodoItemCreateWithoutReflectionInput[] | TodoItemUncheckedCreateWithoutReflectionInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutReflectionInput | TodoItemCreateOrConnectWithoutReflectionInput[]
    upsert?: TodoItemUpsertWithWhereUniqueWithoutReflectionInput | TodoItemUpsertWithWhereUniqueWithoutReflectionInput[]
    createMany?: TodoItemCreateManyReflectionInputEnvelope
    set?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    disconnect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    delete?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    update?: TodoItemUpdateWithWhereUniqueWithoutReflectionInput | TodoItemUpdateWithWhereUniqueWithoutReflectionInput[]
    updateMany?: TodoItemUpdateManyWithWhereWithoutReflectionInput | TodoItemUpdateManyWithWhereWithoutReflectionInput[]
    deleteMany?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
  }

  export type SessionReflectionCreateNestedOneWithoutTodoItemsInput = {
    create?: XOR<SessionReflectionCreateWithoutTodoItemsInput, SessionReflectionUncheckedCreateWithoutTodoItemsInput>
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutTodoItemsInput
    connect?: SessionReflectionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTodoItemsInput = {
    create?: XOR<UserCreateWithoutTodoItemsInput, UserUncheckedCreateWithoutTodoItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodoItemsInput
    connect?: UserWhereUniqueInput
  }

  export type SessionReflectionUpdateOneWithoutTodoItemsNestedInput = {
    create?: XOR<SessionReflectionCreateWithoutTodoItemsInput, SessionReflectionUncheckedCreateWithoutTodoItemsInput>
    connectOrCreate?: SessionReflectionCreateOrConnectWithoutTodoItemsInput
    upsert?: SessionReflectionUpsertWithoutTodoItemsInput
    disconnect?: SessionReflectionWhereInput | boolean
    delete?: SessionReflectionWhereInput | boolean
    connect?: SessionReflectionWhereUniqueInput
    update?: XOR<XOR<SessionReflectionUpdateToOneWithWhereWithoutTodoItemsInput, SessionReflectionUpdateWithoutTodoItemsInput>, SessionReflectionUncheckedUpdateWithoutTodoItemsInput>
  }

  export type UserUpdateOneRequiredWithoutTodoItemsNestedInput = {
    create?: XOR<UserCreateWithoutTodoItemsInput, UserUncheckedCreateWithoutTodoItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodoItemsInput
    upsert?: UserUpsertWithoutTodoItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTodoItemsInput, UserUpdateWithoutTodoItemsInput>, UserUncheckedUpdateWithoutTodoItemsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutTicketsCreatedInput = {
    create?: XOR<UserCreateWithoutTicketsCreatedInput, UserUncheckedCreateWithoutTicketsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTicketsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTicketsCreatedInput, UserUncheckedCreateWithoutTicketsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsCreatedInput
    upsert?: UserUpsertWithoutTicketsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsCreatedInput, UserUpdateWithoutTicketsCreatedInput>, UserUncheckedUpdateWithoutTicketsCreatedInput>
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type SupportTicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCommentsInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketCommentsInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type SupportTicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCommentsInput
    upsert?: SupportTicketUpsertWithoutCommentsInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutCommentsInput, SupportTicketUpdateWithoutCommentsInput>, SupportTicketUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    upsert?: UserUpsertWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketCommentsInput, UserUpdateWithoutTicketCommentsInput>, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type UserCreateNestedOneWithoutWikiPagesInput = {
    create?: XOR<UserCreateWithoutWikiPagesInput, UserUncheckedCreateWithoutWikiPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWikiPagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWikiPagesNestedInput = {
    create?: XOR<UserCreateWithoutWikiPagesInput, UserUncheckedCreateWithoutWikiPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWikiPagesInput
    upsert?: UserUpsertWithoutWikiPagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWikiPagesInput, UserUpdateWithoutWikiPagesInput>, UserUncheckedUpdateWithoutWikiPagesInput>
  }

  export type UserCreateNestedOneWithoutWhiteboardsInput = {
    create?: XOR<UserCreateWithoutWhiteboardsInput, UserUncheckedCreateWithoutWhiteboardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhiteboardsInput
    connect?: UserWhereUniqueInput
  }

  export type ArtboardCreateNestedManyWithoutWhiteboardInput = {
    create?: XOR<ArtboardCreateWithoutWhiteboardInput, ArtboardUncheckedCreateWithoutWhiteboardInput> | ArtboardCreateWithoutWhiteboardInput[] | ArtboardUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: ArtboardCreateOrConnectWithoutWhiteboardInput | ArtboardCreateOrConnectWithoutWhiteboardInput[]
    createMany?: ArtboardCreateManyWhiteboardInputEnvelope
    connect?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
  }

  export type ArtboardUncheckedCreateNestedManyWithoutWhiteboardInput = {
    create?: XOR<ArtboardCreateWithoutWhiteboardInput, ArtboardUncheckedCreateWithoutWhiteboardInput> | ArtboardCreateWithoutWhiteboardInput[] | ArtboardUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: ArtboardCreateOrConnectWithoutWhiteboardInput | ArtboardCreateOrConnectWithoutWhiteboardInput[]
    createMany?: ArtboardCreateManyWhiteboardInputEnvelope
    connect?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWhiteboardsNestedInput = {
    create?: XOR<UserCreateWithoutWhiteboardsInput, UserUncheckedCreateWithoutWhiteboardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhiteboardsInput
    upsert?: UserUpsertWithoutWhiteboardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhiteboardsInput, UserUpdateWithoutWhiteboardsInput>, UserUncheckedUpdateWithoutWhiteboardsInput>
  }

  export type ArtboardUpdateManyWithoutWhiteboardNestedInput = {
    create?: XOR<ArtboardCreateWithoutWhiteboardInput, ArtboardUncheckedCreateWithoutWhiteboardInput> | ArtboardCreateWithoutWhiteboardInput[] | ArtboardUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: ArtboardCreateOrConnectWithoutWhiteboardInput | ArtboardCreateOrConnectWithoutWhiteboardInput[]
    upsert?: ArtboardUpsertWithWhereUniqueWithoutWhiteboardInput | ArtboardUpsertWithWhereUniqueWithoutWhiteboardInput[]
    createMany?: ArtboardCreateManyWhiteboardInputEnvelope
    set?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    disconnect?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    delete?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    connect?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    update?: ArtboardUpdateWithWhereUniqueWithoutWhiteboardInput | ArtboardUpdateWithWhereUniqueWithoutWhiteboardInput[]
    updateMany?: ArtboardUpdateManyWithWhereWithoutWhiteboardInput | ArtboardUpdateManyWithWhereWithoutWhiteboardInput[]
    deleteMany?: ArtboardScalarWhereInput | ArtboardScalarWhereInput[]
  }

  export type ArtboardUncheckedUpdateManyWithoutWhiteboardNestedInput = {
    create?: XOR<ArtboardCreateWithoutWhiteboardInput, ArtboardUncheckedCreateWithoutWhiteboardInput> | ArtboardCreateWithoutWhiteboardInput[] | ArtboardUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: ArtboardCreateOrConnectWithoutWhiteboardInput | ArtboardCreateOrConnectWithoutWhiteboardInput[]
    upsert?: ArtboardUpsertWithWhereUniqueWithoutWhiteboardInput | ArtboardUpsertWithWhereUniqueWithoutWhiteboardInput[]
    createMany?: ArtboardCreateManyWhiteboardInputEnvelope
    set?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    disconnect?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    delete?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    connect?: ArtboardWhereUniqueInput | ArtboardWhereUniqueInput[]
    update?: ArtboardUpdateWithWhereUniqueWithoutWhiteboardInput | ArtboardUpdateWithWhereUniqueWithoutWhiteboardInput[]
    updateMany?: ArtboardUpdateManyWithWhereWithoutWhiteboardInput | ArtboardUpdateManyWithWhereWithoutWhiteboardInput[]
    deleteMany?: ArtboardScalarWhereInput | ArtboardScalarWhereInput[]
  }

  export type WhiteboardCreateNestedOneWithoutArtboardsInput = {
    create?: XOR<WhiteboardCreateWithoutArtboardsInput, WhiteboardUncheckedCreateWithoutArtboardsInput>
    connectOrCreate?: WhiteboardCreateOrConnectWithoutArtboardsInput
    connect?: WhiteboardWhereUniqueInput
  }

  export type WhiteboardUpdateOneRequiredWithoutArtboardsNestedInput = {
    create?: XOR<WhiteboardCreateWithoutArtboardsInput, WhiteboardUncheckedCreateWithoutArtboardsInput>
    connectOrCreate?: WhiteboardCreateOrConnectWithoutArtboardsInput
    upsert?: WhiteboardUpsertWithoutArtboardsInput
    connect?: WhiteboardWhereUniqueInput
    update?: XOR<XOR<WhiteboardUpdateToOneWithWhereWithoutArtboardsInput, WhiteboardUpdateWithoutArtboardsInput>, WhiteboardUncheckedUpdateWithoutArtboardsInput>
  }

  export type UserCreateNestedOneWithoutSlidesInput = {
    create?: XOR<UserCreateWithoutSlidesInput, UserUncheckedCreateWithoutSlidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSlidesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSlidesNestedInput = {
    create?: XOR<UserCreateWithoutSlidesInput, UserUncheckedCreateWithoutSlidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSlidesInput
    upsert?: UserUpsertWithoutSlidesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSlidesInput, UserUpdateWithoutSlidesInput>, UserUncheckedUpdateWithoutSlidesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MentorProfileCreateWithoutUserInput = {
    id?: string
    company?: string | null
    jobTitle?: string | null
    expertise?: string | null
    experience?: string | null
    linkedIn?: string | null
    maxMentees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorProfileUncheckedCreateWithoutUserInput = {
    id?: string
    company?: string | null
    jobTitle?: string | null
    expertise?: string | null
    experience?: string | null
    linkedIn?: string | null
    maxMentees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorProfileCreateOrConnectWithoutUserInput = {
    where: MentorProfileWhereUniqueInput
    create: XOR<MentorProfileCreateWithoutUserInput, MentorProfileUncheckedCreateWithoutUserInput>
  }

  export type MenteeProfileCreateWithoutUserInput = {
    id?: string
    studentId?: string | null
    major?: string | null
    year?: number | null
    careerGoals?: string | null
    skills?: string | null
    strengths?: string | null
    weaknesses?: string | null
    currentChallenges?: string | null
    expectations?: string | null
    background?: string | null
    experience?: string | null
    endGoals?: string | null
    startupIdeas?: string | null
    personalNotes?: string | null
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenteeProfileUncheckedCreateWithoutUserInput = {
    id?: string
    studentId?: string | null
    major?: string | null
    year?: number | null
    careerGoals?: string | null
    skills?: string | null
    strengths?: string | null
    weaknesses?: string | null
    currentChallenges?: string | null
    expectations?: string | null
    background?: string | null
    experience?: string | null
    endGoals?: string | null
    startupIdeas?: string | null
    personalNotes?: string | null
    isOnboardingComplete?: boolean
    onboardingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenteeProfileCreateOrConnectWithoutUserInput = {
    where: MenteeProfileWhereUniqueInput
    create: XOR<MenteeProfileCreateWithoutUserInput, MenteeProfileUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipCreateWithoutMentorInput = {
    id?: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    programCycle: ProgramCycleCreateNestedOneWithoutMentorshipsInput
    mentees?: MentorshipMenteeCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingCreateNestedManyWithoutMentorshipInput
    goals?: GoalCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUncheckedCreateWithoutMentorInput = {
    id?: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentees?: MentorshipMenteeUncheckedCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutMentorshipInput
    goals?: GoalUncheckedCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipCreateOrConnectWithoutMentorInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput>
  }

  export type MentorshipCreateManyMentorInputEnvelope = {
    data: MentorshipCreateManyMentorInput | MentorshipCreateManyMentorInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipMenteeCreateWithoutMenteeInput = {
    id?: string
    joinedAt?: Date | string
    status?: string
    mentorship: MentorshipCreateNestedOneWithoutMenteesInput
  }

  export type MentorshipMenteeUncheckedCreateWithoutMenteeInput = {
    id?: string
    mentorshipId: string
    joinedAt?: Date | string
    status?: string
  }

  export type MentorshipMenteeCreateOrConnectWithoutMenteeInput = {
    where: MentorshipMenteeWhereUniqueInput
    create: XOR<MentorshipMenteeCreateWithoutMenteeInput, MentorshipMenteeUncheckedCreateWithoutMenteeInput>
  }

  export type MentorshipMenteeCreateManyMenteeInputEnvelope = {
    data: MentorshipMenteeCreateManyMenteeInput | MentorshipMenteeCreateManyMenteeInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutMeetingsInput
    attendances?: AttendanceCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutCreatorInput = {
    id?: string
    mentorshipId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesUncheckedCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput>
  }

  export type MeetingCreateManyCreatorInputEnvelope = {
    data: MeetingCreateManyCreatorInput | MeetingCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutUserInput = {
    id?: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    meetingId: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MeetingMinutesCreateWithoutAuthorInput = {
    id?: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutMinutesInput
  }

  export type MeetingMinutesUncheckedCreateWithoutAuthorInput = {
    id?: string
    meetingId: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingMinutesCreateOrConnectWithoutAuthorInput = {
    where: MeetingMinutesWhereUniqueInput
    create: XOR<MeetingMinutesCreateWithoutAuthorInput, MeetingMinutesUncheckedCreateWithoutAuthorInput>
  }

  export type MeetingMinutesCreateManyAuthorInputEnvelope = {
    data: MeetingMinutesCreateManyAuthorInput | MeetingMinutesCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutGoalsInput
    progressNotes?: ProgressNoteCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutCreatorInput = {
    id?: string
    mentorshipId: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    progressNotes?: ProgressNoteUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutCreatorInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutCreatorInput, GoalUncheckedCreateWithoutCreatorInput>
  }

  export type GoalCreateManyCreatorInputEnvelope = {
    data: GoalCreateManyCreatorInput | GoalCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutFromUserInput = {
    id?: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutFeedbacksInput
    toUser: UserCreateNestedOneWithoutFeedbackReceivedInput
  }

  export type FeedbackUncheckedCreateWithoutFromUserInput = {
    id?: string
    mentorshipId: string
    toUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutFromUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutFromUserInput, FeedbackUncheckedCreateWithoutFromUserInput>
  }

  export type FeedbackCreateManyFromUserInputEnvelope = {
    data: FeedbackCreateManyFromUserInput | FeedbackCreateManyFromUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutToUserInput = {
    id?: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutFeedbacksInput
    fromUser: UserCreateNestedOneWithoutFeedbackGivenInput
  }

  export type FeedbackUncheckedCreateWithoutToUserInput = {
    id?: string
    mentorshipId: string
    fromUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutToUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutToUserInput, FeedbackUncheckedCreateWithoutToUserInput>
  }

  export type FeedbackCreateManyToUserInputEnvelope = {
    data: FeedbackCreateManyToUserInput | FeedbackCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    fileUrl?: string | null
    linkUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    category?: string | null
    tags?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUncheckedCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    fileUrl?: string | null
    linkUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    category?: string | null
    tags?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateOrConnectWithoutUploadedByInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput>
  }

  export type ResourceCreateManyUploadedByInputEnvelope = {
    data: ResourceCreateManyUploadedByInput | ResourceCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    link?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    link?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioCreateWithoutMenteeInput = {
    id?: string
    personalityMbti?: string | null
    personalityDisc?: string | null
    personalityHolland?: string | null
    competencies?: string | null
    shortTermGoals?: string | null
    longTermGoals?: string | null
    initialCompletedAt?: Date | string | null
    initialStrengths?: string | null
    initialWeaknesses?: string | null
    initialChallenges?: string | null
    initialStartupIdeas?: string | null
    initialPersonalNotes?: string | null
    finalGoalsAchieved?: number | null
    finalSkillsGained?: string | null
    finalMentorFeedback?: string | null
    finalSelfAssessment?: string | null
    finalRecommendations?: string | null
    finalStrengths?: string | null
    finalWeaknesses?: string | null
    finalChallenges?: string | null
    finalStartupIdeas?: string | null
    finalPersonalNotes?: string | null
    finalCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioUncheckedCreateWithoutMenteeInput = {
    id?: string
    personalityMbti?: string | null
    personalityDisc?: string | null
    personalityHolland?: string | null
    competencies?: string | null
    shortTermGoals?: string | null
    longTermGoals?: string | null
    initialCompletedAt?: Date | string | null
    initialStrengths?: string | null
    initialWeaknesses?: string | null
    initialChallenges?: string | null
    initialStartupIdeas?: string | null
    initialPersonalNotes?: string | null
    finalGoalsAchieved?: number | null
    finalSkillsGained?: string | null
    finalMentorFeedback?: string | null
    finalSelfAssessment?: string | null
    finalRecommendations?: string | null
    finalStrengths?: string | null
    finalWeaknesses?: string | null
    finalChallenges?: string | null
    finalStartupIdeas?: string | null
    finalPersonalNotes?: string | null
    finalCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCreateOrConnectWithoutMenteeInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutMenteeInput, PortfolioUncheckedCreateWithoutMenteeInput>
  }

  export type PortfolioCreateManyMenteeInputEnvelope = {
    data: PortfolioCreateManyMenteeInput | PortfolioCreateManyMenteeInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityCreateWithoutUserInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUncheckedCreateWithoutUserInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateOrConnectWithoutUserInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutUserInput, AvailabilityUncheckedCreateWithoutUserInput>
  }

  export type AvailabilityCreateManyUserInputEnvelope = {
    data: AvailabilityCreateManyUserInput | AvailabilityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionReflectionCreateWithoutMenteeInput = {
    id?: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutSessionReflectionsInput
    todoItems?: TodoItemCreateNestedManyWithoutReflectionInput
  }

  export type SessionReflectionUncheckedCreateWithoutMenteeInput = {
    id?: string
    meetingId: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutReflectionInput
  }

  export type SessionReflectionCreateOrConnectWithoutMenteeInput = {
    where: SessionReflectionWhereUniqueInput
    create: XOR<SessionReflectionCreateWithoutMenteeInput, SessionReflectionUncheckedCreateWithoutMenteeInput>
  }

  export type SessionReflectionCreateManyMenteeInputEnvelope = {
    data: SessionReflectionCreateManyMenteeInput | SessionReflectionCreateManyMenteeInput[]
    skipDuplicates?: boolean
  }

  export type TodoItemCreateWithoutMenteeInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reflection?: SessionReflectionCreateNestedOneWithoutTodoItemsInput
  }

  export type TodoItemUncheckedCreateWithoutMenteeInput = {
    id?: string
    reflectionId?: string | null
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoItemCreateOrConnectWithoutMenteeInput = {
    where: TodoItemWhereUniqueInput
    create: XOR<TodoItemCreateWithoutMenteeInput, TodoItemUncheckedCreateWithoutMenteeInput>
  }

  export type TodoItemCreateManyMenteeInputEnvelope = {
    data: TodoItemCreateManyMenteeInput | TodoItemCreateManyMenteeInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityId?: string | null
    entityType?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityId?: string | null
    entityType?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsCreatedInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketCreateManyAssignedToInputEnvelope = {
    data: SupportTicketCreateManyAssignedToInput | SupportTicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutUserInput = {
    id?: string
    ticketId: string
    content: string
    createdAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentCreateManyUserInputEnvelope = {
    data: TicketCommentCreateManyUserInput | TicketCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WikiPageCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content?: string | null
    category?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content?: string | null
    category?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageCreateOrConnectWithoutAuthorInput = {
    where: WikiPageWhereUniqueInput
    create: XOR<WikiPageCreateWithoutAuthorInput, WikiPageUncheckedCreateWithoutAuthorInput>
  }

  export type WikiPageCreateManyAuthorInputEnvelope = {
    data: WikiPageCreateManyAuthorInput | WikiPageCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type WhiteboardCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    artboards?: ArtboardCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    artboards?: ArtboardUncheckedCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardCreateOrConnectWithoutCreatorInput = {
    where: WhiteboardWhereUniqueInput
    create: XOR<WhiteboardCreateWithoutCreatorInput, WhiteboardUncheckedCreateWithoutCreatorInput>
  }

  export type WhiteboardCreateManyCreatorInputEnvelope = {
    data: WhiteboardCreateManyCreatorInput | WhiteboardCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SlideCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    theme?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlideUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    theme?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlideCreateOrConnectWithoutCreatorInput = {
    where: SlideWhereUniqueInput
    create: XOR<SlideCreateWithoutCreatorInput, SlideUncheckedCreateWithoutCreatorInput>
  }

  export type SlideCreateManyCreatorInputEnvelope = {
    data: SlideCreateManyCreatorInput | SlideCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type MentorProfileUpsertWithoutUserInput = {
    update: XOR<MentorProfileUpdateWithoutUserInput, MentorProfileUncheckedUpdateWithoutUserInput>
    create: XOR<MentorProfileCreateWithoutUserInput, MentorProfileUncheckedCreateWithoutUserInput>
    where?: MentorProfileWhereInput
  }

  export type MentorProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: MentorProfileWhereInput
    data: XOR<MentorProfileUpdateWithoutUserInput, MentorProfileUncheckedUpdateWithoutUserInput>
  }

  export type MentorProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    linkedIn?: NullableStringFieldUpdateOperationsInput | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    linkedIn?: NullableStringFieldUpdateOperationsInput | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeProfileUpsertWithoutUserInput = {
    update: XOR<MenteeProfileUpdateWithoutUserInput, MenteeProfileUncheckedUpdateWithoutUserInput>
    create: XOR<MenteeProfileCreateWithoutUserInput, MenteeProfileUncheckedCreateWithoutUserInput>
    where?: MenteeProfileWhereInput
  }

  export type MenteeProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: MenteeProfileWhereInput
    data: XOR<MenteeProfileUpdateWithoutUserInput, MenteeProfileUncheckedUpdateWithoutUserInput>
  }

  export type MenteeProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    careerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    endGoals?: NullableStringFieldUpdateOperationsInput | string | null
    startupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    personalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    careerGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    endGoals?: NullableStringFieldUpdateOperationsInput | string | null
    startupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    personalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type MentorshipUpsertWithWhereUniqueWithoutMentorInput = {
    where: MentorshipWhereUniqueInput
    update: XOR<MentorshipUpdateWithoutMentorInput, MentorshipUncheckedUpdateWithoutMentorInput>
    create: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput>
  }

  export type MentorshipUpdateWithWhereUniqueWithoutMentorInput = {
    where: MentorshipWhereUniqueInput
    data: XOR<MentorshipUpdateWithoutMentorInput, MentorshipUncheckedUpdateWithoutMentorInput>
  }

  export type MentorshipUpdateManyWithWhereWithoutMentorInput = {
    where: MentorshipScalarWhereInput
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyWithoutMentorInput>
  }

  export type MentorshipScalarWhereInput = {
    AND?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
    OR?: MentorshipScalarWhereInput[]
    NOT?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
    id?: StringFilter<"Mentorship"> | string
    mentorId?: StringFilter<"Mentorship"> | string
    type?: StringFilter<"Mentorship"> | string
    status?: StringFilter<"Mentorship"> | string
    programCycleId?: StringFilter<"Mentorship"> | string
    startDate?: DateTimeFilter<"Mentorship"> | Date | string
    endDate?: DateTimeFilter<"Mentorship"> | Date | string
    maxMentees?: IntFilter<"Mentorship"> | number
    notes?: StringNullableFilter<"Mentorship"> | string | null
    createdAt?: DateTimeFilter<"Mentorship"> | Date | string
    updatedAt?: DateTimeFilter<"Mentorship"> | Date | string
  }

  export type MentorshipMenteeUpsertWithWhereUniqueWithoutMenteeInput = {
    where: MentorshipMenteeWhereUniqueInput
    update: XOR<MentorshipMenteeUpdateWithoutMenteeInput, MentorshipMenteeUncheckedUpdateWithoutMenteeInput>
    create: XOR<MentorshipMenteeCreateWithoutMenteeInput, MentorshipMenteeUncheckedCreateWithoutMenteeInput>
  }

  export type MentorshipMenteeUpdateWithWhereUniqueWithoutMenteeInput = {
    where: MentorshipMenteeWhereUniqueInput
    data: XOR<MentorshipMenteeUpdateWithoutMenteeInput, MentorshipMenteeUncheckedUpdateWithoutMenteeInput>
  }

  export type MentorshipMenteeUpdateManyWithWhereWithoutMenteeInput = {
    where: MentorshipMenteeScalarWhereInput
    data: XOR<MentorshipMenteeUpdateManyMutationInput, MentorshipMenteeUncheckedUpdateManyWithoutMenteeInput>
  }

  export type MentorshipMenteeScalarWhereInput = {
    AND?: MentorshipMenteeScalarWhereInput | MentorshipMenteeScalarWhereInput[]
    OR?: MentorshipMenteeScalarWhereInput[]
    NOT?: MentorshipMenteeScalarWhereInput | MentorshipMenteeScalarWhereInput[]
    id?: StringFilter<"MentorshipMentee"> | string
    mentorshipId?: StringFilter<"MentorshipMentee"> | string
    menteeId?: StringFilter<"MentorshipMentee"> | string
    joinedAt?: DateTimeFilter<"MentorshipMentee"> | Date | string
    status?: StringFilter<"MentorshipMentee"> | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutCreatorInput, MeetingUncheckedUpdateWithoutCreatorInput>
    create: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutCreatorInput, MeetingUncheckedUpdateWithoutCreatorInput>
  }

  export type MeetingUpdateManyWithWhereWithoutCreatorInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutCreatorInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: StringFilter<"Meeting"> | string
    mentorshipId?: StringFilter<"Meeting"> | string
    creatorId?: StringFilter<"Meeting"> | string
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    type?: StringFilter<"Meeting"> | string
    meetingType?: StringFilter<"Meeting"> | string
    scheduledAt?: DateTimeFilter<"Meeting"> | Date | string
    duration?: IntFilter<"Meeting"> | number
    location?: StringNullableFilter<"Meeting"> | string | null
    meetingUrl?: StringNullableFilter<"Meeting"> | string | null
    status?: StringFilter<"Meeting"> | string
    qrToken?: StringNullableFilter<"Meeting"> | string | null
    qrExpiresAt?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    meetingId?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    checkInTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkInLat?: FloatNullableFilter<"Attendance"> | number | null
    checkInLng?: FloatNullableFilter<"Attendance"> | number | null
    deviceHash?: StringNullableFilter<"Attendance"> | string | null
    status?: StringFilter<"Attendance"> | string
    verifiedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type MeetingMinutesUpsertWithWhereUniqueWithoutAuthorInput = {
    where: MeetingMinutesWhereUniqueInput
    update: XOR<MeetingMinutesUpdateWithoutAuthorInput, MeetingMinutesUncheckedUpdateWithoutAuthorInput>
    create: XOR<MeetingMinutesCreateWithoutAuthorInput, MeetingMinutesUncheckedCreateWithoutAuthorInput>
  }

  export type MeetingMinutesUpdateWithWhereUniqueWithoutAuthorInput = {
    where: MeetingMinutesWhereUniqueInput
    data: XOR<MeetingMinutesUpdateWithoutAuthorInput, MeetingMinutesUncheckedUpdateWithoutAuthorInput>
  }

  export type MeetingMinutesUpdateManyWithWhereWithoutAuthorInput = {
    where: MeetingMinutesScalarWhereInput
    data: XOR<MeetingMinutesUpdateManyMutationInput, MeetingMinutesUncheckedUpdateManyWithoutAuthorInput>
  }

  export type MeetingMinutesScalarWhereInput = {
    AND?: MeetingMinutesScalarWhereInput | MeetingMinutesScalarWhereInput[]
    OR?: MeetingMinutesScalarWhereInput[]
    NOT?: MeetingMinutesScalarWhereInput | MeetingMinutesScalarWhereInput[]
    id?: StringFilter<"MeetingMinutes"> | string
    meetingId?: StringFilter<"MeetingMinutes"> | string
    authorId?: StringFilter<"MeetingMinutes"> | string
    agenda?: StringNullableFilter<"MeetingMinutes"> | string | null
    keyPoints?: StringNullableFilter<"MeetingMinutes"> | string | null
    actionItems?: StringNullableFilter<"MeetingMinutes"> | string | null
    outcome?: StringNullableFilter<"MeetingMinutes"> | string | null
    attachments?: StringNullableFilter<"MeetingMinutes"> | string | null
    status?: StringFilter<"MeetingMinutes"> | string
    submittedAt?: DateTimeNullableFilter<"MeetingMinutes"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"MeetingMinutes"> | Date | string | null
    createdAt?: DateTimeFilter<"MeetingMinutes"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingMinutes"> | Date | string
  }

  export type GoalUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutCreatorInput, GoalUncheckedUpdateWithoutCreatorInput>
    create: XOR<GoalCreateWithoutCreatorInput, GoalUncheckedCreateWithoutCreatorInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutCreatorInput, GoalUncheckedUpdateWithoutCreatorInput>
  }

  export type GoalUpdateManyWithWhereWithoutCreatorInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutCreatorInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: StringFilter<"Goal"> | string
    mentorshipId?: StringFilter<"Goal"> | string
    creatorId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringFilter<"Goal"> | string
    targetValue?: IntNullableFilter<"Goal"> | number | null
    currentValue?: IntFilter<"Goal"> | number
    unit?: StringNullableFilter<"Goal"> | string | null
    status?: StringFilter<"Goal"> | string
    priority?: StringFilter<"Goal"> | string
    dueDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    mentorConfirmed?: BoolFilter<"Goal"> | boolean
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutFromUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutFromUserInput, FeedbackUncheckedUpdateWithoutFromUserInput>
    create: XOR<FeedbackCreateWithoutFromUserInput, FeedbackUncheckedCreateWithoutFromUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutFromUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutFromUserInput, FeedbackUncheckedUpdateWithoutFromUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutFromUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFromUserInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter<"Feedback"> | string
    mentorshipId?: StringFilter<"Feedback"> | string
    fromUserId?: StringFilter<"Feedback"> | string
    toUserId?: StringFilter<"Feedback"> | string
    type?: StringFilter<"Feedback"> | string
    rating?: IntNullableFilter<"Feedback"> | number | null
    communication?: IntNullableFilter<"Feedback"> | number | null
    engagement?: IntNullableFilter<"Feedback"> | number | null
    content?: StringNullableFilter<"Feedback"> | string | null
    strengths?: StringNullableFilter<"Feedback"> | string | null
    improvements?: StringNullableFilter<"Feedback"> | string | null
    isAnonymous?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutToUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutToUserInput, FeedbackUncheckedUpdateWithoutToUserInput>
    create: XOR<FeedbackCreateWithoutToUserInput, FeedbackUncheckedCreateWithoutToUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutToUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutToUserInput, FeedbackUncheckedUpdateWithoutToUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutToUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutToUserInput>
  }

  export type ResourceUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutUploadedByInput, ResourceUncheckedUpdateWithoutUploadedByInput>
    create: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutUploadedByInput, ResourceUncheckedUpdateWithoutUploadedByInput>
  }

  export type ResourceUpdateManyWithWhereWithoutUploadedByInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    type?: StringFilter<"Resource"> | string
    fileUrl?: StringNullableFilter<"Resource"> | string | null
    linkUrl?: StringNullableFilter<"Resource"> | string | null
    fileName?: StringNullableFilter<"Resource"> | string | null
    fileSize?: IntNullableFilter<"Resource"> | number | null
    mimeType?: StringNullableFilter<"Resource"> | string | null
    category?: StringNullableFilter<"Resource"> | string | null
    tags?: StringNullableFilter<"Resource"> | string | null
    visibility?: StringFilter<"Resource"> | string
    uploadedById?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PortfolioUpsertWithWhereUniqueWithoutMenteeInput = {
    where: PortfolioWhereUniqueInput
    update: XOR<PortfolioUpdateWithoutMenteeInput, PortfolioUncheckedUpdateWithoutMenteeInput>
    create: XOR<PortfolioCreateWithoutMenteeInput, PortfolioUncheckedCreateWithoutMenteeInput>
  }

  export type PortfolioUpdateWithWhereUniqueWithoutMenteeInput = {
    where: PortfolioWhereUniqueInput
    data: XOR<PortfolioUpdateWithoutMenteeInput, PortfolioUncheckedUpdateWithoutMenteeInput>
  }

  export type PortfolioUpdateManyWithWhereWithoutMenteeInput = {
    where: PortfolioScalarWhereInput
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyWithoutMenteeInput>
  }

  export type PortfolioScalarWhereInput = {
    AND?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    OR?: PortfolioScalarWhereInput[]
    NOT?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    id?: StringFilter<"Portfolio"> | string
    menteeId?: StringFilter<"Portfolio"> | string
    personalityMbti?: StringNullableFilter<"Portfolio"> | string | null
    personalityDisc?: StringNullableFilter<"Portfolio"> | string | null
    personalityHolland?: StringNullableFilter<"Portfolio"> | string | null
    competencies?: StringNullableFilter<"Portfolio"> | string | null
    shortTermGoals?: StringNullableFilter<"Portfolio"> | string | null
    longTermGoals?: StringNullableFilter<"Portfolio"> | string | null
    initialCompletedAt?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    initialStrengths?: StringNullableFilter<"Portfolio"> | string | null
    initialWeaknesses?: StringNullableFilter<"Portfolio"> | string | null
    initialChallenges?: StringNullableFilter<"Portfolio"> | string | null
    initialStartupIdeas?: StringNullableFilter<"Portfolio"> | string | null
    initialPersonalNotes?: StringNullableFilter<"Portfolio"> | string | null
    finalGoalsAchieved?: IntNullableFilter<"Portfolio"> | number | null
    finalSkillsGained?: StringNullableFilter<"Portfolio"> | string | null
    finalMentorFeedback?: StringNullableFilter<"Portfolio"> | string | null
    finalSelfAssessment?: StringNullableFilter<"Portfolio"> | string | null
    finalRecommendations?: StringNullableFilter<"Portfolio"> | string | null
    finalStrengths?: StringNullableFilter<"Portfolio"> | string | null
    finalWeaknesses?: StringNullableFilter<"Portfolio"> | string | null
    finalChallenges?: StringNullableFilter<"Portfolio"> | string | null
    finalStartupIdeas?: StringNullableFilter<"Portfolio"> | string | null
    finalPersonalNotes?: StringNullableFilter<"Portfolio"> | string | null
    finalCompletedAt?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutUserInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutUserInput, AvailabilityUncheckedUpdateWithoutUserInput>
    create: XOR<AvailabilityCreateWithoutUserInput, AvailabilityUncheckedCreateWithoutUserInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutUserInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutUserInput, AvailabilityUncheckedUpdateWithoutUserInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutUserInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutUserInput>
  }

  export type AvailabilityScalarWhereInput = {
    AND?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    OR?: AvailabilityScalarWhereInput[]
    NOT?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    id?: StringFilter<"Availability"> | string
    userId?: StringFilter<"Availability"> | string
    dayOfWeek?: IntFilter<"Availability"> | number
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    duration?: IntFilter<"Availability"> | number
    isActive?: BoolFilter<"Availability"> | boolean
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
  }

  export type SessionReflectionUpsertWithWhereUniqueWithoutMenteeInput = {
    where: SessionReflectionWhereUniqueInput
    update: XOR<SessionReflectionUpdateWithoutMenteeInput, SessionReflectionUncheckedUpdateWithoutMenteeInput>
    create: XOR<SessionReflectionCreateWithoutMenteeInput, SessionReflectionUncheckedCreateWithoutMenteeInput>
  }

  export type SessionReflectionUpdateWithWhereUniqueWithoutMenteeInput = {
    where: SessionReflectionWhereUniqueInput
    data: XOR<SessionReflectionUpdateWithoutMenteeInput, SessionReflectionUncheckedUpdateWithoutMenteeInput>
  }

  export type SessionReflectionUpdateManyWithWhereWithoutMenteeInput = {
    where: SessionReflectionScalarWhereInput
    data: XOR<SessionReflectionUpdateManyMutationInput, SessionReflectionUncheckedUpdateManyWithoutMenteeInput>
  }

  export type SessionReflectionScalarWhereInput = {
    AND?: SessionReflectionScalarWhereInput | SessionReflectionScalarWhereInput[]
    OR?: SessionReflectionScalarWhereInput[]
    NOT?: SessionReflectionScalarWhereInput | SessionReflectionScalarWhereInput[]
    id?: StringFilter<"SessionReflection"> | string
    meetingId?: StringFilter<"SessionReflection"> | string
    menteeId?: StringFilter<"SessionReflection"> | string
    content?: StringNullableFilter<"SessionReflection"> | string | null
    mentorConfirmed?: BoolFilter<"SessionReflection"> | boolean
    createdAt?: DateTimeFilter<"SessionReflection"> | Date | string
    updatedAt?: DateTimeFilter<"SessionReflection"> | Date | string
  }

  export type TodoItemUpsertWithWhereUniqueWithoutMenteeInput = {
    where: TodoItemWhereUniqueInput
    update: XOR<TodoItemUpdateWithoutMenteeInput, TodoItemUncheckedUpdateWithoutMenteeInput>
    create: XOR<TodoItemCreateWithoutMenteeInput, TodoItemUncheckedCreateWithoutMenteeInput>
  }

  export type TodoItemUpdateWithWhereUniqueWithoutMenteeInput = {
    where: TodoItemWhereUniqueInput
    data: XOR<TodoItemUpdateWithoutMenteeInput, TodoItemUncheckedUpdateWithoutMenteeInput>
  }

  export type TodoItemUpdateManyWithWhereWithoutMenteeInput = {
    where: TodoItemScalarWhereInput
    data: XOR<TodoItemUpdateManyMutationInput, TodoItemUncheckedUpdateManyWithoutMenteeInput>
  }

  export type TodoItemScalarWhereInput = {
    AND?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
    OR?: TodoItemScalarWhereInput[]
    NOT?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
    id?: StringFilter<"TodoItem"> | string
    reflectionId?: StringNullableFilter<"TodoItem"> | string | null
    menteeId?: StringFilter<"TodoItem"> | string
    title?: StringFilter<"TodoItem"> | string
    status?: StringFilter<"TodoItem"> | string
    priority?: StringFilter<"TodoItem"> | string
    dueDate?: DateTimeNullableFilter<"TodoItem"> | Date | string | null
    startDate?: DateTimeNullableFilter<"TodoItem"> | Date | string | null
    column?: StringFilter<"TodoItem"> | string
    labels?: StringNullableFilter<"TodoItem"> | string | null
    description?: StringNullableFilter<"TodoItem"> | string | null
    attachments?: StringNullableFilter<"TodoItem"> | string | null
    comments?: StringNullableFilter<"TodoItem"> | string | null
    createdAt?: DateTimeFilter<"TodoItem"> | Date | string
    updatedAt?: DateTimeFilter<"TodoItem"> | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    entityType?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutUserInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    userId?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
  }

  export type WikiPageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: WikiPageWhereUniqueInput
    update: XOR<WikiPageUpdateWithoutAuthorInput, WikiPageUncheckedUpdateWithoutAuthorInput>
    create: XOR<WikiPageCreateWithoutAuthorInput, WikiPageUncheckedCreateWithoutAuthorInput>
  }

  export type WikiPageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: WikiPageWhereUniqueInput
    data: XOR<WikiPageUpdateWithoutAuthorInput, WikiPageUncheckedUpdateWithoutAuthorInput>
  }

  export type WikiPageUpdateManyWithWhereWithoutAuthorInput = {
    where: WikiPageScalarWhereInput
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyWithoutAuthorInput>
  }

  export type WikiPageScalarWhereInput = {
    AND?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
    OR?: WikiPageScalarWhereInput[]
    NOT?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
    id?: StringFilter<"WikiPage"> | string
    title?: StringFilter<"WikiPage"> | string
    slug?: StringFilter<"WikiPage"> | string
    content?: StringNullableFilter<"WikiPage"> | string | null
    category?: StringNullableFilter<"WikiPage"> | string | null
    visibility?: StringFilter<"WikiPage"> | string
    authorId?: StringFilter<"WikiPage"> | string
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
  }

  export type WhiteboardUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WhiteboardWhereUniqueInput
    update: XOR<WhiteboardUpdateWithoutCreatorInput, WhiteboardUncheckedUpdateWithoutCreatorInput>
    create: XOR<WhiteboardCreateWithoutCreatorInput, WhiteboardUncheckedCreateWithoutCreatorInput>
  }

  export type WhiteboardUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WhiteboardWhereUniqueInput
    data: XOR<WhiteboardUpdateWithoutCreatorInput, WhiteboardUncheckedUpdateWithoutCreatorInput>
  }

  export type WhiteboardUpdateManyWithWhereWithoutCreatorInput = {
    where: WhiteboardScalarWhereInput
    data: XOR<WhiteboardUpdateManyMutationInput, WhiteboardUncheckedUpdateManyWithoutCreatorInput>
  }

  export type WhiteboardScalarWhereInput = {
    AND?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
    OR?: WhiteboardScalarWhereInput[]
    NOT?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
    id?: StringFilter<"Whiteboard"> | string
    title?: StringFilter<"Whiteboard"> | string
    description?: StringNullableFilter<"Whiteboard"> | string | null
    thumbnail?: StringNullableFilter<"Whiteboard"> | string | null
    status?: StringFilter<"Whiteboard"> | string
    creatorId?: StringFilter<"Whiteboard"> | string
    createdAt?: DateTimeFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeFilter<"Whiteboard"> | Date | string
  }

  export type SlideUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SlideWhereUniqueInput
    update: XOR<SlideUpdateWithoutCreatorInput, SlideUncheckedUpdateWithoutCreatorInput>
    create: XOR<SlideCreateWithoutCreatorInput, SlideUncheckedCreateWithoutCreatorInput>
  }

  export type SlideUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SlideWhereUniqueInput
    data: XOR<SlideUpdateWithoutCreatorInput, SlideUncheckedUpdateWithoutCreatorInput>
  }

  export type SlideUpdateManyWithWhereWithoutCreatorInput = {
    where: SlideScalarWhereInput
    data: XOR<SlideUpdateManyMutationInput, SlideUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SlideScalarWhereInput = {
    AND?: SlideScalarWhereInput | SlideScalarWhereInput[]
    OR?: SlideScalarWhereInput[]
    NOT?: SlideScalarWhereInput | SlideScalarWhereInput[]
    id?: StringFilter<"Slide"> | string
    title?: StringFilter<"Slide"> | string
    description?: StringNullableFilter<"Slide"> | string | null
    content?: StringNullableFilter<"Slide"> | string | null
    theme?: StringFilter<"Slide"> | string
    status?: StringFilter<"Slide"> | string
    creatorId?: StringFilter<"Slide"> | string
    createdAt?: DateTimeFilter<"Slide"> | Date | string
    updatedAt?: DateTimeFilter<"Slide"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutMentorProfileInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMentorProfileInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMentorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentorProfileInput, UserUncheckedCreateWithoutMentorProfileInput>
  }

  export type UserUpsertWithoutMentorProfileInput = {
    update: XOR<UserUpdateWithoutMentorProfileInput, UserUncheckedUpdateWithoutMentorProfileInput>
    create: XOR<UserCreateWithoutMentorProfileInput, UserUncheckedCreateWithoutMentorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentorProfileInput, UserUncheckedUpdateWithoutMentorProfileInput>
  }

  export type UserUpdateWithoutMentorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMentorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutMenteeProfileInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMenteeProfileInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMenteeProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMenteeProfileInput, UserUncheckedCreateWithoutMenteeProfileInput>
  }

  export type UserUpsertWithoutMenteeProfileInput = {
    update: XOR<UserUpdateWithoutMenteeProfileInput, UserUncheckedUpdateWithoutMenteeProfileInput>
    create: XOR<UserCreateWithoutMenteeProfileInput, UserUncheckedCreateWithoutMenteeProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMenteeProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMenteeProfileInput, UserUncheckedUpdateWithoutMenteeProfileInput>
  }

  export type UserUpdateWithoutMenteeProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMenteeProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MentorshipCreateWithoutProgramCycleInput = {
    id?: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentor: UserCreateNestedOneWithoutMentorshipsInput
    mentees?: MentorshipMenteeCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingCreateNestedManyWithoutMentorshipInput
    goals?: GoalCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUncheckedCreateWithoutProgramCycleInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentees?: MentorshipMenteeUncheckedCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutMentorshipInput
    goals?: GoalUncheckedCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipCreateOrConnectWithoutProgramCycleInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutProgramCycleInput, MentorshipUncheckedCreateWithoutProgramCycleInput>
  }

  export type MentorshipCreateManyProgramCycleInputEnvelope = {
    data: MentorshipCreateManyProgramCycleInput | MentorshipCreateManyProgramCycleInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipUpsertWithWhereUniqueWithoutProgramCycleInput = {
    where: MentorshipWhereUniqueInput
    update: XOR<MentorshipUpdateWithoutProgramCycleInput, MentorshipUncheckedUpdateWithoutProgramCycleInput>
    create: XOR<MentorshipCreateWithoutProgramCycleInput, MentorshipUncheckedCreateWithoutProgramCycleInput>
  }

  export type MentorshipUpdateWithWhereUniqueWithoutProgramCycleInput = {
    where: MentorshipWhereUniqueInput
    data: XOR<MentorshipUpdateWithoutProgramCycleInput, MentorshipUncheckedUpdateWithoutProgramCycleInput>
  }

  export type MentorshipUpdateManyWithWhereWithoutProgramCycleInput = {
    where: MentorshipScalarWhereInput
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyWithoutProgramCycleInput>
  }

  export type UserCreateWithoutMentorshipsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMentorshipsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMentorshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentorshipsInput, UserUncheckedCreateWithoutMentorshipsInput>
  }

  export type ProgramCycleCreateWithoutMentorshipsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCycleUncheckedCreateWithoutMentorshipsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCycleCreateOrConnectWithoutMentorshipsInput = {
    where: ProgramCycleWhereUniqueInput
    create: XOR<ProgramCycleCreateWithoutMentorshipsInput, ProgramCycleUncheckedCreateWithoutMentorshipsInput>
  }

  export type MentorshipMenteeCreateWithoutMentorshipInput = {
    id?: string
    joinedAt?: Date | string
    status?: string
    mentee: UserCreateNestedOneWithoutMenteeshipsInput
  }

  export type MentorshipMenteeUncheckedCreateWithoutMentorshipInput = {
    id?: string
    menteeId: string
    joinedAt?: Date | string
    status?: string
  }

  export type MentorshipMenteeCreateOrConnectWithoutMentorshipInput = {
    where: MentorshipMenteeWhereUniqueInput
    create: XOR<MentorshipMenteeCreateWithoutMentorshipInput, MentorshipMenteeUncheckedCreateWithoutMentorshipInput>
  }

  export type MentorshipMenteeCreateManyMentorshipInputEnvelope = {
    data: MentorshipMenteeCreateManyMentorshipInput | MentorshipMenteeCreateManyMentorshipInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutMentorshipInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutMeetingsCreatedInput
    attendances?: AttendanceCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutMentorshipInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesUncheckedCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutMentorshipInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutMentorshipInput, MeetingUncheckedCreateWithoutMentorshipInput>
  }

  export type MeetingCreateManyMentorshipInputEnvelope = {
    data: MeetingCreateManyMentorshipInput | MeetingCreateManyMentorshipInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutMentorshipInput = {
    id?: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutGoalsCreatedInput
    progressNotes?: ProgressNoteCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutMentorshipInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    progressNotes?: ProgressNoteUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutMentorshipInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutMentorshipInput, GoalUncheckedCreateWithoutMentorshipInput>
  }

  export type GoalCreateManyMentorshipInputEnvelope = {
    data: GoalCreateManyMentorshipInput | GoalCreateManyMentorshipInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutMentorshipInput = {
    id?: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUser: UserCreateNestedOneWithoutFeedbackGivenInput
    toUser: UserCreateNestedOneWithoutFeedbackReceivedInput
  }

  export type FeedbackUncheckedCreateWithoutMentorshipInput = {
    id?: string
    fromUserId: string
    toUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutMentorshipInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutMentorshipInput, FeedbackUncheckedCreateWithoutMentorshipInput>
  }

  export type FeedbackCreateManyMentorshipInputEnvelope = {
    data: FeedbackCreateManyMentorshipInput | FeedbackCreateManyMentorshipInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMentorshipsInput = {
    update: XOR<UserUpdateWithoutMentorshipsInput, UserUncheckedUpdateWithoutMentorshipsInput>
    create: XOR<UserCreateWithoutMentorshipsInput, UserUncheckedCreateWithoutMentorshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentorshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentorshipsInput, UserUncheckedUpdateWithoutMentorshipsInput>
  }

  export type UserUpdateWithoutMentorshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMentorshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProgramCycleUpsertWithoutMentorshipsInput = {
    update: XOR<ProgramCycleUpdateWithoutMentorshipsInput, ProgramCycleUncheckedUpdateWithoutMentorshipsInput>
    create: XOR<ProgramCycleCreateWithoutMentorshipsInput, ProgramCycleUncheckedCreateWithoutMentorshipsInput>
    where?: ProgramCycleWhereInput
  }

  export type ProgramCycleUpdateToOneWithWhereWithoutMentorshipsInput = {
    where?: ProgramCycleWhereInput
    data: XOR<ProgramCycleUpdateWithoutMentorshipsInput, ProgramCycleUncheckedUpdateWithoutMentorshipsInput>
  }

  export type ProgramCycleUpdateWithoutMentorshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCycleUncheckedUpdateWithoutMentorshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipMenteeUpsertWithWhereUniqueWithoutMentorshipInput = {
    where: MentorshipMenteeWhereUniqueInput
    update: XOR<MentorshipMenteeUpdateWithoutMentorshipInput, MentorshipMenteeUncheckedUpdateWithoutMentorshipInput>
    create: XOR<MentorshipMenteeCreateWithoutMentorshipInput, MentorshipMenteeUncheckedCreateWithoutMentorshipInput>
  }

  export type MentorshipMenteeUpdateWithWhereUniqueWithoutMentorshipInput = {
    where: MentorshipMenteeWhereUniqueInput
    data: XOR<MentorshipMenteeUpdateWithoutMentorshipInput, MentorshipMenteeUncheckedUpdateWithoutMentorshipInput>
  }

  export type MentorshipMenteeUpdateManyWithWhereWithoutMentorshipInput = {
    where: MentorshipMenteeScalarWhereInput
    data: XOR<MentorshipMenteeUpdateManyMutationInput, MentorshipMenteeUncheckedUpdateManyWithoutMentorshipInput>
  }

  export type MeetingUpsertWithWhereUniqueWithoutMentorshipInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutMentorshipInput, MeetingUncheckedUpdateWithoutMentorshipInput>
    create: XOR<MeetingCreateWithoutMentorshipInput, MeetingUncheckedCreateWithoutMentorshipInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutMentorshipInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutMentorshipInput, MeetingUncheckedUpdateWithoutMentorshipInput>
  }

  export type MeetingUpdateManyWithWhereWithoutMentorshipInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutMentorshipInput>
  }

  export type GoalUpsertWithWhereUniqueWithoutMentorshipInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutMentorshipInput, GoalUncheckedUpdateWithoutMentorshipInput>
    create: XOR<GoalCreateWithoutMentorshipInput, GoalUncheckedCreateWithoutMentorshipInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutMentorshipInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutMentorshipInput, GoalUncheckedUpdateWithoutMentorshipInput>
  }

  export type GoalUpdateManyWithWhereWithoutMentorshipInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutMentorshipInput>
  }

  export type FeedbackUpsertWithWhereUniqueWithoutMentorshipInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutMentorshipInput, FeedbackUncheckedUpdateWithoutMentorshipInput>
    create: XOR<FeedbackCreateWithoutMentorshipInput, FeedbackUncheckedCreateWithoutMentorshipInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutMentorshipInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutMentorshipInput, FeedbackUncheckedUpdateWithoutMentorshipInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutMentorshipInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutMentorshipInput>
  }

  export type MentorshipCreateWithoutMenteesInput = {
    id?: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentor: UserCreateNestedOneWithoutMentorshipsInput
    programCycle: ProgramCycleCreateNestedOneWithoutMentorshipsInput
    meetings?: MeetingCreateNestedManyWithoutMentorshipInput
    goals?: GoalCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUncheckedCreateWithoutMenteesInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetings?: MeetingUncheckedCreateNestedManyWithoutMentorshipInput
    goals?: GoalUncheckedCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipCreateOrConnectWithoutMenteesInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutMenteesInput, MentorshipUncheckedCreateWithoutMenteesInput>
  }

  export type UserCreateWithoutMenteeshipsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMenteeshipsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMenteeshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMenteeshipsInput, UserUncheckedCreateWithoutMenteeshipsInput>
  }

  export type MentorshipUpsertWithoutMenteesInput = {
    update: XOR<MentorshipUpdateWithoutMenteesInput, MentorshipUncheckedUpdateWithoutMenteesInput>
    create: XOR<MentorshipCreateWithoutMenteesInput, MentorshipUncheckedCreateWithoutMenteesInput>
    where?: MentorshipWhereInput
  }

  export type MentorshipUpdateToOneWithWhereWithoutMenteesInput = {
    where?: MentorshipWhereInput
    data: XOR<MentorshipUpdateWithoutMenteesInput, MentorshipUncheckedUpdateWithoutMenteesInput>
  }

  export type MentorshipUpdateWithoutMenteesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor?: UserUpdateOneRequiredWithoutMentorshipsNestedInput
    programCycle?: ProgramCycleUpdateOneRequiredWithoutMentorshipsNestedInput
    meetings?: MeetingUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutMenteesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetings?: MeetingUncheckedUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUncheckedUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutMentorshipNestedInput
  }

  export type UserUpsertWithoutMenteeshipsInput = {
    update: XOR<UserUpdateWithoutMenteeshipsInput, UserUncheckedUpdateWithoutMenteeshipsInput>
    create: XOR<UserCreateWithoutMenteeshipsInput, UserUncheckedCreateWithoutMenteeshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMenteeshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMenteeshipsInput, UserUncheckedUpdateWithoutMenteeshipsInput>
  }

  export type UserUpdateWithoutMenteeshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMenteeshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MentorshipCreateWithoutMeetingsInput = {
    id?: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentor: UserCreateNestedOneWithoutMentorshipsInput
    programCycle: ProgramCycleCreateNestedOneWithoutMentorshipsInput
    mentees?: MentorshipMenteeCreateNestedManyWithoutMentorshipInput
    goals?: GoalCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUncheckedCreateWithoutMeetingsInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentees?: MentorshipMenteeUncheckedCreateNestedManyWithoutMentorshipInput
    goals?: GoalUncheckedCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipCreateOrConnectWithoutMeetingsInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutMeetingsInput, MentorshipUncheckedCreateWithoutMeetingsInput>
  }

  export type UserCreateWithoutMeetingsCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMeetingsCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMeetingsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
  }

  export type AttendanceCreateWithoutMeetingInput = {
    id?: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutMeetingInput = {
    id?: string
    userId: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutMeetingInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutMeetingInput, AttendanceUncheckedCreateWithoutMeetingInput>
  }

  export type AttendanceCreateManyMeetingInputEnvelope = {
    data: AttendanceCreateManyMeetingInput | AttendanceCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type MeetingMinutesCreateWithoutMeetingInput = {
    id?: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutMinutesCreatedInput
  }

  export type MeetingMinutesUncheckedCreateWithoutMeetingInput = {
    id?: string
    authorId: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingMinutesCreateOrConnectWithoutMeetingInput = {
    where: MeetingMinutesWhereUniqueInput
    create: XOR<MeetingMinutesCreateWithoutMeetingInput, MeetingMinutesUncheckedCreateWithoutMeetingInput>
  }

  export type MeetingMinutesCreateManyMeetingInputEnvelope = {
    data: MeetingMinutesCreateManyMeetingInput | MeetingMinutesCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type SessionReflectionCreateWithoutMeetingInput = {
    id?: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentee: UserCreateNestedOneWithoutSessionReflectionsInput
    todoItems?: TodoItemCreateNestedManyWithoutReflectionInput
  }

  export type SessionReflectionUncheckedCreateWithoutMeetingInput = {
    id?: string
    menteeId: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutReflectionInput
  }

  export type SessionReflectionCreateOrConnectWithoutMeetingInput = {
    where: SessionReflectionWhereUniqueInput
    create: XOR<SessionReflectionCreateWithoutMeetingInput, SessionReflectionUncheckedCreateWithoutMeetingInput>
  }

  export type SessionReflectionCreateManyMeetingInputEnvelope = {
    data: SessionReflectionCreateManyMeetingInput | SessionReflectionCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipUpsertWithoutMeetingsInput = {
    update: XOR<MentorshipUpdateWithoutMeetingsInput, MentorshipUncheckedUpdateWithoutMeetingsInput>
    create: XOR<MentorshipCreateWithoutMeetingsInput, MentorshipUncheckedCreateWithoutMeetingsInput>
    where?: MentorshipWhereInput
  }

  export type MentorshipUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: MentorshipWhereInput
    data: XOR<MentorshipUpdateWithoutMeetingsInput, MentorshipUncheckedUpdateWithoutMeetingsInput>
  }

  export type MentorshipUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor?: UserUpdateOneRequiredWithoutMentorshipsNestedInput
    programCycle?: ProgramCycleUpdateOneRequiredWithoutMentorshipsNestedInput
    mentees?: MentorshipMenteeUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentees?: MentorshipMenteeUncheckedUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUncheckedUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutMentorshipNestedInput
  }

  export type UserUpsertWithoutMeetingsCreatedInput = {
    update: XOR<UserUpdateWithoutMeetingsCreatedInput, UserUncheckedUpdateWithoutMeetingsCreatedInput>
    create: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeetingsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeetingsCreatedInput, UserUncheckedUpdateWithoutMeetingsCreatedInput>
  }

  export type UserUpdateWithoutMeetingsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMeetingsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutMeetingInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutMeetingInput, AttendanceUncheckedUpdateWithoutMeetingInput>
    create: XOR<AttendanceCreateWithoutMeetingInput, AttendanceUncheckedCreateWithoutMeetingInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutMeetingInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutMeetingInput, AttendanceUncheckedUpdateWithoutMeetingInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutMeetingInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutMeetingInput>
  }

  export type MeetingMinutesUpsertWithWhereUniqueWithoutMeetingInput = {
    where: MeetingMinutesWhereUniqueInput
    update: XOR<MeetingMinutesUpdateWithoutMeetingInput, MeetingMinutesUncheckedUpdateWithoutMeetingInput>
    create: XOR<MeetingMinutesCreateWithoutMeetingInput, MeetingMinutesUncheckedCreateWithoutMeetingInput>
  }

  export type MeetingMinutesUpdateWithWhereUniqueWithoutMeetingInput = {
    where: MeetingMinutesWhereUniqueInput
    data: XOR<MeetingMinutesUpdateWithoutMeetingInput, MeetingMinutesUncheckedUpdateWithoutMeetingInput>
  }

  export type MeetingMinutesUpdateManyWithWhereWithoutMeetingInput = {
    where: MeetingMinutesScalarWhereInput
    data: XOR<MeetingMinutesUpdateManyMutationInput, MeetingMinutesUncheckedUpdateManyWithoutMeetingInput>
  }

  export type SessionReflectionUpsertWithWhereUniqueWithoutMeetingInput = {
    where: SessionReflectionWhereUniqueInput
    update: XOR<SessionReflectionUpdateWithoutMeetingInput, SessionReflectionUncheckedUpdateWithoutMeetingInput>
    create: XOR<SessionReflectionCreateWithoutMeetingInput, SessionReflectionUncheckedCreateWithoutMeetingInput>
  }

  export type SessionReflectionUpdateWithWhereUniqueWithoutMeetingInput = {
    where: SessionReflectionWhereUniqueInput
    data: XOR<SessionReflectionUpdateWithoutMeetingInput, SessionReflectionUncheckedUpdateWithoutMeetingInput>
  }

  export type SessionReflectionUpdateManyWithWhereWithoutMeetingInput = {
    where: SessionReflectionScalarWhereInput
    data: XOR<SessionReflectionUpdateManyMutationInput, SessionReflectionUncheckedUpdateManyWithoutMeetingInput>
  }

  export type MeetingCreateWithoutAttendancesInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutMeetingsInput
    creator: UserCreateNestedOneWithoutMeetingsCreatedInput
    minutes?: MeetingMinutesCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutAttendancesInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    minutes?: MeetingMinutesUncheckedCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutAttendancesInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutAttendancesInput, MeetingUncheckedCreateWithoutAttendancesInput>
  }

  export type UserCreateWithoutAttendancesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type MeetingUpsertWithoutAttendancesInput = {
    update: XOR<MeetingUpdateWithoutAttendancesInput, MeetingUncheckedUpdateWithoutAttendancesInput>
    create: XOR<MeetingCreateWithoutAttendancesInput, MeetingUncheckedCreateWithoutAttendancesInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutAttendancesInput, MeetingUncheckedUpdateWithoutAttendancesInput>
  }

  export type MeetingUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutMeetingsNestedInput
    creator?: UserUpdateOneRequiredWithoutMeetingsCreatedNestedInput
    minutes?: MeetingMinutesUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minutes?: MeetingMinutesUncheckedUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MeetingCreateWithoutMinutesInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutMeetingsInput
    creator: UserCreateNestedOneWithoutMeetingsCreatedInput
    attendances?: AttendanceCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutMinutesInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMeetingInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutMinutesInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutMinutesInput, MeetingUncheckedCreateWithoutMinutesInput>
  }

  export type UserCreateWithoutMinutesCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMinutesCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMinutesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMinutesCreatedInput, UserUncheckedCreateWithoutMinutesCreatedInput>
  }

  export type MeetingUpsertWithoutMinutesInput = {
    update: XOR<MeetingUpdateWithoutMinutesInput, MeetingUncheckedUpdateWithoutMinutesInput>
    create: XOR<MeetingCreateWithoutMinutesInput, MeetingUncheckedCreateWithoutMinutesInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutMinutesInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutMinutesInput, MeetingUncheckedUpdateWithoutMinutesInput>
  }

  export type MeetingUpdateWithoutMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutMeetingsNestedInput
    creator?: UserUpdateOneRequiredWithoutMeetingsCreatedNestedInput
    attendances?: AttendanceUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type UserUpsertWithoutMinutesCreatedInput = {
    update: XOR<UserUpdateWithoutMinutesCreatedInput, UserUncheckedUpdateWithoutMinutesCreatedInput>
    create: XOR<UserCreateWithoutMinutesCreatedInput, UserUncheckedCreateWithoutMinutesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMinutesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMinutesCreatedInput, UserUncheckedUpdateWithoutMinutesCreatedInput>
  }

  export type UserUpdateWithoutMinutesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMinutesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MentorshipCreateWithoutGoalsInput = {
    id?: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentor: UserCreateNestedOneWithoutMentorshipsInput
    programCycle: ProgramCycleCreateNestedOneWithoutMentorshipsInput
    mentees?: MentorshipMenteeCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUncheckedCreateWithoutGoalsInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentees?: MentorshipMenteeUncheckedCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutMentorshipInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipCreateOrConnectWithoutGoalsInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutGoalsInput, MentorshipUncheckedCreateWithoutGoalsInput>
  }

  export type UserCreateWithoutGoalsCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutGoalsCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutGoalsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGoalsCreatedInput, UserUncheckedCreateWithoutGoalsCreatedInput>
  }

  export type ProgressNoteCreateWithoutGoalInput = {
    id?: string
    note: string
    value?: number | null
    createdAt?: Date | string
  }

  export type ProgressNoteUncheckedCreateWithoutGoalInput = {
    id?: string
    note: string
    value?: number | null
    createdAt?: Date | string
  }

  export type ProgressNoteCreateOrConnectWithoutGoalInput = {
    where: ProgressNoteWhereUniqueInput
    create: XOR<ProgressNoteCreateWithoutGoalInput, ProgressNoteUncheckedCreateWithoutGoalInput>
  }

  export type ProgressNoteCreateManyGoalInputEnvelope = {
    data: ProgressNoteCreateManyGoalInput | ProgressNoteCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipUpsertWithoutGoalsInput = {
    update: XOR<MentorshipUpdateWithoutGoalsInput, MentorshipUncheckedUpdateWithoutGoalsInput>
    create: XOR<MentorshipCreateWithoutGoalsInput, MentorshipUncheckedCreateWithoutGoalsInput>
    where?: MentorshipWhereInput
  }

  export type MentorshipUpdateToOneWithWhereWithoutGoalsInput = {
    where?: MentorshipWhereInput
    data: XOR<MentorshipUpdateWithoutGoalsInput, MentorshipUncheckedUpdateWithoutGoalsInput>
  }

  export type MentorshipUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor?: UserUpdateOneRequiredWithoutMentorshipsNestedInput
    programCycle?: ProgramCycleUpdateOneRequiredWithoutMentorshipsNestedInput
    mentees?: MentorshipMenteeUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentees?: MentorshipMenteeUncheckedUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutMentorshipNestedInput
  }

  export type UserUpsertWithoutGoalsCreatedInput = {
    update: XOR<UserUpdateWithoutGoalsCreatedInput, UserUncheckedUpdateWithoutGoalsCreatedInput>
    create: XOR<UserCreateWithoutGoalsCreatedInput, UserUncheckedCreateWithoutGoalsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGoalsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGoalsCreatedInput, UserUncheckedUpdateWithoutGoalsCreatedInput>
  }

  export type UserUpdateWithoutGoalsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutGoalsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProgressNoteUpsertWithWhereUniqueWithoutGoalInput = {
    where: ProgressNoteWhereUniqueInput
    update: XOR<ProgressNoteUpdateWithoutGoalInput, ProgressNoteUncheckedUpdateWithoutGoalInput>
    create: XOR<ProgressNoteCreateWithoutGoalInput, ProgressNoteUncheckedCreateWithoutGoalInput>
  }

  export type ProgressNoteUpdateWithWhereUniqueWithoutGoalInput = {
    where: ProgressNoteWhereUniqueInput
    data: XOR<ProgressNoteUpdateWithoutGoalInput, ProgressNoteUncheckedUpdateWithoutGoalInput>
  }

  export type ProgressNoteUpdateManyWithWhereWithoutGoalInput = {
    where: ProgressNoteScalarWhereInput
    data: XOR<ProgressNoteUpdateManyMutationInput, ProgressNoteUncheckedUpdateManyWithoutGoalInput>
  }

  export type ProgressNoteScalarWhereInput = {
    AND?: ProgressNoteScalarWhereInput | ProgressNoteScalarWhereInput[]
    OR?: ProgressNoteScalarWhereInput[]
    NOT?: ProgressNoteScalarWhereInput | ProgressNoteScalarWhereInput[]
    id?: StringFilter<"ProgressNote"> | string
    goalId?: StringFilter<"ProgressNote"> | string
    note?: StringFilter<"ProgressNote"> | string
    value?: IntNullableFilter<"ProgressNote"> | number | null
    createdAt?: DateTimeFilter<"ProgressNote"> | Date | string
  }

  export type GoalCreateWithoutProgressNotesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutGoalsInput
    creator: UserCreateNestedOneWithoutGoalsCreatedInput
  }

  export type GoalUncheckedCreateWithoutProgressNotesInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCreateOrConnectWithoutProgressNotesInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutProgressNotesInput, GoalUncheckedCreateWithoutProgressNotesInput>
  }

  export type GoalUpsertWithoutProgressNotesInput = {
    update: XOR<GoalUpdateWithoutProgressNotesInput, GoalUncheckedUpdateWithoutProgressNotesInput>
    create: XOR<GoalCreateWithoutProgressNotesInput, GoalUncheckedCreateWithoutProgressNotesInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutProgressNotesInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutProgressNotesInput, GoalUncheckedUpdateWithoutProgressNotesInput>
  }

  export type GoalUpdateWithoutProgressNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutGoalsNestedInput
    creator?: UserUpdateOneRequiredWithoutGoalsCreatedNestedInput
  }

  export type GoalUncheckedUpdateWithoutProgressNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipCreateWithoutFeedbacksInput = {
    id?: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentor: UserCreateNestedOneWithoutMentorshipsInput
    programCycle: ProgramCycleCreateNestedOneWithoutMentorshipsInput
    mentees?: MentorshipMenteeCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingCreateNestedManyWithoutMentorshipInput
    goals?: GoalCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentees?: MentorshipMenteeUncheckedCreateNestedManyWithoutMentorshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutMentorshipInput
    goals?: GoalUncheckedCreateNestedManyWithoutMentorshipInput
  }

  export type MentorshipCreateOrConnectWithoutFeedbacksInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutFeedbacksInput, MentorshipUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserCreateWithoutFeedbackGivenInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFeedbackGivenInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFeedbackGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackGivenInput, UserUncheckedCreateWithoutFeedbackGivenInput>
  }

  export type UserCreateWithoutFeedbackReceivedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFeedbackReceivedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFeedbackReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackReceivedInput, UserUncheckedCreateWithoutFeedbackReceivedInput>
  }

  export type MentorshipUpsertWithoutFeedbacksInput = {
    update: XOR<MentorshipUpdateWithoutFeedbacksInput, MentorshipUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<MentorshipCreateWithoutFeedbacksInput, MentorshipUncheckedCreateWithoutFeedbacksInput>
    where?: MentorshipWhereInput
  }

  export type MentorshipUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: MentorshipWhereInput
    data: XOR<MentorshipUpdateWithoutFeedbacksInput, MentorshipUncheckedUpdateWithoutFeedbacksInput>
  }

  export type MentorshipUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor?: UserUpdateOneRequiredWithoutMentorshipsNestedInput
    programCycle?: ProgramCycleUpdateOneRequiredWithoutMentorshipsNestedInput
    mentees?: MentorshipMenteeUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentees?: MentorshipMenteeUncheckedUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUncheckedUpdateManyWithoutMentorshipNestedInput
  }

  export type UserUpsertWithoutFeedbackGivenInput = {
    update: XOR<UserUpdateWithoutFeedbackGivenInput, UserUncheckedUpdateWithoutFeedbackGivenInput>
    create: XOR<UserCreateWithoutFeedbackGivenInput, UserUncheckedCreateWithoutFeedbackGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackGivenInput, UserUncheckedUpdateWithoutFeedbackGivenInput>
  }

  export type UserUpdateWithoutFeedbackGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutFeedbackReceivedInput = {
    update: XOR<UserUpdateWithoutFeedbackReceivedInput, UserUncheckedUpdateWithoutFeedbackReceivedInput>
    create: XOR<UserCreateWithoutFeedbackReceivedInput, UserUncheckedCreateWithoutFeedbackReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackReceivedInput, UserUncheckedUpdateWithoutFeedbackReceivedInput>
  }

  export type UserUpdateWithoutFeedbackReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutResourcesUploadedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutResourcesUploadedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutResourcesUploadedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourcesUploadedInput, UserUncheckedCreateWithoutResourcesUploadedInput>
  }

  export type UserUpsertWithoutResourcesUploadedInput = {
    update: XOR<UserUpdateWithoutResourcesUploadedInput, UserUncheckedUpdateWithoutResourcesUploadedInput>
    create: XOR<UserCreateWithoutResourcesUploadedInput, UserUncheckedCreateWithoutResourcesUploadedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourcesUploadedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourcesUploadedInput, UserUncheckedUpdateWithoutResourcesUploadedInput>
  }

  export type UserUpdateWithoutResourcesUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutResourcesUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPortfoliosInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPortfoliosInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPortfoliosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
  }

  export type UserUpsertWithoutPortfoliosInput = {
    update: XOR<UserUpdateWithoutPortfoliosInput, UserUncheckedUpdateWithoutPortfoliosInput>
    create: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPortfoliosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPortfoliosInput, UserUncheckedUpdateWithoutPortfoliosInput>
  }

  export type UserUpdateWithoutPortfoliosInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPortfoliosInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAvailabilitiesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAvailabilitiesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAvailabilitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
  }

  export type UserUpsertWithoutAvailabilitiesInput = {
    update: XOR<UserUpdateWithoutAvailabilitiesInput, UserUncheckedUpdateWithoutAvailabilitiesInput>
    create: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAvailabilitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAvailabilitiesInput, UserUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type UserUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MeetingCreateWithoutSessionReflectionsInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorship: MentorshipCreateNestedOneWithoutMeetingsInput
    creator: UserCreateNestedOneWithoutMeetingsCreatedInput
    attendances?: AttendanceCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutSessionReflectionsInput = {
    id?: string
    mentorshipId: string
    creatorId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMeetingInput
    minutes?: MeetingMinutesUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutSessionReflectionsInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutSessionReflectionsInput, MeetingUncheckedCreateWithoutSessionReflectionsInput>
  }

  export type UserCreateWithoutSessionReflectionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSessionReflectionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSessionReflectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionReflectionsInput, UserUncheckedCreateWithoutSessionReflectionsInput>
  }

  export type TodoItemCreateWithoutReflectionInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mentee: UserCreateNestedOneWithoutTodoItemsInput
  }

  export type TodoItemUncheckedCreateWithoutReflectionInput = {
    id?: string
    menteeId: string
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoItemCreateOrConnectWithoutReflectionInput = {
    where: TodoItemWhereUniqueInput
    create: XOR<TodoItemCreateWithoutReflectionInput, TodoItemUncheckedCreateWithoutReflectionInput>
  }

  export type TodoItemCreateManyReflectionInputEnvelope = {
    data: TodoItemCreateManyReflectionInput | TodoItemCreateManyReflectionInput[]
    skipDuplicates?: boolean
  }

  export type MeetingUpsertWithoutSessionReflectionsInput = {
    update: XOR<MeetingUpdateWithoutSessionReflectionsInput, MeetingUncheckedUpdateWithoutSessionReflectionsInput>
    create: XOR<MeetingCreateWithoutSessionReflectionsInput, MeetingUncheckedCreateWithoutSessionReflectionsInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutSessionReflectionsInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutSessionReflectionsInput, MeetingUncheckedUpdateWithoutSessionReflectionsInput>
  }

  export type MeetingUpdateWithoutSessionReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutMeetingsNestedInput
    creator?: UserUpdateOneRequiredWithoutMeetingsCreatedNestedInput
    attendances?: AttendanceUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutSessionReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type UserUpsertWithoutSessionReflectionsInput = {
    update: XOR<UserUpdateWithoutSessionReflectionsInput, UserUncheckedUpdateWithoutSessionReflectionsInput>
    create: XOR<UserCreateWithoutSessionReflectionsInput, UserUncheckedCreateWithoutSessionReflectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionReflectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionReflectionsInput, UserUncheckedUpdateWithoutSessionReflectionsInput>
  }

  export type UserUpdateWithoutSessionReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TodoItemUpsertWithWhereUniqueWithoutReflectionInput = {
    where: TodoItemWhereUniqueInput
    update: XOR<TodoItemUpdateWithoutReflectionInput, TodoItemUncheckedUpdateWithoutReflectionInput>
    create: XOR<TodoItemCreateWithoutReflectionInput, TodoItemUncheckedCreateWithoutReflectionInput>
  }

  export type TodoItemUpdateWithWhereUniqueWithoutReflectionInput = {
    where: TodoItemWhereUniqueInput
    data: XOR<TodoItemUpdateWithoutReflectionInput, TodoItemUncheckedUpdateWithoutReflectionInput>
  }

  export type TodoItemUpdateManyWithWhereWithoutReflectionInput = {
    where: TodoItemScalarWhereInput
    data: XOR<TodoItemUpdateManyMutationInput, TodoItemUncheckedUpdateManyWithoutReflectionInput>
  }

  export type SessionReflectionCreateWithoutTodoItemsInput = {
    id?: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutSessionReflectionsInput
    mentee: UserCreateNestedOneWithoutSessionReflectionsInput
  }

  export type SessionReflectionUncheckedCreateWithoutTodoItemsInput = {
    id?: string
    meetingId: string
    menteeId: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionReflectionCreateOrConnectWithoutTodoItemsInput = {
    where: SessionReflectionWhereUniqueInput
    create: XOR<SessionReflectionCreateWithoutTodoItemsInput, SessionReflectionUncheckedCreateWithoutTodoItemsInput>
  }

  export type UserCreateWithoutTodoItemsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTodoItemsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTodoItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTodoItemsInput, UserUncheckedCreateWithoutTodoItemsInput>
  }

  export type SessionReflectionUpsertWithoutTodoItemsInput = {
    update: XOR<SessionReflectionUpdateWithoutTodoItemsInput, SessionReflectionUncheckedUpdateWithoutTodoItemsInput>
    create: XOR<SessionReflectionCreateWithoutTodoItemsInput, SessionReflectionUncheckedCreateWithoutTodoItemsInput>
    where?: SessionReflectionWhereInput
  }

  export type SessionReflectionUpdateToOneWithWhereWithoutTodoItemsInput = {
    where?: SessionReflectionWhereInput
    data: XOR<SessionReflectionUpdateWithoutTodoItemsInput, SessionReflectionUncheckedUpdateWithoutTodoItemsInput>
  }

  export type SessionReflectionUpdateWithoutTodoItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutSessionReflectionsNestedInput
    mentee?: UserUpdateOneRequiredWithoutSessionReflectionsNestedInput
  }

  export type SessionReflectionUncheckedUpdateWithoutTodoItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTodoItemsInput = {
    update: XOR<UserUpdateWithoutTodoItemsInput, UserUncheckedUpdateWithoutTodoItemsInput>
    create: XOR<UserCreateWithoutTodoItemsInput, UserUncheckedCreateWithoutTodoItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTodoItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTodoItemsInput, UserUncheckedUpdateWithoutTodoItemsInput>
  }

  export type UserUpdateWithoutTodoItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTodoItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutTicketsCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTicketsCreatedInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTicketsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsCreatedInput, UserUncheckedCreateWithoutTicketsCreatedInput>
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type TicketCommentCreateWithoutTicketInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTicketsCreatedInput = {
    update: XOR<UserUpdateWithoutTicketsCreatedInput, UserUncheckedUpdateWithoutTicketsCreatedInput>
    create: XOR<UserCreateWithoutTicketsCreatedInput, UserUncheckedCreateWithoutTicketsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsCreatedInput, UserUncheckedUpdateWithoutTicketsCreatedInput>
  }

  export type UserUpdateWithoutTicketsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type SupportTicketCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsCreatedInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    userId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutCommentsInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTicketCommentsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTicketCommentsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTicketCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
  }

  export type SupportTicketUpsertWithoutCommentsInput = {
    update: XOR<SupportTicketUpdateWithoutCommentsInput, SupportTicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutCommentsInput, SupportTicketUncheckedUpdateWithoutCommentsInput>
  }

  export type SupportTicketUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsCreatedNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTicketCommentsInput = {
    update: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type UserUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutWikiPagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutWikiPagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutWikiPagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWikiPagesInput, UserUncheckedCreateWithoutWikiPagesInput>
  }

  export type UserUpsertWithoutWikiPagesInput = {
    update: XOR<UserUpdateWithoutWikiPagesInput, UserUncheckedUpdateWithoutWikiPagesInput>
    create: XOR<UserCreateWithoutWikiPagesInput, UserUncheckedCreateWithoutWikiPagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWikiPagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWikiPagesInput, UserUncheckedUpdateWithoutWikiPagesInput>
  }

  export type UserUpdateWithoutWikiPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutWikiPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutWhiteboardsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    slides?: SlideCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutWhiteboardsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    slides?: SlideUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutWhiteboardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhiteboardsInput, UserUncheckedCreateWithoutWhiteboardsInput>
  }

  export type ArtboardCreateWithoutWhiteboardInput = {
    id?: string
    order?: number
    name?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtboardUncheckedCreateWithoutWhiteboardInput = {
    id?: string
    order?: number
    name?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtboardCreateOrConnectWithoutWhiteboardInput = {
    where: ArtboardWhereUniqueInput
    create: XOR<ArtboardCreateWithoutWhiteboardInput, ArtboardUncheckedCreateWithoutWhiteboardInput>
  }

  export type ArtboardCreateManyWhiteboardInputEnvelope = {
    data: ArtboardCreateManyWhiteboardInput | ArtboardCreateManyWhiteboardInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWhiteboardsInput = {
    update: XOR<UserUpdateWithoutWhiteboardsInput, UserUncheckedUpdateWithoutWhiteboardsInput>
    create: XOR<UserCreateWithoutWhiteboardsInput, UserUncheckedCreateWithoutWhiteboardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhiteboardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhiteboardsInput, UserUncheckedUpdateWithoutWhiteboardsInput>
  }

  export type UserUpdateWithoutWhiteboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    slides?: SlideUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutWhiteboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    slides?: SlideUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ArtboardUpsertWithWhereUniqueWithoutWhiteboardInput = {
    where: ArtboardWhereUniqueInput
    update: XOR<ArtboardUpdateWithoutWhiteboardInput, ArtboardUncheckedUpdateWithoutWhiteboardInput>
    create: XOR<ArtboardCreateWithoutWhiteboardInput, ArtboardUncheckedCreateWithoutWhiteboardInput>
  }

  export type ArtboardUpdateWithWhereUniqueWithoutWhiteboardInput = {
    where: ArtboardWhereUniqueInput
    data: XOR<ArtboardUpdateWithoutWhiteboardInput, ArtboardUncheckedUpdateWithoutWhiteboardInput>
  }

  export type ArtboardUpdateManyWithWhereWithoutWhiteboardInput = {
    where: ArtboardScalarWhereInput
    data: XOR<ArtboardUpdateManyMutationInput, ArtboardUncheckedUpdateManyWithoutWhiteboardInput>
  }

  export type ArtboardScalarWhereInput = {
    AND?: ArtboardScalarWhereInput | ArtboardScalarWhereInput[]
    OR?: ArtboardScalarWhereInput[]
    NOT?: ArtboardScalarWhereInput | ArtboardScalarWhereInput[]
    id?: StringFilter<"Artboard"> | string
    whiteboardId?: StringFilter<"Artboard"> | string
    order?: IntFilter<"Artboard"> | number
    name?: StringNullableFilter<"Artboard"> | string | null
    elements?: JsonNullableFilter<"Artboard">
    appState?: JsonNullableFilter<"Artboard">
    createdAt?: DateTimeFilter<"Artboard"> | Date | string
    updatedAt?: DateTimeFilter<"Artboard"> | Date | string
  }

  export type WhiteboardCreateWithoutArtboardsInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutWhiteboardsInput
  }

  export type WhiteboardUncheckedCreateWithoutArtboardsInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhiteboardCreateOrConnectWithoutArtboardsInput = {
    where: WhiteboardWhereUniqueInput
    create: XOR<WhiteboardCreateWithoutArtboardsInput, WhiteboardUncheckedCreateWithoutArtboardsInput>
  }

  export type WhiteboardUpsertWithoutArtboardsInput = {
    update: XOR<WhiteboardUpdateWithoutArtboardsInput, WhiteboardUncheckedUpdateWithoutArtboardsInput>
    create: XOR<WhiteboardCreateWithoutArtboardsInput, WhiteboardUncheckedCreateWithoutArtboardsInput>
    where?: WhiteboardWhereInput
  }

  export type WhiteboardUpdateToOneWithWhereWithoutArtboardsInput = {
    where?: WhiteboardWhereInput
    data: XOR<WhiteboardUpdateWithoutArtboardsInput, WhiteboardUncheckedUpdateWithoutArtboardsInput>
  }

  export type WhiteboardUpdateWithoutArtboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutWhiteboardsNestedInput
  }

  export type WhiteboardUncheckedUpdateWithoutArtboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSlidesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mentorships?: MentorshipCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSlidesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatar?: string | null
    bio?: string | null
    passwordHash?: string | null
    role?: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mentorProfile?: MentorProfileUncheckedCreateNestedOneWithoutUserInput
    menteeProfile?: MenteeProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mentorships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    menteeships?: MentorshipMenteeUncheckedCreateNestedManyWithoutMenteeInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    minutesCreated?: MeetingMinutesUncheckedCreateNestedManyWithoutAuthorInput
    goalsCreated?: GoalUncheckedCreateNestedManyWithoutCreatorInput
    feedbackGiven?: FeedbackUncheckedCreateNestedManyWithoutFromUserInput
    feedbackReceived?: FeedbackUncheckedCreateNestedManyWithoutToUserInput
    resourcesUploaded?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutMenteeInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutUserInput
    sessionReflections?: SessionReflectionUncheckedCreateNestedManyWithoutMenteeInput
    todoItems?: TodoItemUncheckedCreateNestedManyWithoutMenteeInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    ticketsCreated?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutAuthorInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSlidesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSlidesInput, UserUncheckedCreateWithoutSlidesInput>
  }

  export type UserUpsertWithoutSlidesInput = {
    update: XOR<UserUpdateWithoutSlidesInput, UserUncheckedUpdateWithoutSlidesInput>
    create: XOR<UserCreateWithoutSlidesInput, UserUncheckedCreateWithoutSlidesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSlidesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSlidesInput, UserUncheckedUpdateWithoutSlidesInput>
  }

  export type UserUpdateWithoutSlidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSlidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorProfile?: MentorProfileUncheckedUpdateOneWithoutUserNestedInput
    menteeProfile?: MenteeProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mentorships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    menteeships?: MentorshipMenteeUncheckedUpdateManyWithoutMenteeNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    minutesCreated?: MeetingMinutesUncheckedUpdateManyWithoutAuthorNestedInput
    goalsCreated?: GoalUncheckedUpdateManyWithoutCreatorNestedInput
    feedbackGiven?: FeedbackUncheckedUpdateManyWithoutFromUserNestedInput
    feedbackReceived?: FeedbackUncheckedUpdateManyWithoutToUserNestedInput
    resourcesUploaded?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutMenteeNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutUserNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMenteeNestedInput
    todoItems?: TodoItemUncheckedUpdateManyWithoutMenteeNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    ticketsCreated?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutAuthorNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type MentorshipCreateManyMentorInput = {
    id?: string
    type?: string
    status?: string
    programCycleId: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorshipMenteeCreateManyMenteeInput = {
    id?: string
    mentorshipId: string
    joinedAt?: Date | string
    status?: string
  }

  export type MeetingCreateManyCreatorInput = {
    id?: string
    mentorshipId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyUserInput = {
    id?: string
    meetingId: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MeetingMinutesCreateManyAuthorInput = {
    id?: string
    meetingId: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCreateManyCreatorInput = {
    id?: string
    mentorshipId: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManyFromUserInput = {
    id?: string
    mentorshipId: string
    toUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManyToUserInput = {
    id?: string
    mentorshipId: string
    fromUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateManyUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    fileUrl?: string | null
    linkUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    category?: string | null
    tags?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    link?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PortfolioCreateManyMenteeInput = {
    id?: string
    personalityMbti?: string | null
    personalityDisc?: string | null
    personalityHolland?: string | null
    competencies?: string | null
    shortTermGoals?: string | null
    longTermGoals?: string | null
    initialCompletedAt?: Date | string | null
    initialStrengths?: string | null
    initialWeaknesses?: string | null
    initialChallenges?: string | null
    initialStartupIdeas?: string | null
    initialPersonalNotes?: string | null
    finalGoalsAchieved?: number | null
    finalSkillsGained?: string | null
    finalMentorFeedback?: string | null
    finalSelfAssessment?: string | null
    finalRecommendations?: string | null
    finalStrengths?: string | null
    finalWeaknesses?: string | null
    finalChallenges?: string | null
    finalStartupIdeas?: string | null
    finalPersonalNotes?: string | null
    finalCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateManyUserInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionReflectionCreateManyMenteeInput = {
    id?: string
    meetingId: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoItemCreateManyMenteeInput = {
    id?: string
    reflectionId?: string | null
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: string
    entityId?: string | null
    entityType?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyUserInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateManyAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: string
    priority?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentCreateManyUserInput = {
    id?: string
    ticketId: string
    content: string
    createdAt?: Date | string
  }

  export type WikiPageCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    content?: string | null
    category?: string | null
    visibility?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhiteboardCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    thumbnail?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlideCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    theme?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorshipUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programCycle?: ProgramCycleUpdateOneRequiredWithoutMentorshipsNestedInput
    mentees?: MentorshipMenteeUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentees?: MentorshipMenteeUncheckedUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUncheckedUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateManyWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programCycleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipMenteeUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    mentorship?: MentorshipUpdateOneRequiredWithoutMenteesNestedInput
  }

  export type MentorshipMenteeUncheckedUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MentorshipMenteeUncheckedUpdateManyWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutMeetingsNestedInput
    attendances?: AttendanceUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUncheckedUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingMinutesUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutMinutesNestedInput
  }

  export type MeetingMinutesUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingMinutesUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutGoalsNestedInput
    progressNotes?: ProgressNoteUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressNotes?: ProgressNoteUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutFeedbacksNestedInput
    toUser?: UserUpdateOneRequiredWithoutFeedbackReceivedNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentorship?: MentorshipUpdateOneRequiredWithoutFeedbacksNestedInput
    fromUser?: UserUpdateOneRequiredWithoutFeedbackGivenNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorshipId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    personalityMbti?: NullableStringFieldUpdateOperationsInput | string | null
    personalityDisc?: NullableStringFieldUpdateOperationsInput | string | null
    personalityHolland?: NullableStringFieldUpdateOperationsInput | string | null
    competencies?: NullableStringFieldUpdateOperationsInput | string | null
    shortTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    longTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    initialCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    initialWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    initialChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    initialStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    initialPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalGoalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    finalSkillsGained?: NullableStringFieldUpdateOperationsInput | string | null
    finalMentorFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    finalSelfAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    finalRecommendations?: NullableStringFieldUpdateOperationsInput | string | null
    finalStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    finalWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    finalChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    finalStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    finalPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUncheckedUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    personalityMbti?: NullableStringFieldUpdateOperationsInput | string | null
    personalityDisc?: NullableStringFieldUpdateOperationsInput | string | null
    personalityHolland?: NullableStringFieldUpdateOperationsInput | string | null
    competencies?: NullableStringFieldUpdateOperationsInput | string | null
    shortTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    longTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    initialCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    initialWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    initialChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    initialStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    initialPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalGoalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    finalSkillsGained?: NullableStringFieldUpdateOperationsInput | string | null
    finalMentorFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    finalSelfAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    finalRecommendations?: NullableStringFieldUpdateOperationsInput | string | null
    finalStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    finalWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    finalChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    finalStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    finalPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUncheckedUpdateManyWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    personalityMbti?: NullableStringFieldUpdateOperationsInput | string | null
    personalityDisc?: NullableStringFieldUpdateOperationsInput | string | null
    personalityHolland?: NullableStringFieldUpdateOperationsInput | string | null
    competencies?: NullableStringFieldUpdateOperationsInput | string | null
    shortTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    longTermGoals?: NullableStringFieldUpdateOperationsInput | string | null
    initialCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    initialWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    initialChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    initialStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    initialPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalGoalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    finalSkillsGained?: NullableStringFieldUpdateOperationsInput | string | null
    finalMentorFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    finalSelfAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    finalRecommendations?: NullableStringFieldUpdateOperationsInput | string | null
    finalStrengths?: NullableStringFieldUpdateOperationsInput | string | null
    finalWeaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    finalChallenges?: NullableStringFieldUpdateOperationsInput | string | null
    finalStartupIdeas?: NullableStringFieldUpdateOperationsInput | string | null
    finalPersonalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    finalCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionReflectionUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutSessionReflectionsNestedInput
    todoItems?: TodoItemUpdateManyWithoutReflectionNestedInput
  }

  export type SessionReflectionUncheckedUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    todoItems?: TodoItemUncheckedUpdateManyWithoutReflectionNestedInput
  }

  export type SessionReflectionUncheckedUpdateManyWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reflection?: SessionReflectionUpdateOneWithoutTodoItemsNestedInput
  }

  export type TodoItemUncheckedUpdateWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reflectionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemUncheckedUpdateManyWithoutMenteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reflectionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsCreatedNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artboards?: ArtboardUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artboards?: ArtboardUncheckedUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlideUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlideUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlideUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipCreateManyProgramCycleInput = {
    id?: string
    mentorId: string
    type?: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    maxMentees?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorshipUpdateWithoutProgramCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor?: UserUpdateOneRequiredWithoutMentorshipsNestedInput
    mentees?: MentorshipMenteeUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutProgramCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentees?: MentorshipMenteeUncheckedUpdateManyWithoutMentorshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutMentorshipNestedInput
    goals?: GoalUncheckedUpdateManyWithoutMentorshipNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutMentorshipNestedInput
  }

  export type MentorshipUncheckedUpdateManyWithoutProgramCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxMentees?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorshipMenteeCreateManyMentorshipInput = {
    id?: string
    menteeId: string
    joinedAt?: Date | string
    status?: string
  }

  export type MeetingCreateManyMentorshipInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    type?: string
    meetingType?: string
    scheduledAt: Date | string
    duration?: number
    location?: string | null
    meetingUrl?: string | null
    status?: string
    qrToken?: string | null
    qrExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCreateManyMentorshipInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category?: string
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManyMentorshipInput = {
    id?: string
    fromUserId: string
    toUserId: string
    type?: string
    rating?: number | null
    communication?: number | null
    engagement?: number | null
    content?: string | null
    strengths?: string | null
    improvements?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MentorshipMenteeUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    mentee?: UserUpdateOneRequiredWithoutMenteeshipsNestedInput
  }

  export type MentorshipMenteeUncheckedUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MentorshipMenteeUncheckedUpdateManyWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutMeetingsCreatedNestedInput
    attendances?: AttendanceUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutMeetingNestedInput
    minutes?: MeetingMinutesUncheckedUpdateManyWithoutMeetingNestedInput
    sessionReflections?: SessionReflectionUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateManyWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutGoalsCreatedNestedInput
    progressNotes?: ProgressNoteUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressNotes?: ProgressNoteUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateManyWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    targetValue?: NullableIntFieldUpdateOperationsInput | number | null
    currentValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutFeedbackGivenNestedInput
    toUser?: UserUpdateOneRequiredWithoutFeedbackReceivedNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutMentorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyMeetingInput = {
    id?: string
    userId: string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    checkInLat?: number | null
    checkInLng?: number | null
    deviceHash?: string | null
    status?: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MeetingMinutesCreateManyMeetingInput = {
    id?: string
    authorId: string
    agenda?: string | null
    keyPoints?: string | null
    actionItems?: string | null
    outcome?: string | null
    attachments?: string | null
    status?: string
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionReflectionCreateManyMeetingInput = {
    id?: string
    menteeId: string
    content?: string | null
    mentorConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    checkInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingMinutesUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutMinutesCreatedNestedInput
  }

  export type MeetingMinutesUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingMinutesUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionReflectionUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee?: UserUpdateOneRequiredWithoutSessionReflectionsNestedInput
    todoItems?: TodoItemUpdateManyWithoutReflectionNestedInput
  }

  export type SessionReflectionUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    todoItems?: TodoItemUncheckedUpdateManyWithoutReflectionNestedInput
  }

  export type SessionReflectionUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mentorConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressNoteCreateManyGoalInput = {
    id?: string
    note: string
    value?: number | null
    createdAt?: Date | string
  }

  export type ProgressNoteUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressNoteUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressNoteUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemCreateManyReflectionInput = {
    id?: string
    menteeId: string
    title: string
    status?: string
    priority?: string
    dueDate?: Date | string | null
    startDate?: Date | string | null
    column?: string
    labels?: string | null
    description?: string | null
    attachments?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoItemUpdateWithoutReflectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee?: UserUpdateOneRequiredWithoutTodoItemsNestedInput
  }

  export type TodoItemUncheckedUpdateWithoutReflectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemUncheckedUpdateManyWithoutReflectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    menteeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    column?: StringFieldUpdateOperationsInput | string
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateManyTicketInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtboardCreateManyWhiteboardInput = {
    id?: string
    order?: number
    name?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtboardUpdateWithoutWhiteboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtboardUncheckedUpdateWithoutWhiteboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtboardUncheckedUpdateManyWithoutWhiteboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    appState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}